diff --git a/dist/L.Control.Heightgraph.js b/dist/L.Control.Heightgraph.js
index 9d4f3c1ae4408936c97520282d30e3ae6978cfc2..dc224c5bb3632b3e0fc1214e656cfb79936d69d3 100644
--- a/dist/L.Control.Heightgraph.js
+++ b/dist/L.Control.Heightgraph.js
@@ -2890,6 +2890,176 @@ selection.prototype.properties = selection_properties;
 transition.prototype.attrs = transition_attrs;
 transition.prototype.styles = transition_styles;
 
+var slice = Array.prototype.slice;
+
+function identity$1(x) {
+  return x;
+}
+
+var top = 1,
+    right = 2,
+    bottom = 3,
+    left = 4,
+    epsilon = 1e-6;
+
+function translateX(x) {
+  return "translate(" + (x + 0.5) + ",0)";
+}
+
+function translateY(y) {
+  return "translate(0," + (y + 0.5) + ")";
+}
+
+function number(scale) {
+  return function(d) {
+    return +scale(d);
+  };
+}
+
+function center(scale) {
+  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
+  if (scale.round()) offset = Math.round(offset);
+  return function(d) {
+    return +scale(d) + offset;
+  };
+}
+
+function entering() {
+  return !this.__axis;
+}
+
+function axis(orient, scale) {
+  var tickArguments = [],
+      tickValues = null,
+      tickFormat = null,
+      tickSizeInner = 6,
+      tickSizeOuter = 6,
+      tickPadding = 3,
+      k = orient === top || orient === left ? -1 : 1,
+      x = orient === left || orient === right ? "x" : "y",
+      transform = orient === top || orient === bottom ? translateX : translateY;
+
+  function axis(context) {
+    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
+        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
+        spacing = Math.max(tickSizeInner, 0) + tickPadding,
+        range = scale.range(),
+        range0 = +range[0] + 0.5,
+        range1 = +range[range.length - 1] + 0.5,
+        position = (scale.bandwidth ? center : number)(scale.copy()),
+        selection = context.selection ? context.selection() : context,
+        path = selection.selectAll(".domain").data([null]),
+        tick = selection.selectAll(".tick").data(values, scale).order(),
+        tickExit = tick.exit(),
+        tickEnter = tick.enter().append("g").attr("class", "tick"),
+        line = tick.select("line"),
+        text = tick.select("text");
+
+    path = path.merge(path.enter().insert("path", ".tick")
+        .attr("class", "domain")
+        .attr("stroke", "currentColor"));
+
+    tick = tick.merge(tickEnter);
+
+    line = line.merge(tickEnter.append("line")
+        .attr("stroke", "currentColor")
+        .attr(x + "2", k * tickSizeInner));
+
+    text = text.merge(tickEnter.append("text")
+        .attr("fill", "currentColor")
+        .attr(x, k * spacing)
+        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
+
+    if (context !== selection) {
+      path = path.transition(context);
+      tick = tick.transition(context);
+      line = line.transition(context);
+      text = text.transition(context);
+
+      tickExit = tickExit.transition(context)
+          .attr("opacity", epsilon)
+          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });
+
+      tickEnter
+          .attr("opacity", epsilon)
+          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
+    }
+
+    tickExit.remove();
+
+    path
+        .attr("d", orient === left || orient == right
+            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
+            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));
+
+    tick
+        .attr("opacity", 1)
+        .attr("transform", function(d) { return transform(position(d)); });
+
+    line
+        .attr(x + "2", k * tickSizeInner);
+
+    text
+        .attr(x, k * spacing)
+        .text(format);
+
+    selection.filter(entering)
+        .attr("fill", "none")
+        .attr("font-size", 10)
+        .attr("font-family", "sans-serif")
+        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
+
+    selection
+        .each(function() { this.__axis = position; });
+  }
+
+  axis.scale = function(_) {
+    return arguments.length ? (scale = _, axis) : scale;
+  };
+
+  axis.ticks = function() {
+    return tickArguments = slice.call(arguments), axis;
+  };
+
+  axis.tickArguments = function(_) {
+    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
+  };
+
+  axis.tickValues = function(_) {
+    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
+  };
+
+  axis.tickFormat = function(_) {
+    return arguments.length ? (tickFormat = _, axis) : tickFormat;
+  };
+
+  axis.tickSize = function(_) {
+    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
+  };
+
+  axis.tickSizeInner = function(_) {
+    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
+  };
+
+  axis.tickSizeOuter = function(_) {
+    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
+  };
+
+  axis.tickPadding = function(_) {
+    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
+  };
+
+  return axis;
+}
+
+function axisBottom(scale) {
+  return axis(bottom, scale);
+}
+
+function axisLeft(scale) {
+  return axis(left, scale);
+}
+
 function ascending$1(a, b) {
   return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
 }
@@ -3051,752 +3221,602 @@ function d3Min(values, valueof) {
   return min;
 }
 
-function initRange(domain, range) {
-  switch (arguments.length) {
-    case 0: break;
-    case 1: this.range(domain); break;
-    default: this.range(range).domain(domain); break;
-  }
-  return this;
-}
+var pi = Math.PI,
+    tau = 2 * pi,
+    epsilon$1 = 1e-6,
+    tauEpsilon = tau - epsilon$1;
 
-var prefix = "$";
+function Path() {
+  this._x0 = this._y0 = // start of current subpath
+  this._x1 = this._y1 = null; // end of current subpath
+  this._ = "";
+}
 
-function Map() {}
+function path() {
+  return new Path;
+}
 
-Map.prototype = map.prototype = {
-  constructor: Map,
-  has: function(key) {
-    return (prefix + key) in this;
-  },
-  get: function(key) {
-    return this[prefix + key];
-  },
-  set: function(key, value) {
-    this[prefix + key] = value;
-    return this;
-  },
-  remove: function(key) {
-    var property = prefix + key;
-    return property in this && delete this[property];
-  },
-  clear: function() {
-    for (var property in this) if (property[0] === prefix) delete this[property];
-  },
-  keys: function() {
-    var keys = [];
-    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
-    return keys;
+Path.prototype = path.prototype = {
+  constructor: Path,
+  moveTo: function(x, y) {
+    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
   },
-  values: function() {
-    var values = [];
-    for (var property in this) if (property[0] === prefix) values.push(this[property]);
-    return values;
+  closePath: function() {
+    if (this._x1 !== null) {
+      this._x1 = this._x0, this._y1 = this._y0;
+      this._ += "Z";
+    }
   },
-  entries: function() {
-    var entries = [];
-    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
-    return entries;
+  lineTo: function(x, y) {
+    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
   },
-  size: function() {
-    var size = 0;
-    for (var property in this) if (property[0] === prefix) ++size;
-    return size;
+  quadraticCurveTo: function(x1, y1, x, y) {
+    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
   },
-  empty: function() {
-    for (var property in this) if (property[0] === prefix) return false;
-    return true;
+  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
+    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
   },
-  each: function(f) {
-    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
-  }
-};
+  arcTo: function(x1, y1, x2, y2, r) {
+    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
+    var x0 = this._x1,
+        y0 = this._y1,
+        x21 = x2 - x1,
+        y21 = y2 - y1,
+        x01 = x0 - x1,
+        y01 = y0 - y1,
+        l01_2 = x01 * x01 + y01 * y01;
 
-function map(object, f) {
-  var map = new Map;
+    // Is the radius negative? Error.
+    if (r < 0) throw new Error("negative radius: " + r);
 
-  // Copy constructor.
-  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });
-
-  // Index array by numeric index or specified key function.
-  else if (Array.isArray(object)) {
-    var i = -1,
-        n = object.length,
-        o;
-
-    if (f == null) while (++i < n) map.set(i, object[i]);
-    else while (++i < n) map.set(f(o = object[i], i, object), o);
-  }
+    // Is this path empty? Move to (x1,y1).
+    if (this._x1 === null) {
+      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
+    }
 
-  // Convert object to map.
-  else if (object) for (var key in object) map.set(key, object[key]);
+    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
+    else if (!(l01_2 > epsilon$1));
 
-  return map;
-}
+    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
+    // Equivalently, is (x1,y1) coincident with (x2,y2)?
+    // Or, is the radius zero? Line to (x1,y1).
+    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
+      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
+    }
 
-function Set() {}
+    // Otherwise, draw an arc!
+    else {
+      var x20 = x2 - x0,
+          y20 = y2 - y0,
+          l21_2 = x21 * x21 + y21 * y21,
+          l20_2 = x20 * x20 + y20 * y20,
+          l21 = Math.sqrt(l21_2),
+          l01 = Math.sqrt(l01_2),
+          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
+          t01 = l / l01,
+          t21 = l / l21;
 
-var proto = map.prototype;
+      // If the start tangent is not coincident with (x0,y0), line to.
+      if (Math.abs(t01 - 1) > epsilon$1) {
+        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
+      }
 
-Set.prototype = set$2.prototype = {
-  constructor: Set,
-  has: proto.has,
-  add: function(value) {
-    value += "";
-    this[prefix + value] = value;
-    return this;
+      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
+    }
   },
-  remove: proto.remove,
-  clear: proto.clear,
-  values: proto.keys,
-  size: proto.size,
-  empty: proto.empty,
-  each: proto.each
-};
-
-function set$2(object, f) {
-  var set = new Set;
-
-  // Copy constructor.
-  if (object instanceof Set) object.each(function(value) { set.add(value); });
+  arc: function(x, y, r, a0, a1, ccw) {
+    x = +x, y = +y, r = +r, ccw = !!ccw;
+    var dx = r * Math.cos(a0),
+        dy = r * Math.sin(a0),
+        x0 = x + dx,
+        y0 = y + dy,
+        cw = 1 ^ ccw,
+        da = ccw ? a0 - a1 : a1 - a0;
 
-  // Otherwise, assume it’s an array.
-  else if (object) {
-    var i = -1, n = object.length;
-    if (f == null) while (++i < n) set.add(object[i]);
-    else while (++i < n) set.add(f(object[i], i, object));
-  }
+    // Is the radius negative? Error.
+    if (r < 0) throw new Error("negative radius: " + r);
 
-  return set;
-}
+    // Is this path empty? Move to (x0,y0).
+    if (this._x1 === null) {
+      this._ += "M" + x0 + "," + y0;
+    }
 
-var array = Array.prototype;
+    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
+    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
+      this._ += "L" + x0 + "," + y0;
+    }
 
-var map$1 = array.map;
-var slice = array.slice;
+    // Is this arc empty? We’re done.
+    if (!r) return;
 
-var implicit = {name: "implicit"};
+    // Does the angle go the wrong way? Flip the direction.
+    if (da < 0) da = da % tau + tau;
 
-function ordinal() {
-  var index = map(),
-      domain = [],
-      range = [],
-      unknown = implicit;
+    // Is this a complete circle? Draw two arcs to complete the circle.
+    if (da > tauEpsilon) {
+      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
+    }
 
-  function scale(d) {
-    var key = d + "", i = index.get(key);
-    if (!i) {
-      if (unknown !== implicit) return unknown;
-      index.set(key, i = domain.push(d));
+    // Is this arc non-empty? Draw an arc!
+    else if (da > epsilon$1) {
+      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
     }
-    return range[(i - 1) % range.length];
+  },
+  rect: function(x, y, w, h) {
+    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
+  },
+  toString: function() {
+    return this._;
   }
-
-  scale.domain = function(_) {
-    if (!arguments.length) return domain.slice();
-    domain = [], index = map();
-    var i = -1, n = _.length, d, key;
-    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
-    return scale;
-  };
-
-  scale.range = function(_) {
-    return arguments.length ? (range = slice.call(_), scale) : range.slice();
-  };
-
-  scale.unknown = function(_) {
-    return arguments.length ? (unknown = _, scale) : unknown;
-  };
-
-  scale.copy = function() {
-    return ordinal(domain, range).unknown(unknown);
-  };
-
-  initRange.apply(scale, arguments);
-
-  return scale;
-}
+};
 
 function constant$2(x) {
-  return function() {
+  return function constant() {
     return x;
   };
 }
 
-function number(x) {
-  return +x;
+var pi$1 = Math.PI;
+var tau$1 = 2 * pi$1;
+
+function Linear(context) {
+  this._context = context;
 }
 
-var unit = [0, 1];
+Linear.prototype = {
+  areaStart: function() {
+    this._line = 0;
+  },
+  areaEnd: function() {
+    this._line = NaN;
+  },
+  lineStart: function() {
+    this._point = 0;
+  },
+  lineEnd: function() {
+    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
+    this._line = 1 - this._line;
+  },
+  point: function(x, y) {
+    x = +x, y = +y;
+    switch (this._point) {
+      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
+      case 1: this._point = 2; // proceed
+      default: this._context.lineTo(x, y); break;
+    }
+  }
+};
 
-function identity$1(x) {
-  return x;
+function curveLinear(context) {
+  return new Linear(context);
 }
 
-function normalize(a, b) {
-  return (b -= (a = +a))
-      ? function(x) { return (x - a) / b; }
-      : constant$2(isNaN(b) ? NaN : 0.5);
+function x(p) {
+  return p[0];
 }
 
-function clamper(domain) {
-  var a = domain[0], b = domain[domain.length - 1], t;
-  if (a > b) t = a, a = b, b = t;
-  return function(x) { return Math.max(a, Math.min(b, x)); };
+function y(p) {
+  return p[1];
 }
 
-// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
-// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
-function bimap(domain, range, interpolate) {
-  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
-  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
-  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
-  return function(x) { return r0(d0(x)); };
-}
+function line() {
+  var x$1 = x,
+      y$1 = y,
+      defined = constant$2(true),
+      context = null,
+      curve = curveLinear,
+      output = null;
 
-function polymap(domain, range, interpolate) {
-  var j = Math.min(domain.length, range.length) - 1,
-      d = new Array(j),
-      r = new Array(j),
-      i = -1;
+  function line(data) {
+    var i,
+        n = data.length,
+        d,
+        defined0 = false,
+        buffer;
 
-  // Reverse descending domains.
-  if (domain[j] < domain[0]) {
-    domain = domain.slice().reverse();
-    range = range.slice().reverse();
-  }
+    if (context == null) output = curve(buffer = path());
 
-  while (++i < j) {
-    d[i] = normalize(domain[i], domain[i + 1]);
-    r[i] = interpolate(range[i], range[i + 1]);
+    for (i = 0; i <= n; ++i) {
+      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
+        if (defined0 = !defined0) output.lineStart();
+        else output.lineEnd();
+      }
+      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
+    }
+
+    if (buffer) return output = null, buffer + "" || null;
   }
 
-  return function(x) {
-    var i = bisectRight(domain, x, 1, j) - 1;
-    return r[i](d[i](x));
+  line.x = function(_) {
+    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$2(+_), line) : x$1;
   };
-}
 
-function copy(source, target) {
-  return target
-      .domain(source.domain())
-      .range(source.range())
-      .interpolate(source.interpolate())
-      .clamp(source.clamp())
-      .unknown(source.unknown());
-}
+  line.y = function(_) {
+    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$2(+_), line) : y$1;
+  };
 
-function transformer() {
-  var domain = unit,
-      range = unit,
-      interpolate = interpolateValue,
-      transform,
-      untransform,
-      unknown,
-      clamp = identity$1,
-      piecewise,
-      output,
-      input;
+  line.defined = function(_) {
+    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), line) : defined;
+  };
 
-  function rescale() {
-    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
-    output = input = null;
-    return scale;
+  line.curve = function(_) {
+    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
+  };
+
+  line.context = function(_) {
+    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
+  };
+
+  return line;
+}
+
+function d3Area() {
+  var x0 = x,
+      x1 = null,
+      y0 = constant$2(0),
+      y1 = y,
+      defined = constant$2(true),
+      context = null,
+      curve = curveLinear,
+      output = null;
+
+  function area(data) {
+    var i,
+        j,
+        k,
+        n = data.length,
+        d,
+        defined0 = false,
+        buffer,
+        x0z = new Array(n),
+        y0z = new Array(n);
+
+    if (context == null) output = curve(buffer = path());
+
+    for (i = 0; i <= n; ++i) {
+      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
+        if (defined0 = !defined0) {
+          j = i;
+          output.areaStart();
+          output.lineStart();
+        } else {
+          output.lineEnd();
+          output.lineStart();
+          for (k = i - 1; k >= j; --k) {
+            output.point(x0z[k], y0z[k]);
+          }
+          output.lineEnd();
+          output.areaEnd();
+        }
+      }
+      if (defined0) {
+        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
+        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
+      }
+    }
+
+    if (buffer) return output = null, buffer + "" || null;
   }
 
-  function scale(x) {
-    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
+  function arealine() {
+    return line().defined(defined).curve(curve).context(context);
   }
 
-  scale.invert = function(y) {
-    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
+  area.x = function(_) {
+    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area) : x0;
   };
 
-  scale.domain = function(_) {
-    return arguments.length ? (domain = map$1.call(_, number), clamp === identity$1 || (clamp = clamper(domain)), rescale()) : domain.slice();
+  area.x0 = function(_) {
+    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area) : x0;
   };
 
-  scale.range = function(_) {
-    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
+  area.x1 = function(_) {
+    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : x1;
   };
 
-  scale.rangeRound = function(_) {
-    return range = slice.call(_), interpolate = interpolateRound, rescale();
+  area.y = function(_) {
+    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area) : y0;
   };
 
-  scale.clamp = function(_) {
-    return arguments.length ? (clamp = _ ? clamper(domain) : identity$1, scale) : clamp !== identity$1;
+  area.y0 = function(_) {
+    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area) : y0;
   };
 
-  scale.interpolate = function(_) {
-    return arguments.length ? (interpolate = _, rescale()) : interpolate;
+  area.y1 = function(_) {
+    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : y1;
   };
 
-  scale.unknown = function(_) {
-    return arguments.length ? (unknown = _, scale) : unknown;
+  area.lineX0 =
+  area.lineY0 = function() {
+    return arealine().x(x0).y(y0);
   };
 
-  return function(t, u) {
-    transform = t, untransform = u;
-    return rescale();
+  area.lineY1 = function() {
+    return arealine().x(x0).y(y1);
   };
-}
 
-function continuous(transform, untransform) {
-  return transformer()(transform, untransform);
-}
+  area.lineX1 = function() {
+    return arealine().x(x1).y(y0);
+  };
 
-// Computes the decimal coefficient and exponent of the specified number x with
-// significant digits p, where x is positive and p is in [1, 21] or undefined.
-// For example, formatDecimal(1.23) returns ["123", 0].
-function formatDecimal(x, p) {
-  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
-  var i, coefficient = x.slice(0, i);
+  area.defined = function(_) {
+    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), area) : defined;
+  };
 
-  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
-  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
-  return [
-    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
-    +x.slice(i + 1)
-  ];
-}
+  area.curve = function(_) {
+    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
+  };
 
-function exponent(x) {
-  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
+  area.context = function(_) {
+    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
+  };
+
+  return area;
 }
 
-function formatGroup(grouping, thousands) {
-  return function(value, width) {
-    var i = value.length,
-        t = [],
-        j = 0,
-        g = grouping[0],
-        length = 0;
+var circle = {
+  draw: function(context, size) {
+    var r = Math.sqrt(size / pi$1);
+    context.moveTo(r, 0);
+    context.arc(0, 0, r, 0, tau$1);
+  }
+};
 
-    while (i > 0 && g > 0) {
-      if (length + g + 1 > width) g = Math.max(1, width - length);
-      t.push(value.substring(i -= g, i + g));
-      if ((length += g + 1) > width) break;
-      g = grouping[j = (j + 1) % grouping.length];
-    }
+var sqrt3 = Math.sqrt(3);
 
-    return t.reverse().join(thousands);
+var symbolTriangle = {
+  draw: function(context, size) {
+    var y = -Math.sqrt(size / (sqrt3 * 3));
+    context.moveTo(0, y * 2);
+    context.lineTo(-sqrt3 * y, -y);
+    context.lineTo(sqrt3 * y, -y);
+    context.closePath();
+  }
+};
+
+function symbol() {
+  var type = constant$2(circle),
+      size = constant$2(64),
+      context = null;
+
+  function symbol() {
+    var buffer;
+    if (!context) context = buffer = path();
+    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
+    if (buffer) return context = null, buffer + "" || null;
+  }
+
+  symbol.type = function(_) {
+    return arguments.length ? (type = typeof _ === "function" ? _ : constant$2(_), symbol) : type;
   };
-}
 
-function formatNumerals(numerals) {
-  return function(value) {
-    return value.replace(/[0-9]/g, function(i) {
-      return numerals[+i];
-    });
+  symbol.size = function(_) {
+    return arguments.length ? (size = typeof _ === "function" ? _ : constant$2(+_), symbol) : size;
   };
-}
 
-// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
-var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+  symbol.context = function(_) {
+    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
+  };
 
-function formatSpecifier(specifier) {
-  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
-  var match;
-  return new FormatSpecifier({
-    fill: match[1],
-    align: match[2],
-    sign: match[3],
-    symbol: match[4],
-    zero: match[5],
-    width: match[6],
-    comma: match[7],
-    precision: match[8] && match[8].slice(1),
-    trim: match[9],
-    type: match[10]
-  });
+  return symbol;
 }
 
-formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
-
-function FormatSpecifier(specifier) {
-  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
-  this.align = specifier.align === undefined ? ">" : specifier.align + "";
-  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
-  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
-  this.zero = !!specifier.zero;
-  this.width = specifier.width === undefined ? undefined : +specifier.width;
-  this.comma = !!specifier.comma;
-  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
-  this.trim = !!specifier.trim;
-  this.type = specifier.type === undefined ? "" : specifier.type + "";
+function point$1(that, x, y) {
+  that._context.bezierCurveTo(
+    (2 * that._x0 + that._x1) / 3,
+    (2 * that._y0 + that._y1) / 3,
+    (that._x0 + 2 * that._x1) / 3,
+    (that._y0 + 2 * that._y1) / 3,
+    (that._x0 + 4 * that._x1 + x) / 6,
+    (that._y0 + 4 * that._y1 + y) / 6
+  );
 }
 
-FormatSpecifier.prototype.toString = function() {
-  return this.fill
-      + this.align
-      + this.sign
-      + this.symbol
-      + (this.zero ? "0" : "")
-      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
-      + (this.comma ? "," : "")
-      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
-      + (this.trim ? "~" : "")
-      + this.type;
-};
-
-// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
-function formatTrim(s) {
-  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
-    switch (s[i]) {
-      case ".": i0 = i1 = i; break;
-      case "0": if (i0 === 0) i0 = i; i1 = i; break;
-      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
-    }
-  }
-  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
+function Basis(context) {
+  this._context = context;
 }
 
-var prefixExponent;
-
-function formatPrefixAuto(x, p) {
-  var d = formatDecimal(x, p);
-  if (!d) return x + "";
-  var coefficient = d[0],
-      exponent = d[1],
-      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
-      n = coefficient.length;
-  return i === n ? coefficient
-      : i > n ? coefficient + new Array(i - n + 1).join("0")
-      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
-      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
-}
-
-function formatRounded(x, p) {
-  var d = formatDecimal(x, p);
-  if (!d) return x + "";
-  var coefficient = d[0],
-      exponent = d[1];
-  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
-      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
-      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
-}
-
-var formatTypes = {
-  "%": function(x, p) { return (x * 100).toFixed(p); },
-  "b": function(x) { return Math.round(x).toString(2); },
-  "c": function(x) { return x + ""; },
-  "d": function(x) { return Math.round(x).toString(10); },
-  "e": function(x, p) { return x.toExponential(p); },
-  "f": function(x, p) { return x.toFixed(p); },
-  "g": function(x, p) { return x.toPrecision(p); },
-  "o": function(x) { return Math.round(x).toString(8); },
-  "p": function(x, p) { return formatRounded(x * 100, p); },
-  "r": formatRounded,
-  "s": formatPrefixAuto,
-  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
-  "x": function(x) { return Math.round(x).toString(16); }
+Basis.prototype = {
+  areaStart: function() {
+    this._line = 0;
+  },
+  areaEnd: function() {
+    this._line = NaN;
+  },
+  lineStart: function() {
+    this._x0 = this._x1 =
+    this._y0 = this._y1 = NaN;
+    this._point = 0;
+  },
+  lineEnd: function() {
+    switch (this._point) {
+      case 3: point$1(this, this._x1, this._y1); // proceed
+      case 2: this._context.lineTo(this._x1, this._y1); break;
+    }
+    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
+    this._line = 1 - this._line;
+  },
+  point: function(x, y) {
+    x = +x, y = +y;
+    switch (this._point) {
+      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
+      case 1: this._point = 2; break;
+      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
+      default: point$1(this, x, y); break;
+    }
+    this._x0 = this._x1, this._x1 = x;
+    this._y0 = this._y1, this._y1 = y;
+  }
 };
 
-function identity$2(x) {
-  return x;
+function curveBasis(context) {
+  return new Basis(context);
 }
 
-var map$2 = Array.prototype.map,
-    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];
-
-function formatLocale(locale) {
-  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$2 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""),
-      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
-      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
-      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
-      numerals = locale.numerals === undefined ? identity$2 : formatNumerals(map$2.call(locale.numerals, String)),
-      percent = locale.percent === undefined ? "%" : locale.percent + "",
-      minus = locale.minus === undefined ? "-" : locale.minus + "",
-      nan = locale.nan === undefined ? "NaN" : locale.nan + "";
-
-  function newFormat(specifier) {
-    specifier = formatSpecifier(specifier);
-
-    var fill = specifier.fill,
-        align = specifier.align,
-        sign = specifier.sign,
-        symbol = specifier.symbol,
-        zero = specifier.zero,
-        width = specifier.width,
-        comma = specifier.comma,
-        precision = specifier.precision,
-        trim = specifier.trim,
-        type = specifier.type;
-
-    // The "n" type is an alias for ",g".
-    if (type === "n") comma = true, type = "g";
-
-    // The "" type, and any invalid type, is an alias for ".12~g".
-    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";
-
-    // If zero fill is specified, padding goes after sign and before digits.
-    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";
-
-    // Compute the prefix and suffix.
-    // For SI-prefix, the suffix is lazily computed.
-    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
-        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
-
-    // What format function should we use?
-    // Is this an integer type?
-    // Can this type generate exponential notation?
-    var formatType = formatTypes[type],
-        maybeSuffix = /[defgprs%]/.test(type);
-
-    // Set the default precision if not specified,
-    // or clamp the specified precision to the supported range.
-    // For significant precision, it must be in [1, 21].
-    // For fixed precision, it must be in [0, 20].
-    precision = precision === undefined ? 6
-        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
-        : Math.max(0, Math.min(20, precision));
-
-    function format(value) {
-      var valuePrefix = prefix,
-          valueSuffix = suffix,
-          i, n, c;
-
-      if (type === "c") {
-        valueSuffix = formatType(value) + valueSuffix;
-        value = "";
-      } else {
-        value = +value;
-
-        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
-        var valueNegative = value < 0 || 1 / value < 0;
-
-        // Perform the initial formatting.
-        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
-
-        // Trim insignificant zeros.
-        if (trim) value = formatTrim(value);
-
-        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
-        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
-
-        // Compute the prefix and suffix.
-        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
-        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
-
-        // Break the formatted value into the integer “value” part that can be
-        // grouped, and fractional or exponential “suffix” part that is not.
-        if (maybeSuffix) {
-          i = -1, n = value.length;
-          while (++i < n) {
-            if (c = value.charCodeAt(i), 48 > c || c > 57) {
-              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
-              value = value.slice(0, i);
-              break;
-            }
-          }
-        }
-      }
+function initRange(domain, range) {
+  switch (arguments.length) {
+    case 0: break;
+    case 1: this.range(domain); break;
+    default: this.range(range).domain(domain); break;
+  }
+  return this;
+}
 
-      // If the fill character is not "0", grouping is applied before padding.
-      if (comma && !zero) value = group(value, Infinity);
+var prefix = "$";
 
-      // Compute the padding.
-      var length = valuePrefix.length + value.length + valueSuffix.length,
-          padding = length < width ? new Array(width - length + 1).join(fill) : "";
+function Map() {}
 
-      // If the fill character is "0", grouping is applied after padding.
-      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
+Map.prototype = map.prototype = {
+  constructor: Map,
+  has: function(key) {
+    return (prefix + key) in this;
+  },
+  get: function(key) {
+    return this[prefix + key];
+  },
+  set: function(key, value) {
+    this[prefix + key] = value;
+    return this;
+  },
+  remove: function(key) {
+    var property = prefix + key;
+    return property in this && delete this[property];
+  },
+  clear: function() {
+    for (var property in this) if (property[0] === prefix) delete this[property];
+  },
+  keys: function() {
+    var keys = [];
+    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
+    return keys;
+  },
+  values: function() {
+    var values = [];
+    for (var property in this) if (property[0] === prefix) values.push(this[property]);
+    return values;
+  },
+  entries: function() {
+    var entries = [];
+    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
+    return entries;
+  },
+  size: function() {
+    var size = 0;
+    for (var property in this) if (property[0] === prefix) ++size;
+    return size;
+  },
+  empty: function() {
+    for (var property in this) if (property[0] === prefix) return false;
+    return true;
+  },
+  each: function(f) {
+    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
+  }
+};
 
-      // Reconstruct the final output based on the desired alignment.
-      switch (align) {
-        case "<": value = valuePrefix + value + valueSuffix + padding; break;
-        case "=": value = valuePrefix + padding + value + valueSuffix; break;
-        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
-        default: value = padding + valuePrefix + value + valueSuffix; break;
-      }
+function map(object, f) {
+  var map = new Map;
 
-      return numerals(value);
-    }
+  // Copy constructor.
+  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });
 
-    format.toString = function() {
-      return specifier + "";
-    };
+  // Index array by numeric index or specified key function.
+  else if (Array.isArray(object)) {
+    var i = -1,
+        n = object.length,
+        o;
 
-    return format;
+    if (f == null) while (++i < n) map.set(i, object[i]);
+    else while (++i < n) map.set(f(o = object[i], i, object), o);
   }
 
-  function formatPrefix(specifier, value) {
-    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
-        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
-        k = Math.pow(10, -e),
-        prefix = prefixes[8 + e / 3];
-    return function(value) {
-      return f(k * value) + prefix;
-    };
-  }
+  // Convert object to map.
+  else if (object) for (var key in object) map.set(key, object[key]);
 
-  return {
-    format: newFormat,
-    formatPrefix: formatPrefix
-  };
+  return map;
 }
 
-var locale;
-var format;
-var formatPrefix;
-
-defaultLocale({
-  decimal: ".",
-  thousands: ",",
-  grouping: [3],
-  currency: ["$", ""],
-  minus: "-"
-});
+function Set() {}
 
-function defaultLocale(definition) {
-  locale = formatLocale(definition);
-  format = locale.format;
-  formatPrefix = locale.formatPrefix;
-  return locale;
-}
+var proto = map.prototype;
 
-function precisionFixed(step) {
-  return Math.max(0, -exponent(Math.abs(step)));
-}
+Set.prototype = set$2.prototype = {
+  constructor: Set,
+  has: proto.has,
+  add: function(value) {
+    value += "";
+    this[prefix + value] = value;
+    return this;
+  },
+  remove: proto.remove,
+  clear: proto.clear,
+  values: proto.keys,
+  size: proto.size,
+  empty: proto.empty,
+  each: proto.each
+};
 
-function precisionPrefix(step, value) {
-  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
-}
+function set$2(object, f) {
+  var set = new Set;
 
-function precisionRound(step, max) {
-  step = Math.abs(step), max = Math.abs(max) - step;
-  return Math.max(0, exponent(max) - exponent(step)) + 1;
-}
+  // Copy constructor.
+  if (object instanceof Set) object.each(function(value) { set.add(value); });
 
-function tickFormat(start, stop, count, specifier) {
-  var step = tickStep(start, stop, count),
-      precision;
-  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
-  switch (specifier.type) {
-    case "s": {
-      var value = Math.max(Math.abs(start), Math.abs(stop));
-      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
-      return formatPrefix(specifier, value);
-    }
-    case "":
-    case "e":
-    case "g":
-    case "p":
-    case "r": {
-      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
-      break;
-    }
-    case "f":
-    case "%": {
-      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
-      break;
-    }
+  // Otherwise, assume it’s an array.
+  else if (object) {
+    var i = -1, n = object.length;
+    if (f == null) while (++i < n) set.add(object[i]);
+    else while (++i < n) set.add(f(object[i], i, object));
   }
-  return format(specifier);
-}
-
-function linearish(scale) {
-  var domain = scale.domain;
-
-  scale.ticks = function(count) {
-    var d = domain();
-    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
-  };
 
-  scale.tickFormat = function(count, specifier) {
-    var d = domain();
-    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
-  };
-
-  scale.nice = function(count) {
-    if (count == null) count = 10;
+  return set;
+}
 
-    var d = domain(),
-        i0 = 0,
-        i1 = d.length - 1,
-        start = d[i0],
-        stop = d[i1],
-        step;
+var array = Array.prototype;
 
-    if (stop < start) {
-      step = start, start = stop, stop = step;
-      step = i0, i0 = i1, i1 = step;
-    }
+var map$1 = array.map;
+var slice$1 = array.slice;
 
-    step = tickIncrement(start, stop, count);
+var implicit = {name: "implicit"};
 
-    if (step > 0) {
-      start = Math.floor(start / step) * step;
-      stop = Math.ceil(stop / step) * step;
-      step = tickIncrement(start, stop, count);
-    } else if (step < 0) {
-      start = Math.ceil(start * step) / step;
-      stop = Math.floor(stop * step) / step;
-      step = tickIncrement(start, stop, count);
-    }
+function ordinal() {
+  var index = map(),
+      domain = [],
+      range = [],
+      unknown = implicit;
 
-    if (step > 0) {
-      d[i0] = Math.floor(start / step) * step;
-      d[i1] = Math.ceil(stop / step) * step;
-      domain(d);
-    } else if (step < 0) {
-      d[i0] = Math.ceil(start * step) / step;
-      d[i1] = Math.floor(stop * step) / step;
-      domain(d);
+  function scale(d) {
+    var key = d + "", i = index.get(key);
+    if (!i) {
+      if (unknown !== implicit) return unknown;
+      index.set(key, i = domain.push(d));
     }
+    return range[(i - 1) % range.length];
+  }
 
+  scale.domain = function(_) {
+    if (!arguments.length) return domain.slice();
+    domain = [], index = map();
+    var i = -1, n = _.length, d, key;
+    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
     return scale;
   };
 
-  return scale;
-}
+  scale.range = function(_) {
+    return arguments.length ? (range = slice$1.call(_), scale) : range.slice();
+  };
 
-function linear$1() {
-  var scale = continuous(identity$1, identity$1);
+  scale.unknown = function(_) {
+    return arguments.length ? (unknown = _, scale) : unknown;
+  };
 
   scale.copy = function() {
-    return copy(scale, linear$1());
+    return ordinal(domain, range).unknown(unknown);
   };
 
   initRange.apply(scale, arguments);
 
-  return linearish(scale);
-}
-
-function nopropagation() {
-  event$1.stopImmediatePropagation();
-}
-
-function noevent() {
-  event$1.preventDefault();
-  event$1.stopImmediatePropagation();
-}
-
-function nodrag(view) {
-  var root = view.document.documentElement,
-      selection = select(view).on("dragstart.drag", noevent, true);
-  if ("onselectstart" in root) {
-    selection.on("selectstart.drag", noevent, true);
-  } else {
-    root.__noselect = root.style.MozUserSelect;
-    root.style.MozUserSelect = "none";
-  }
-}
-
-function yesdrag(view, noclick) {
-  var root = view.document.documentElement,
-      selection = select(view).on("dragstart.drag", null);
-  if (noclick) {
-    selection.on("click.drag", noevent, true);
-    setTimeout(function() { selection.on("click.drag", null); }, 0);
-  }
-  if ("onselectstart" in root) {
-    selection.on("selectstart.drag", null);
-  } else {
-    root.style.MozUserSelect = root.__noselect;
-    delete root.__noselect;
-  }
+  return scale;
 }
 
 function constant$3(x) {
@@ -3805,819 +3825,799 @@ function constant$3(x) {
   };
 }
 
-function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
-  this.target = target;
-  this.type = type;
-  this.subject = subject;
-  this.identifier = id;
-  this.active = active;
-  this.x = x;
-  this.y = y;
-  this.dx = dx;
-  this.dy = dy;
-  this._ = dispatch;
+function number$1(x) {
+  return +x;
 }
 
-DragEvent.prototype.on = function() {
-  var value = this._.on.apply(this._, arguments);
-  return value === this._ ? this : value;
-};
+var unit = [0, 1];
 
-// Ignore right-click, since that should open the context menu.
-function defaultFilter() {
-  return !event$1.ctrlKey && !event$1.button;
+function identity$2(x) {
+  return x;
 }
 
-function defaultContainer() {
-  return this.parentNode;
+function normalize(a, b) {
+  return (b -= (a = +a))
+      ? function(x) { return (x - a) / b; }
+      : constant$3(isNaN(b) ? NaN : 0.5);
 }
 
-function defaultSubject(d) {
-  return d == null ? {x: event$1.x, y: event$1.y} : d;
+function clamper(domain) {
+  var a = domain[0], b = domain[domain.length - 1], t;
+  if (a > b) t = a, a = b, b = t;
+  return function(x) { return Math.max(a, Math.min(b, x)); };
 }
 
-function defaultTouchable() {
-  return navigator.maxTouchPoints || ("ontouchstart" in this);
+// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
+// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
+function bimap(domain, range, interpolate) {
+  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
+  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
+  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
+  return function(x) { return r0(d0(x)); };
 }
 
-function drag() {
-  var filter = defaultFilter,
-      container = defaultContainer,
-      subject = defaultSubject,
-      touchable = defaultTouchable,
-      gestures = {},
-      listeners = dispatch("start", "drag", "end"),
-      active = 0,
-      mousedownx,
-      mousedowny,
-      mousemoving,
-      touchending,
-      clickDistance2 = 0;
-
-  function drag(selection) {
-    selection
-        .on("mousedown.drag", mousedowned)
-      .filter(touchable)
-        .on("touchstart.drag", touchstarted)
-        .on("touchmove.drag", touchmoved)
-        .on("touchend.drag touchcancel.drag", touchended)
-        .style("touch-action", "none")
-        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
-  }
-
-  function mousedowned() {
-    if (touchending || !filter.apply(this, arguments)) return;
-    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
-    if (!gesture) return;
-    select(event$1.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
-    nodrag(event$1.view);
-    nopropagation();
-    mousemoving = false;
-    mousedownx = event$1.clientX;
-    mousedowny = event$1.clientY;
-    gesture("start");
-  }
+function polymap(domain, range, interpolate) {
+  var j = Math.min(domain.length, range.length) - 1,
+      d = new Array(j),
+      r = new Array(j),
+      i = -1;
 
-  function mousemoved() {
-    noevent();
-    if (!mousemoving) {
-      var dx = event$1.clientX - mousedownx, dy = event$1.clientY - mousedowny;
-      mousemoving = dx * dx + dy * dy > clickDistance2;
-    }
-    gestures.mouse("drag");
+  // Reverse descending domains.
+  if (domain[j] < domain[0]) {
+    domain = domain.slice().reverse();
+    range = range.slice().reverse();
   }
 
-  function mouseupped() {
-    select(event$1.view).on("mousemove.drag mouseup.drag", null);
-    yesdrag(event$1.view, mousemoving);
-    noevent();
-    gestures.mouse("end");
+  while (++i < j) {
+    d[i] = normalize(domain[i], domain[i + 1]);
+    r[i] = interpolate(range[i], range[i + 1]);
   }
 
-  function touchstarted() {
-    if (!filter.apply(this, arguments)) return;
-    var touches = event$1.changedTouches,
-        c = container.apply(this, arguments),
-        n = touches.length, i, gesture;
+  return function(x) {
+    var i = bisectRight(domain, x, 1, j) - 1;
+    return r[i](d[i](x));
+  };
+}
 
-    for (i = 0; i < n; ++i) {
-      if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
-        nopropagation();
-        gesture("start");
-      }
-    }
-  }
+function copy(source, target) {
+  return target
+      .domain(source.domain())
+      .range(source.range())
+      .interpolate(source.interpolate())
+      .clamp(source.clamp())
+      .unknown(source.unknown());
+}
 
-  function touchmoved() {
-    var touches = event$1.changedTouches,
-        n = touches.length, i, gesture;
+function transformer() {
+  var domain = unit,
+      range = unit,
+      interpolate = interpolateValue,
+      transform,
+      untransform,
+      unknown,
+      clamp = identity$2,
+      piecewise,
+      output,
+      input;
 
-    for (i = 0; i < n; ++i) {
-      if (gesture = gestures[touches[i].identifier]) {
-        noevent();
-        gesture("drag");
-      }
-    }
+  function rescale() {
+    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
+    output = input = null;
+    return scale;
   }
 
-  function touchended() {
-    var touches = event$1.changedTouches,
-        n = touches.length, i, gesture;
-
-    if (touchending) clearTimeout(touchending);
-    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
-    for (i = 0; i < n; ++i) {
-      if (gesture = gestures[touches[i].identifier]) {
-        nopropagation();
-        gesture("end");
-      }
-    }
+  function scale(x) {
+    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
   }
 
-  function beforestart(id, container, point, that, args) {
-    var p = point(container, id), s, dx, dy,
-        sublisteners = listeners.copy();
-
-    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
-      if ((event$1.subject = s = subject.apply(that, args)) == null) return false;
-      dx = s.x - p[0] || 0;
-      dy = s.y - p[1] || 0;
-      return true;
-    })) return;
-
-    return function gesture(type) {
-      var p0 = p, n;
-      switch (type) {
-        case "start": gestures[id] = gesture, n = active++; break;
-        case "end": delete gestures[id], --active; // nobreak
-        case "drag": p = point(container, id), n = active; break;
-      }
-      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
-    };
-  }
+  scale.invert = function(y) {
+    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
+  };
 
-  drag.filter = function(_) {
-    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$3(!!_), drag) : filter;
+  scale.domain = function(_) {
+    return arguments.length ? (domain = map$1.call(_, number$1), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();
   };
 
-  drag.container = function(_) {
-    return arguments.length ? (container = typeof _ === "function" ? _ : constant$3(_), drag) : container;
+  scale.range = function(_) {
+    return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
   };
 
-  drag.subject = function(_) {
-    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$3(_), drag) : subject;
+  scale.rangeRound = function(_) {
+    return range = slice$1.call(_), interpolate = interpolateRound, rescale();
   };
 
-  drag.touchable = function(_) {
-    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$3(!!_), drag) : touchable;
+  scale.clamp = function(_) {
+    return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;
   };
 
-  drag.on = function() {
-    var value = listeners.on.apply(listeners, arguments);
-    return value === listeners ? drag : value;
+  scale.interpolate = function(_) {
+    return arguments.length ? (interpolate = _, rescale()) : interpolate;
   };
 
-  drag.clickDistance = function(_) {
-    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
+  scale.unknown = function(_) {
+    return arguments.length ? (unknown = _, scale) : unknown;
   };
 
-  return drag;
+  return function(t, u) {
+    transform = t, untransform = u;
+    return rescale();
+  };
 }
 
-var slice$1 = Array.prototype.slice;
-
-function identity$3(x) {
-  return x;
+function continuous(transform, untransform) {
+  return transformer()(transform, untransform);
 }
 
-var top = 1,
-    right = 2,
-    bottom = 3,
-    left = 4,
-    epsilon = 1e-6;
+// Computes the decimal coefficient and exponent of the specified number x with
+// significant digits p, where x is positive and p is in [1, 21] or undefined.
+// For example, formatDecimal(1.23) returns ["123", 0].
+function formatDecimal(x, p) {
+  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
+  var i, coefficient = x.slice(0, i);
 
-function translateX(x) {
-  return "translate(" + (x + 0.5) + ",0)";
+  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
+  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
+  return [
+    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
+    +x.slice(i + 1)
+  ];
 }
 
-function translateY(y) {
-  return "translate(0," + (y + 0.5) + ")";
+function exponent(x) {
+  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
 }
 
-function number$1(scale) {
-  return function(d) {
-    return +scale(d);
-  };
-}
+function formatGroup(grouping, thousands) {
+  return function(value, width) {
+    var i = value.length,
+        t = [],
+        j = 0,
+        g = grouping[0],
+        length = 0;
 
-function center(scale) {
-  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
-  if (scale.round()) offset = Math.round(offset);
-  return function(d) {
-    return +scale(d) + offset;
+    while (i > 0 && g > 0) {
+      if (length + g + 1 > width) g = Math.max(1, width - length);
+      t.push(value.substring(i -= g, i + g));
+      if ((length += g + 1) > width) break;
+      g = grouping[j = (j + 1) % grouping.length];
+    }
+
+    return t.reverse().join(thousands);
   };
 }
 
-function entering() {
-  return !this.__axis;
+function formatNumerals(numerals) {
+  return function(value) {
+    return value.replace(/[0-9]/g, function(i) {
+      return numerals[+i];
+    });
+  };
 }
 
-function axis(orient, scale) {
-  var tickArguments = [],
-      tickValues = null,
-      tickFormat = null,
-      tickSizeInner = 6,
-      tickSizeOuter = 6,
-      tickPadding = 3,
-      k = orient === top || orient === left ? -1 : 1,
-      x = orient === left || orient === right ? "x" : "y",
-      transform = orient === top || orient === bottom ? translateX : translateY;
-
-  function axis(context) {
-    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
-        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$3) : tickFormat,
-        spacing = Math.max(tickSizeInner, 0) + tickPadding,
-        range = scale.range(),
-        range0 = +range[0] + 0.5,
-        range1 = +range[range.length - 1] + 0.5,
-        position = (scale.bandwidth ? center : number$1)(scale.copy()),
-        selection = context.selection ? context.selection() : context,
-        path = selection.selectAll(".domain").data([null]),
-        tick = selection.selectAll(".tick").data(values, scale).order(),
-        tickExit = tick.exit(),
-        tickEnter = tick.enter().append("g").attr("class", "tick"),
-        line = tick.select("line"),
-        text = tick.select("text");
-
-    path = path.merge(path.enter().insert("path", ".tick")
-        .attr("class", "domain")
-        .attr("stroke", "currentColor"));
-
-    tick = tick.merge(tickEnter);
+// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
+var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
 
-    line = line.merge(tickEnter.append("line")
-        .attr("stroke", "currentColor")
-        .attr(x + "2", k * tickSizeInner));
+function formatSpecifier(specifier) {
+  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
+  var match;
+  return new FormatSpecifier({
+    fill: match[1],
+    align: match[2],
+    sign: match[3],
+    symbol: match[4],
+    zero: match[5],
+    width: match[6],
+    comma: match[7],
+    precision: match[8] && match[8].slice(1),
+    trim: match[9],
+    type: match[10]
+  });
+}
 
-    text = text.merge(tickEnter.append("text")
-        .attr("fill", "currentColor")
-        .attr(x, k * spacing)
-        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
+formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
 
-    if (context !== selection) {
-      path = path.transition(context);
-      tick = tick.transition(context);
-      line = line.transition(context);
-      text = text.transition(context);
+function FormatSpecifier(specifier) {
+  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
+  this.align = specifier.align === undefined ? ">" : specifier.align + "";
+  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
+  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
+  this.zero = !!specifier.zero;
+  this.width = specifier.width === undefined ? undefined : +specifier.width;
+  this.comma = !!specifier.comma;
+  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
+  this.trim = !!specifier.trim;
+  this.type = specifier.type === undefined ? "" : specifier.type + "";
+}
 
-      tickExit = tickExit.transition(context)
-          .attr("opacity", epsilon)
-          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });
+FormatSpecifier.prototype.toString = function() {
+  return this.fill
+      + this.align
+      + this.sign
+      + this.symbol
+      + (this.zero ? "0" : "")
+      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
+      + (this.comma ? "," : "")
+      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
+      + (this.trim ? "~" : "")
+      + this.type;
+};
 
-      tickEnter
-          .attr("opacity", epsilon)
-          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
+// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
+function formatTrim(s) {
+  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
+    switch (s[i]) {
+      case ".": i0 = i1 = i; break;
+      case "0": if (i0 === 0) i0 = i; i1 = i; break;
+      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
     }
+  }
+  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
+}
 
-    tickExit.remove();
-
-    path
-        .attr("d", orient === left || orient == right
-            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
-            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));
-
-    tick
-        .attr("opacity", 1)
-        .attr("transform", function(d) { return transform(position(d)); });
+var prefixExponent;
 
-    line
-        .attr(x + "2", k * tickSizeInner);
+function formatPrefixAuto(x, p) {
+  var d = formatDecimal(x, p);
+  if (!d) return x + "";
+  var coefficient = d[0],
+      exponent = d[1],
+      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
+      n = coefficient.length;
+  return i === n ? coefficient
+      : i > n ? coefficient + new Array(i - n + 1).join("0")
+      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
+      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
+}
 
-    text
-        .attr(x, k * spacing)
-        .text(format);
+function formatRounded(x, p) {
+  var d = formatDecimal(x, p);
+  if (!d) return x + "";
+  var coefficient = d[0],
+      exponent = d[1];
+  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
+      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
+      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
+}
 
-    selection.filter(entering)
-        .attr("fill", "none")
-        .attr("font-size", 10)
-        .attr("font-family", "sans-serif")
-        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
+var formatTypes = {
+  "%": function(x, p) { return (x * 100).toFixed(p); },
+  "b": function(x) { return Math.round(x).toString(2); },
+  "c": function(x) { return x + ""; },
+  "d": function(x) { return Math.round(x).toString(10); },
+  "e": function(x, p) { return x.toExponential(p); },
+  "f": function(x, p) { return x.toFixed(p); },
+  "g": function(x, p) { return x.toPrecision(p); },
+  "o": function(x) { return Math.round(x).toString(8); },
+  "p": function(x, p) { return formatRounded(x * 100, p); },
+  "r": formatRounded,
+  "s": formatPrefixAuto,
+  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
+  "x": function(x) { return Math.round(x).toString(16); }
+};
 
-    selection
-        .each(function() { this.__axis = position; });
-  }
+function identity$3(x) {
+  return x;
+}
 
-  axis.scale = function(_) {
-    return arguments.length ? (scale = _, axis) : scale;
-  };
+var map$2 = Array.prototype.map,
+    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];
 
-  axis.ticks = function() {
-    return tickArguments = slice$1.call(arguments), axis;
-  };
+function formatLocale(locale) {
+  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""),
+      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
+      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
+      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
+      numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map$2.call(locale.numerals, String)),
+      percent = locale.percent === undefined ? "%" : locale.percent + "",
+      minus = locale.minus === undefined ? "-" : locale.minus + "",
+      nan = locale.nan === undefined ? "NaN" : locale.nan + "";
 
-  axis.tickArguments = function(_) {
-    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
-  };
+  function newFormat(specifier) {
+    specifier = formatSpecifier(specifier);
 
-  axis.tickValues = function(_) {
-    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
-  };
+    var fill = specifier.fill,
+        align = specifier.align,
+        sign = specifier.sign,
+        symbol = specifier.symbol,
+        zero = specifier.zero,
+        width = specifier.width,
+        comma = specifier.comma,
+        precision = specifier.precision,
+        trim = specifier.trim,
+        type = specifier.type;
 
-  axis.tickFormat = function(_) {
-    return arguments.length ? (tickFormat = _, axis) : tickFormat;
-  };
+    // The "n" type is an alias for ",g".
+    if (type === "n") comma = true, type = "g";
 
-  axis.tickSize = function(_) {
-    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
-  };
+    // The "" type, and any invalid type, is an alias for ".12~g".
+    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";
 
-  axis.tickSizeInner = function(_) {
-    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
-  };
+    // If zero fill is specified, padding goes after sign and before digits.
+    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";
 
-  axis.tickSizeOuter = function(_) {
-    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
-  };
+    // Compute the prefix and suffix.
+    // For SI-prefix, the suffix is lazily computed.
+    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
+        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
 
-  axis.tickPadding = function(_) {
-    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
-  };
+    // What format function should we use?
+    // Is this an integer type?
+    // Can this type generate exponential notation?
+    var formatType = formatTypes[type],
+        maybeSuffix = /[defgprs%]/.test(type);
 
-  return axis;
-}
+    // Set the default precision if not specified,
+    // or clamp the specified precision to the supported range.
+    // For significant precision, it must be in [1, 21].
+    // For fixed precision, it must be in [0, 20].
+    precision = precision === undefined ? 6
+        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
+        : Math.max(0, Math.min(20, precision));
 
-function axisBottom(scale) {
-  return axis(bottom, scale);
-}
+    function format(value) {
+      var valuePrefix = prefix,
+          valueSuffix = suffix,
+          i, n, c;
 
-function axisLeft(scale) {
-  return axis(left, scale);
-}
+      if (type === "c") {
+        valueSuffix = formatType(value) + valueSuffix;
+        value = "";
+      } else {
+        value = +value;
 
-var pi = Math.PI,
-    tau = 2 * pi,
-    epsilon$1 = 1e-6,
-    tauEpsilon = tau - epsilon$1;
+        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
+        var valueNegative = value < 0 || 1 / value < 0;
 
-function Path() {
-  this._x0 = this._y0 = // start of current subpath
-  this._x1 = this._y1 = null; // end of current subpath
-  this._ = "";
-}
+        // Perform the initial formatting.
+        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
 
-function path() {
-  return new Path;
-}
+        // Trim insignificant zeros.
+        if (trim) value = formatTrim(value);
 
-Path.prototype = path.prototype = {
-  constructor: Path,
-  moveTo: function(x, y) {
-    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
-  },
-  closePath: function() {
-    if (this._x1 !== null) {
-      this._x1 = this._x0, this._y1 = this._y0;
-      this._ += "Z";
-    }
-  },
-  lineTo: function(x, y) {
-    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
-  },
-  quadraticCurveTo: function(x1, y1, x, y) {
-    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
-  },
-  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
-    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
-  },
-  arcTo: function(x1, y1, x2, y2, r) {
-    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
-    var x0 = this._x1,
-        y0 = this._y1,
-        x21 = x2 - x1,
-        y21 = y2 - y1,
-        x01 = x0 - x1,
-        y01 = y0 - y1,
-        l01_2 = x01 * x01 + y01 * y01;
+        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
+        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
 
-    // Is the radius negative? Error.
-    if (r < 0) throw new Error("negative radius: " + r);
+        // Compute the prefix and suffix.
+        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
+        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
 
-    // Is this path empty? Move to (x1,y1).
-    if (this._x1 === null) {
-      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
-    }
+        // Break the formatted value into the integer “value” part that can be
+        // grouped, and fractional or exponential “suffix” part that is not.
+        if (maybeSuffix) {
+          i = -1, n = value.length;
+          while (++i < n) {
+            if (c = value.charCodeAt(i), 48 > c || c > 57) {
+              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
+              value = value.slice(0, i);
+              break;
+            }
+          }
+        }
+      }
 
-    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
-    else if (!(l01_2 > epsilon$1));
+      // If the fill character is not "0", grouping is applied before padding.
+      if (comma && !zero) value = group(value, Infinity);
 
-    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
-    // Equivalently, is (x1,y1) coincident with (x2,y2)?
-    // Or, is the radius zero? Line to (x1,y1).
-    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
-      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
-    }
+      // Compute the padding.
+      var length = valuePrefix.length + value.length + valueSuffix.length,
+          padding = length < width ? new Array(width - length + 1).join(fill) : "";
 
-    // Otherwise, draw an arc!
-    else {
-      var x20 = x2 - x0,
-          y20 = y2 - y0,
-          l21_2 = x21 * x21 + y21 * y21,
-          l20_2 = x20 * x20 + y20 * y20,
-          l21 = Math.sqrt(l21_2),
-          l01 = Math.sqrt(l01_2),
-          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
-          t01 = l / l01,
-          t21 = l / l21;
+      // If the fill character is "0", grouping is applied after padding.
+      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
 
-      // If the start tangent is not coincident with (x0,y0), line to.
-      if (Math.abs(t01 - 1) > epsilon$1) {
-        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
+      // Reconstruct the final output based on the desired alignment.
+      switch (align) {
+        case "<": value = valuePrefix + value + valueSuffix + padding; break;
+        case "=": value = valuePrefix + padding + value + valueSuffix; break;
+        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
+        default: value = padding + valuePrefix + value + valueSuffix; break;
       }
 
-      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
+      return numerals(value);
     }
-  },
-  arc: function(x, y, r, a0, a1, ccw) {
-    x = +x, y = +y, r = +r, ccw = !!ccw;
-    var dx = r * Math.cos(a0),
-        dy = r * Math.sin(a0),
-        x0 = x + dx,
-        y0 = y + dy,
-        cw = 1 ^ ccw,
-        da = ccw ? a0 - a1 : a1 - a0;
 
-    // Is the radius negative? Error.
-    if (r < 0) throw new Error("negative radius: " + r);
+    format.toString = function() {
+      return specifier + "";
+    };
 
-    // Is this path empty? Move to (x0,y0).
-    if (this._x1 === null) {
-      this._ += "M" + x0 + "," + y0;
-    }
+    return format;
+  }
 
-    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
-    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
-      this._ += "L" + x0 + "," + y0;
-    }
+  function formatPrefix(specifier, value) {
+    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
+        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
+        k = Math.pow(10, -e),
+        prefix = prefixes[8 + e / 3];
+    return function(value) {
+      return f(k * value) + prefix;
+    };
+  }
 
-    // Is this arc empty? We’re done.
-    if (!r) return;
+  return {
+    format: newFormat,
+    formatPrefix: formatPrefix
+  };
+}
 
-    // Does the angle go the wrong way? Flip the direction.
-    if (da < 0) da = da % tau + tau;
+var locale;
+var format;
+var formatPrefix;
 
-    // Is this a complete circle? Draw two arcs to complete the circle.
-    if (da > tauEpsilon) {
-      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
-    }
+defaultLocale({
+  decimal: ".",
+  thousands: ",",
+  grouping: [3],
+  currency: ["$", ""],
+  minus: "-"
+});
 
-    // Is this arc non-empty? Draw an arc!
-    else if (da > epsilon$1) {
-      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
-    }
-  },
-  rect: function(x, y, w, h) {
-    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
-  },
-  toString: function() {
-    return this._;
-  }
-};
+function defaultLocale(definition) {
+  locale = formatLocale(definition);
+  format = locale.format;
+  formatPrefix = locale.formatPrefix;
+  return locale;
+}
 
-function constant$4(x) {
-  return function constant() {
-    return x;
-  };
+function precisionFixed(step) {
+  return Math.max(0, -exponent(Math.abs(step)));
 }
 
-var pi$1 = Math.PI;
-var tau$1 = 2 * pi$1;
+function precisionPrefix(step, value) {
+  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
+}
 
-function Linear(context) {
-  this._context = context;
+function precisionRound(step, max) {
+  step = Math.abs(step), max = Math.abs(max) - step;
+  return Math.max(0, exponent(max) - exponent(step)) + 1;
 }
 
-Linear.prototype = {
-  areaStart: function() {
-    this._line = 0;
-  },
-  areaEnd: function() {
-    this._line = NaN;
-  },
-  lineStart: function() {
-    this._point = 0;
-  },
-  lineEnd: function() {
-    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
-    this._line = 1 - this._line;
-  },
-  point: function(x, y) {
-    x = +x, y = +y;
-    switch (this._point) {
-      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
-      case 1: this._point = 2; // proceed
-      default: this._context.lineTo(x, y); break;
+function tickFormat(start, stop, count, specifier) {
+  var step = tickStep(start, stop, count),
+      precision;
+  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
+  switch (specifier.type) {
+    case "s": {
+      var value = Math.max(Math.abs(start), Math.abs(stop));
+      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
+      return formatPrefix(specifier, value);
+    }
+    case "":
+    case "e":
+    case "g":
+    case "p":
+    case "r": {
+      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
+      break;
+    }
+    case "f":
+    case "%": {
+      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
+      break;
     }
   }
-};
-
-function curveLinear(context) {
-  return new Linear(context);
+  return format(specifier);
 }
 
-function x(p) {
-  return p[0];
-}
+function linearish(scale) {
+  var domain = scale.domain;
 
-function y(p) {
-  return p[1];
-}
+  scale.ticks = function(count) {
+    var d = domain();
+    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
+  };
 
-function line() {
-  var x$1 = x,
-      y$1 = y,
-      defined = constant$4(true),
-      context = null,
-      curve = curveLinear,
-      output = null;
+  scale.tickFormat = function(count, specifier) {
+    var d = domain();
+    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
+  };
 
-  function line(data) {
-    var i,
-        n = data.length,
-        d,
-        defined0 = false,
-        buffer;
+  scale.nice = function(count) {
+    if (count == null) count = 10;
 
-    if (context == null) output = curve(buffer = path());
+    var d = domain(),
+        i0 = 0,
+        i1 = d.length - 1,
+        start = d[i0],
+        stop = d[i1],
+        step;
 
-    for (i = 0; i <= n; ++i) {
-      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
-        if (defined0 = !defined0) output.lineStart();
-        else output.lineEnd();
-      }
-      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
+    if (stop < start) {
+      step = start, start = stop, stop = step;
+      step = i0, i0 = i1, i1 = step;
     }
 
-    if (buffer) return output = null, buffer + "" || null;
-  }
+    step = tickIncrement(start, stop, count);
 
-  line.x = function(_) {
-    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$4(+_), line) : x$1;
-  };
+    if (step > 0) {
+      start = Math.floor(start / step) * step;
+      stop = Math.ceil(stop / step) * step;
+      step = tickIncrement(start, stop, count);
+    } else if (step < 0) {
+      start = Math.ceil(start * step) / step;
+      stop = Math.floor(stop * step) / step;
+      step = tickIncrement(start, stop, count);
+    }
 
-  line.y = function(_) {
-    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$4(+_), line) : y$1;
-  };
+    if (step > 0) {
+      d[i0] = Math.floor(start / step) * step;
+      d[i1] = Math.ceil(stop / step) * step;
+      domain(d);
+    } else if (step < 0) {
+      d[i0] = Math.ceil(start * step) / step;
+      d[i1] = Math.floor(stop * step) / step;
+      domain(d);
+    }
 
-  line.defined = function(_) {
-    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), line) : defined;
+    return scale;
   };
 
-  line.curve = function(_) {
-    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
-  };
+  return scale;
+}
 
-  line.context = function(_) {
-    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
-  };
+function linear$1() {
+  var scale = continuous(identity$2, identity$2);
 
-  return line;
-}
+  scale.copy = function() {
+    return copy(scale, linear$1());
+  };
 
-function d3Area() {
-  var x0 = x,
-      x1 = null,
-      y0 = constant$4(0),
-      y1 = y,
-      defined = constant$4(true),
-      context = null,
-      curve = curveLinear,
-      output = null;
+  initRange.apply(scale, arguments);
 
-  function area(data) {
-    var i,
-        j,
-        k,
-        n = data.length,
-        d,
-        defined0 = false,
-        buffer,
-        x0z = new Array(n),
-        y0z = new Array(n);
+  return linearish(scale);
+}
 
-    if (context == null) output = curve(buffer = path());
+function colors(specifier) {
+  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
+  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
+  return colors;
+}
 
-    for (i = 0; i <= n; ++i) {
-      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
-        if (defined0 = !defined0) {
-          j = i;
-          output.areaStart();
-          output.lineStart();
-        } else {
-          output.lineEnd();
-          output.lineStart();
-          for (k = i - 1; k >= j; --k) {
-            output.point(x0z[k], y0z[k]);
-          }
-          output.lineEnd();
-          output.areaEnd();
-        }
-      }
-      if (defined0) {
-        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
-        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
-      }
-    }
+var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
 
-    if (buffer) return output = null, buffer + "" || null;
-  }
+var schemeAccent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
 
-  function arealine() {
-    return line().defined(defined).curve(curve).context(context);
-  }
+var schemeDark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
 
-  area.x = function(_) {
-    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), x1 = null, area) : x0;
-  };
+var schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
 
-  area.x0 = function(_) {
-    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), area) : x0;
-  };
+var schemeSet2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
 
-  area.x1 = function(_) {
-    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area) : x1;
-  };
+var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
 
-  area.y = function(_) {
-    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), y1 = null, area) : y0;
-  };
+function nopropagation() {
+  event$1.stopImmediatePropagation();
+}
 
-  area.y0 = function(_) {
-    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), area) : y0;
-  };
+function noevent() {
+  event$1.preventDefault();
+  event$1.stopImmediatePropagation();
+}
 
-  area.y1 = function(_) {
-    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area) : y1;
-  };
+function nodrag(view) {
+  var root = view.document.documentElement,
+      selection = select(view).on("dragstart.drag", noevent, true);
+  if ("onselectstart" in root) {
+    selection.on("selectstart.drag", noevent, true);
+  } else {
+    root.__noselect = root.style.MozUserSelect;
+    root.style.MozUserSelect = "none";
+  }
+}
 
-  area.lineX0 =
-  area.lineY0 = function() {
-    return arealine().x(x0).y(y0);
-  };
+function yesdrag(view, noclick) {
+  var root = view.document.documentElement,
+      selection = select(view).on("dragstart.drag", null);
+  if (noclick) {
+    selection.on("click.drag", noevent, true);
+    setTimeout(function() { selection.on("click.drag", null); }, 0);
+  }
+  if ("onselectstart" in root) {
+    selection.on("selectstart.drag", null);
+  } else {
+    root.style.MozUserSelect = root.__noselect;
+    delete root.__noselect;
+  }
+}
 
-  area.lineY1 = function() {
-    return arealine().x(x0).y(y1);
+function constant$4(x) {
+  return function() {
+    return x;
   };
+}
 
-  area.lineX1 = function() {
-    return arealine().x(x1).y(y0);
-  };
+function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
+  this.target = target;
+  this.type = type;
+  this.subject = subject;
+  this.identifier = id;
+  this.active = active;
+  this.x = x;
+  this.y = y;
+  this.dx = dx;
+  this.dy = dy;
+  this._ = dispatch;
+}
 
-  area.defined = function(_) {
-    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), area) : defined;
-  };
+DragEvent.prototype.on = function() {
+  var value = this._.on.apply(this._, arguments);
+  return value === this._ ? this : value;
+};
 
-  area.curve = function(_) {
-    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
-  };
+// Ignore right-click, since that should open the context menu.
+function defaultFilter() {
+  return !event$1.ctrlKey && !event$1.button;
+}
 
-  area.context = function(_) {
-    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
-  };
+function defaultContainer() {
+  return this.parentNode;
+}
 
-  return area;
+function defaultSubject(d) {
+  return d == null ? {x: event$1.x, y: event$1.y} : d;
 }
 
-var circle = {
-  draw: function(context, size) {
-    var r = Math.sqrt(size / pi$1);
-    context.moveTo(r, 0);
-    context.arc(0, 0, r, 0, tau$1);
-  }
-};
+function defaultTouchable() {
+  return navigator.maxTouchPoints || ("ontouchstart" in this);
+}
 
-var sqrt3 = Math.sqrt(3);
+function drag() {
+  var filter = defaultFilter,
+      container = defaultContainer,
+      subject = defaultSubject,
+      touchable = defaultTouchable,
+      gestures = {},
+      listeners = dispatch("start", "drag", "end"),
+      active = 0,
+      mousedownx,
+      mousedowny,
+      mousemoving,
+      touchending,
+      clickDistance2 = 0;
 
-var symbolTriangle = {
-  draw: function(context, size) {
-    var y = -Math.sqrt(size / (sqrt3 * 3));
-    context.moveTo(0, y * 2);
-    context.lineTo(-sqrt3 * y, -y);
-    context.lineTo(sqrt3 * y, -y);
-    context.closePath();
+  function drag(selection) {
+    selection
+        .on("mousedown.drag", mousedowned)
+      .filter(touchable)
+        .on("touchstart.drag", touchstarted)
+        .on("touchmove.drag", touchmoved)
+        .on("touchend.drag touchcancel.drag", touchended)
+        .style("touch-action", "none")
+        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
   }
-};
 
-function symbol() {
-  var type = constant$4(circle),
-      size = constant$4(64),
-      context = null;
+  function mousedowned() {
+    if (touchending || !filter.apply(this, arguments)) return;
+    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
+    if (!gesture) return;
+    select(event$1.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
+    nodrag(event$1.view);
+    nopropagation();
+    mousemoving = false;
+    mousedownx = event$1.clientX;
+    mousedowny = event$1.clientY;
+    gesture("start");
+  }
 
-  function symbol() {
-    var buffer;
-    if (!context) context = buffer = path();
-    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
-    if (buffer) return context = null, buffer + "" || null;
+  function mousemoved() {
+    noevent();
+    if (!mousemoving) {
+      var dx = event$1.clientX - mousedownx, dy = event$1.clientY - mousedowny;
+      mousemoving = dx * dx + dy * dy > clickDistance2;
+    }
+    gestures.mouse("drag");
   }
 
-  symbol.type = function(_) {
-    return arguments.length ? (type = typeof _ === "function" ? _ : constant$4(_), symbol) : type;
-  };
+  function mouseupped() {
+    select(event$1.view).on("mousemove.drag mouseup.drag", null);
+    yesdrag(event$1.view, mousemoving);
+    noevent();
+    gestures.mouse("end");
+  }
 
-  symbol.size = function(_) {
-    return arguments.length ? (size = typeof _ === "function" ? _ : constant$4(+_), symbol) : size;
-  };
+  function touchstarted() {
+    if (!filter.apply(this, arguments)) return;
+    var touches = event$1.changedTouches,
+        c = container.apply(this, arguments),
+        n = touches.length, i, gesture;
 
-  symbol.context = function(_) {
-    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
-  };
+    for (i = 0; i < n; ++i) {
+      if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
+        nopropagation();
+        gesture("start");
+      }
+    }
+  }
 
-  return symbol;
-}
+  function touchmoved() {
+    var touches = event$1.changedTouches,
+        n = touches.length, i, gesture;
 
-function point$1(that, x, y) {
-  that._context.bezierCurveTo(
-    (2 * that._x0 + that._x1) / 3,
-    (2 * that._y0 + that._y1) / 3,
-    (that._x0 + 2 * that._x1) / 3,
-    (that._y0 + 2 * that._y1) / 3,
-    (that._x0 + 4 * that._x1 + x) / 6,
-    (that._y0 + 4 * that._y1 + y) / 6
-  );
-}
+    for (i = 0; i < n; ++i) {
+      if (gesture = gestures[touches[i].identifier]) {
+        noevent();
+        gesture("drag");
+      }
+    }
+  }
 
-function Basis(context) {
-  this._context = context;
-}
+  function touchended() {
+    var touches = event$1.changedTouches,
+        n = touches.length, i, gesture;
 
-Basis.prototype = {
-  areaStart: function() {
-    this._line = 0;
-  },
-  areaEnd: function() {
-    this._line = NaN;
-  },
-  lineStart: function() {
-    this._x0 = this._x1 =
-    this._y0 = this._y1 = NaN;
-    this._point = 0;
-  },
-  lineEnd: function() {
-    switch (this._point) {
-      case 3: point$1(this, this._x1, this._y1); // proceed
-      case 2: this._context.lineTo(this._x1, this._y1); break;
-    }
-    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
-    this._line = 1 - this._line;
-  },
-  point: function(x, y) {
-    x = +x, y = +y;
-    switch (this._point) {
-      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
-      case 1: this._point = 2; break;
-      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
-      default: point$1(this, x, y); break;
+    if (touchending) clearTimeout(touchending);
+    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
+    for (i = 0; i < n; ++i) {
+      if (gesture = gestures[touches[i].identifier]) {
+        nopropagation();
+        gesture("end");
+      }
     }
-    this._x0 = this._x1, this._x1 = x;
-    this._y0 = this._y1, this._y1 = y;
   }
-};
 
-function curveBasis(context) {
-  return new Basis(context);
-}
+  function beforestart(id, container, point, that, args) {
+    var p = point(container, id), s, dx, dy,
+        sublisteners = listeners.copy();
 
-function colors(specifier) {
-  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
-  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
-  return colors;
-}
+    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
+      if ((event$1.subject = s = subject.apply(that, args)) == null) return false;
+      dx = s.x - p[0] || 0;
+      dy = s.y - p[1] || 0;
+      return true;
+    })) return;
 
-var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
+    return function gesture(type) {
+      var p0 = p, n;
+      switch (type) {
+        case "start": gestures[id] = gesture, n = active++; break;
+        case "end": delete gestures[id], --active; // nobreak
+        case "drag": p = point(container, id), n = active; break;
+      }
+      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
+    };
+  }
 
-var schemeAccent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
+  drag.filter = function(_) {
+    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), drag) : filter;
+  };
 
-var schemeDark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
+  drag.container = function(_) {
+    return arguments.length ? (container = typeof _ === "function" ? _ : constant$4(_), drag) : container;
+  };
 
-var schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
+  drag.subject = function(_) {
+    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$4(_), drag) : subject;
+  };
 
-var schemeSet2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
+  drag.touchable = function(_) {
+    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), drag) : touchable;
+  };
 
-var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
+  drag.on = function() {
+    var value = listeners.on.apply(listeners, arguments);
+    return value === listeners ? drag : value;
+  };
+
+  drag.clickDistance = function(_) {
+    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
+  };
+
+  return drag;
+}
 
 (function (factory, window) {
   // define an AMD module that relies on 'leaflet'
-  if (typeof define === 'function' && define.amd) {
-    define(['leaflet'], factory); // define a Common JS module that relies on 'leaflet'
-  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
-    if (typeof window !== 'undefined' && window.L) {
+  if (typeof define === "function" && define.amd) {
+    define(["leaflet"], factory); // define a Common JS module that relies on 'leaflet'
+  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {
+    if (typeof window !== "undefined" && window.L) {
       module.exports = factory(L);
     } else {
-      module.exports = factory(require('leaflet'));
+      module.exports = factory(require("leaflet"));
     }
   } // attach your plugin to the global 'L' variable
 
 
-  if (typeof window !== 'undefined' && window.L) {
+  if (typeof window !== "undefined" && window.L) {
     window.L.Control.Heightgraph = factory(L);
   }
 })(function (L) {
@@ -4659,7 +4659,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       this._svgWidth = this._width - this._margin.left - this._margin.right;
       this._svgHeight = this._height - this._margin.top - this._margin.bottom;
       this._highlightStyle = this.options.highlightStyle || {
-        color: 'red'
+        color: "red"
       };
       this._graphStyle = this.options.graphStyle || {};
       this._dragCache = {};
@@ -4669,7 +4669,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       L.DomEvent.disableClickPropagation(container);
 
       if (this.options.expandControls) {
-        var buttonContainer = this._button = L.DomUtil.create('div', "heightgraph-toggle", container);
+        var buttonContainer = this._button = L.DomUtil.create("div", "heightgraph-toggle", container);
         var link = L.DomUtil.create("a", "heightgraph-toggle-icon", buttonContainer);
         var closeButton = this._closeButton = L.DomUtil.create("a", "heightgraph-close-icon", container);
       }
@@ -4701,13 +4701,13 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
     },
 
     /**
-    * Internal function. Overloads public addData().
-    * Call with resize = true when resizing instead of actually adding data.
-    * TODO: this should be refactored to avoid calling addData on resize
-    * @param data
-    * @param resize
-    * @private
-    */
+     * Internal function. Overloads public addData().
+     * Call with resize = true when resizing instead of actually adding data.
+     * TODO: this should be refactored to avoid calling addData on resize
+     * @param data
+     * @param resize
+     * @private
+     */
     _addData: function _addData(data) {
       if (this._svg !== undefined) {
         this._svg.selectAll("*").remove();
@@ -4751,17 +4751,17 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       if (!L.Browser.touch) {
         L.DomEvent.disableClickPropagation(this._container);
       } else {
-        L.DomEvent.on(this._container, 'click', L.DomEvent.stopPropagation);
+        L.DomEvent.on(this._container, "click", L.DomEvent.stopPropagation);
       }
 
       if (this.options.expandControls) {
-        L.DomEvent.on(this._button, 'click', this._expand, this);
-        L.DomEvent.on(this._closeButton, 'click', this._expand, this);
+        L.DomEvent.on(this._button, "click", this._expand, this);
+        L.DomEvent.on(this._closeButton, "click", this._expand, this);
       }
     },
     _dragHandler: function _dragHandler() {
       //we don´t want map events to occur here
-      if (typeof event !== 'undefined') {
+      if (typeof event !== "undefined") {
         event.preventDefault();
         event.stopPropagation();
       }
@@ -4786,7 +4786,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       if (!this._dragRectangle && !this._dragRectangleG) {
         var g = select(this._container).select("svg").select("g");
         this._dragRectangleG = g.append("g");
-        this._dragRectangle = this._dragRectangleG.append("rect").attr("width", x2 - x1).attr("height", this._svgHeight).attr("x", x1).attr('class', 'mouse-drag').style("fill", "grey").style("opacity", 0.5).style("pointer-events", "none");
+        this._dragRectangle = this._dragRectangleG.append("rect").attr("width", x2 - x1).attr("height", this._svgHeight).attr("x", x1).attr("class", "mouse-drag").style("fill", "grey").style("opacity", 0.5).style("pointer-events", "none");
       } else {
         this._dragRectangle.attr("width", x2 - x1).attr("x", x1);
       }
@@ -4886,11 +4886,11 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       if (!this._showState) {
         select(this._button).style("display", "none");
-        select(this._container).selectAll('svg').style("display", "block");
+        select(this._container).selectAll("svg").style("display", "block");
         select(this._closeButton).style("display", "block");
       } else {
         select(this._button).style("display", "block");
-        select(this._container).selectAll('svg').style("display", "none");
+        select(this._container).selectAll("svg").style("display", "none");
         select(this._closeButton).style("display", "none");
       }
 
@@ -4933,8 +4933,8 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
     _d3ColorCategorical: [schemeAccent, schemeDark2, schemeSet2, schemeCategory10, schemeSet3, schemePaired],
 
     /**
-    * Prepares the data needed for the height graph
-    */
+     * Prepares the data needed for the height graph
+     */
     _prepareData: function _prepareData() {
       this._coordinates = [];
       this._elevations = [];
@@ -4967,7 +4967,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
         var i = void 0,
             cnt = 0;
         var usedColors = {};
-        var isMappingFunction = this._mappings !== undefined && typeof this._mappings[data[y].properties.summary] === 'function';
+        var isMappingFunction = this._mappings !== undefined && typeof this._mappings[data[y].properties.summary] === "function";
 
         for (i = 0; i < data[y].features.length; i++) {
           // data is redundant in every element of data which is why we collect it once
@@ -5104,11 +5104,11 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       if (!this._mouseHeightFocus) {
         var heightG = select(".leaflet-overlay-pane svg").append("g");
-        this._mouseHeightFocus = heightG.append('svg:line').attr('class', 'height-focus line').attr('x2', '0').attr('y2', '0').attr('x1', '0').attr('y1', '0');
-        this._mouseHeightFocusLabel = heightG.append("g").attr('class', 'height-focus label');
-        this._mouseHeightFocusLabelRect = this._mouseHeightFocusLabel.append("rect").attr('class', 'bBox');
-        this._mouseHeightFocusLabelTextElev = this._mouseHeightFocusLabel.append("text").attr('class', 'tspan');
-        this._mouseHeightFocusLabelTextType = this._mouseHeightFocusLabel.append("text").attr('class', 'tspan');
+        this._mouseHeightFocus = heightG.append("svg:line").attr("class", "height-focus line").attr("x2", "0").attr("y2", "0").attr("x1", "0").attr("y1", "0");
+        this._mouseHeightFocusLabel = heightG.append("g").attr("class", "height-focus label");
+        this._mouseHeightFocusLabelRect = this._mouseHeightFocusLabel.append("rect").attr("class", "bBox");
+        this._mouseHeightFocusLabelTextElev = this._mouseHeightFocusLabel.append("text").attr("class", "tspan");
+        this._mouseHeightFocusLabelTextType = this._mouseHeightFocusLabel.append("text").attr("class", "tspan");
         var pointG = this._pointG = heightG.append("g").attr("class", "height-focus circle");
         pointG.append("svg:circle").attr("r", 5).attr("cx", 0).attr("cy", 0).attr("class", "height-focus circle-lower");
       }
@@ -5119,9 +5119,9 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       this._pointG.attr("transform", "translate(" + layerPoint.x + "," + layerPoint.y + ")").style("display", "block");
 
-      this._mouseHeightFocusLabelRect.attr("x", layerPoint.x + 3).attr("y", normalizedY).attr("class", 'bBox');
+      this._mouseHeightFocusLabelRect.attr("x", layerPoint.x + 3).attr("y", normalizedY).attr("class", "bBox");
 
-      this._mouseHeightFocusLabelTextElev.attr("x", layerPoint.x + 5).attr("y", normalizedY + 12).text(height + " m").attr("class", "tspan mouse-height-box-text");
+      this._mouseHeightFocusLabelTextElev.attr("x", layerPoint.x + 5).attr("y", normalizedY + 12).text((height * 3.281).toFixed(0) + " ft").attr("class", "tspan mouse-height-box-text");
 
       this._mouseHeightFocusLabelTextType.attr("x", layerPoint.x + 5).attr("y", normalizedY + 24).text(type).attr("class", "tspan mouse-height-box-text");
 
@@ -5129,7 +5129,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
 
       var maxHeight = type === "" ? 12 + 6 : 2 * 12 + 6;
-      selectAll('.bBox').attr("width", maxWidth + 10).attr("height", maxHeight);
+      selectAll(".bBox").attr("width", maxWidth + 10).attr("height", maxHeight);
     },
 
     /**
@@ -5171,23 +5171,23 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       this._focusRect = this._focus.append("rect").attr("x", 3).attr("y", -this._y(boxPosition)).attr("display", "none"); // text line 1
 
-      this._focusDistance = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + textDistance).attr("id", "heightgraph.distance").text(this._getTranslation('distance') + ':'); // text line 2
+      this._focusDistance = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + textDistance).attr("id", "heightgraph.distance").text(this._getTranslation("distance") + ":"); // text line 2
 
-      this._focusHeight = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 2 * textDistance).attr("id", "heightgraph.height").text(this._getTranslation('elevation') + ':'); // text line 3
+      this._focusHeight = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 2 * textDistance).attr("id", "heightgraph.height").text(this._getTranslation("elevation") + ":"); // text line 3
 
-      this._focusBlockDistance = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 3 * textDistance).attr("id", "heightgraph.blockdistance").text(this._getTranslation('segment_length') + ':'); // text line 4
+      this._focusBlockDistance = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 3 * textDistance).attr("id", "heightgraph.blockdistance").text(this._getTranslation("segment_length") + ":"); // text line 4
 
-      this._focusType = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 4 * textDistance).attr("id", "heightgraph.type").text(this._getTranslation('type') + ':');
-      this._areaTspan = this._focusBlockDistance.append('tspan').attr("class", "tspan");
-      this._typeTspan = this._focusType.append('tspan').attr("class", "tspan");
+      this._focusType = this._focus.append("text").attr("x", 7).attr("y", -this._y(boxPosition) + 4 * textDistance).attr("id", "heightgraph.type").text(this._getTranslation("type") + ":");
+      this._areaTspan = this._focusBlockDistance.append("tspan").attr("class", "tspan");
+      this._typeTspan = this._focusType.append("tspan").attr("class", "tspan");
 
       var height = this._dynamicBoxSize(".focusbox text")[0];
 
-      selectAll('.focusbox rect').attr("height", height * textDistance + textDistance / 2).attr("display", "block");
+      selectAll(".focusbox rect").attr("height", height * textDistance + textDistance / 2).attr("display", "block");
       this._focusLineGroup = this._svg.append("g").attr("class", "focusLine");
       this._focusLine = this._focusLineGroup.append("line").attr("y1", 0).attr("y2", this._y(this._elevationBounds.min));
-      this._distTspan = this._focusDistance.append('tspan').attr("class", "tspan");
-      this._altTspan = this._focusHeight.append('tspan').attr("class", "tspan");
+      this._distTspan = this._focusDistance.append("tspan").attr("class", "tspan");
+      this._altTspan = this._focusHeight.append("tspan").attr("class", "tspan");
     },
 
     /**
@@ -5199,12 +5199,12 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       this._elevationValueText = this._svg.append("text").attr("class", "horizontalLineText").attr("x", this._width - this._margin.left - this._margin.right - 20).attr("y", this._y(this._elevationBounds.min) - 10).attr("fill", "black"); //triangle symbol as controller
 
       var jsonTriangle = [{
-        "x": this._width - this._margin.left - this._margin.right + 7,
-        "y": this._y(this._elevationBounds.min),
-        "color": "black",
-        "type": symbolTriangle,
-        "angle": -90,
-        "size": 100
+        x: this._width - this._margin.left - this._margin.right + 7,
+        y: this._y(this._elevationBounds.min),
+        color: "black",
+        type: symbolTriangle,
+        angle: -90,
+        size: 100
       }];
 
       var dragstart = function dragstart(d) {
@@ -5226,7 +5226,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
           self._highlightedCoords = self._findCoordsForY(eventY);
         }
 
-        select(".horizontalLineText").attr("y", eventY <= 10 ? 0 : eventY > maxY ? maxY - 10 : eventY - 10).text(format(".0f")(self._y.invert(eventY < 0 ? 0 : eventY > maxY ? maxY : eventY)) + " m");
+        select(".horizontalLineText").attr("y", eventY <= 10 ? 0 : eventY > maxY ? maxY - 10 : eventY - 10).text(format(".0f")((self._y.invert(eventY < 0 ? 0 : eventY > maxY ? maxY : eventY) * 3.281).toFixed(0)) + " ft");
 
         self._removeMarkedSegmentsOnMap();
 
@@ -5313,18 +5313,18 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       if (shortDist === true) {
         this._xAxis.tickFormat(function (d) {
-          return format(".2f")(d) + " km";
+          return format(".2f")(d / 1.852) + " nm";
         });
       } else {
         this._xAxis.tickFormat(function (d) {
-          return format(".0f")(d) + " km";
+          return format(".0f")(d / 1.852) + " nm";
         });
       }
 
       this._xAxis.ticks(this.options.xTicks ? Math.pow(2, this.options.xTicks) : Math.round(this._svgWidth / 75), "s");
 
       this._yAxis = axisLeft().scale(this._y).tickFormat(function (d) {
-        return d + " m";
+        return (d * 3.281).toFixed(0) + " ft";
       });
 
       this._yAxis.ticks(this.options.yTicks ? Math.pow(2, this.options.yTicks) : Math.round(this._svgHeight / 30), "s");
@@ -5338,10 +5338,10 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       if (L.Browser.android) {
         background.on("touchstart.drag", this._dragHandler.bind(this)).on("touchstart.drag", this._dragStartHandler.bind(this)).on("touchstart.focusbox", this._mousemoveHandler.bind(this));
-        L.DomEvent.on(this._container, 'touchend', this._dragEndHandler, this);
+        L.DomEvent.on(this._container, "touchend", this._dragEndHandler, this);
       } else {
         background.on("mousemove.focusbox", this._mousemoveHandler.bind(this)).on("mouseout.focusbox", this._mouseoutHandler.bind(this)).on("mousedown.drag", this._dragStartHandler.bind(this)).on("mousemove.drag", this._dragHandler.bind(this));
-        L.DomEvent.on(this._container, 'mouseup', this._dragEndHandler, this);
+        L.DomEvent.on(this._container, "mouseup", this._dragEndHandler, this);
       }
     },
 
@@ -5353,9 +5353,9 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
 
       this._svg.append("g").attr("class", "grid").call(this._make_y_axis().tickSize(-this._svgWidth, 0, 0).ticks(Math.round(this._svgHeight / 30)).tickFormat(""));
 
-      this._svg.append('g').attr("transform", "translate(0," + this._svgHeight + ")").attr('class', 'x axis').call(this._xAxis);
+      this._svg.append("g").attr("transform", "translate(0," + this._svgHeight + ")").attr("class", "x axis").call(this._xAxis);
 
-      this._svg.append('g').attr("transform", "translate(-2,0)").attr('class', 'y axis').call(this._yAxis);
+      this._svg.append("g").attr("transform", "translate(-2,0)").attr("class", "y axis").call(this._yAxis);
     },
 
     /**
@@ -5395,19 +5395,19 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
           height = this._height - this._margin.bottom;
       var verticalItemPosition = height + this._margin.bottom / 2 + 6;
       var jsonTriangles = [{
-        "x": width - 25,
-        "y": verticalItemPosition + 3,
-        "color": "#000",
-        "type": symbolTriangle,
-        "id": "leftArrowSelection",
-        "angle": 0
+        x: width - 25,
+        y: verticalItemPosition + 3,
+        color: "#000",
+        type: symbolTriangle,
+        id: "leftArrowSelection",
+        angle: 0
       }, {
-        "x": width - 10,
-        "y": verticalItemPosition,
-        "color": "#000",
-        "type": symbolTriangle,
-        "id": "rightArrowSelection",
-        "angle": 180
+        x: width - 10,
+        y: verticalItemPosition,
+        color: "#000",
+        type: symbolTriangle,
+        id: "rightArrowSelection",
+        angle: 180
       }]; // Use update pattern to update existing symbols in case of resize
 
       var selectionSign = svg.selectAll(".select-symbol").data(jsonTriangles); // remove any existing selection first
@@ -5446,9 +5446,9 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
         }
 
         var data = [{
-          "selection": type.text
+          selection: type.text
         }];
-        self._selectionText = svg.selectAll('selection_text').data(data).enter().append('text').attr("x", width - 35).attr("y", verticalItemPosition + 4).text(function (d) {
+        self._selectionText = svg.selectAll("selection_text").data(data).enter().append("text").attr("x", width - 35).attr("y", verticalItemPosition + 4).text(function (d) {
           return d.selection;
         }).attr("class", "select-info").attr("id", "selectionText").attr("text-anchor", "end");
       };
@@ -5506,7 +5506,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       var height = this._height - this._margin.bottom;
       var verticalItemPosition = height + this._margin.bottom / 2;
       var leg = [{
-        "text": this._getTranslation("legend")
+        text: this._getTranslation("legend")
       }];
       var legendRectSize = 7;
       var legendSpacing = 7;
@@ -5519,47 +5519,47 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
         return "translate(" + horizontal + "," + vertical + ")";
       });
 
-      var legendRect = legend.append('rect').attr('class', 'legend-rect').attr('x', 15).attr('y', 6 * 6).attr('width', 6).attr('height', 6);
+      var legendRect = legend.append("rect").attr("class", "legend-rect").attr("x", 15).attr("y", 6 * 6).attr("width", 6).attr("height", 6);
 
       if (Object.keys(this._graphStyle).length !== 0) {
-        legendRect.styles(this._graphStyle).style('stroke', function (d, i) {
+        legendRect.styles(this._graphStyle).style("stroke", function (d, i) {
           return d.color;
-        }).style('fill', function (d, i) {
+        }).style("fill", function (d, i) {
           return d.color;
         });
       } else {
-        legendRect.style('stroke', 'black').style('fill', function (d, i) {
+        legendRect.style("stroke", "black").style("fill", function (d, i) {
           return d.color;
         });
       }
 
-      legend.append('text').attr('class', 'legend-text').attr('x', 30).attr('y', 6 * 7).text(function (d, i) {
+      legend.append("text").attr("class", "legend-text").attr("x", 30).attr("y", 6 * 7).text(function (d, i) {
         var textProp = d.text;
         self._boxBoundY = (height - 2 * height / 3 + 7) * i;
         return textProp;
       });
 
-      var legendHover = this._svg.selectAll('.legend-hover').data(leg).enter().append('g').attr('class', 'legend-hover');
+      var legendHover = this._svg.selectAll(".legend-hover").data(leg).enter().append("g").attr("class", "legend-hover");
 
       this._showLegend = false;
-      legendHover.append('text').attr('x', 15).attr('y', verticalItemPosition).attr('text-anchor', "start").text(function (d, i) {
+      legendHover.append("text").attr("x", 15).attr("y", verticalItemPosition).attr("text-anchor", "start").text(function (d, i) {
         return d.text;
-      }).on('mouseover', function () {
-        selectAll('.legend').style("display", "block");
-      }).on('mouseleave', function () {
+      }).on("mouseover", function () {
+        selectAll(".legend").style("display", "block");
+      }).on("mouseleave", function () {
         if (!_this._showLegend) {
-          selectAll('.legend').style("display", "none");
+          selectAll(".legend").style("display", "none");
         }
-      }).on('click', function () {
+      }).on("click", function () {
         _this._showLegend = !_this._showLegend;
       });
     },
 
     /**
-    * calculates the margins of boxes
-    * @param {String} className: name of the class
-    * @return {array} borders: number of text lines, widest range of text
-    */
+     * calculates the margins of boxes
+     * @param {String} className: name of the class
+     * @return {array} borders: number of text lines, widest range of text
+     */
     _dynamicBoxSize: function _dynamicBoxSize(className) {
       var cnt = selectAll(className).nodes().length;
       var widths = [];
@@ -5586,18 +5586,18 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
         return y(d.altitude);
       }).curve(curveBasis);
 
-      this._svg.append("svg:path").attr("d", borderTopLine(data)).attr('class', 'border-top');
+      this._svg.append("svg:path").attr("d", borderTopLine(data)).attr("class", "border-top");
     },
 
     /*
      * Handles the mouseout event when the mouse leaves the background
      */
     _mouseoutHandler: function _mouseoutHandler() {
-      for (var _i = 0, _arr = ['_focusLine', '_focus', '_pointG', '_mouseHeightFocus', '_mouseHeightFocusLabel']; _i < _arr.length; _i++) {
+      for (var _i = 0, _arr = ["_focusLine", "_focus", "_pointG", "_mouseHeightFocus", "_mouseHeightFocusLabel"]; _i < _arr.length; _i++) {
         var param = _arr[_i];
 
         if (this[param]) {
-          this[param].style('display', 'none');
+          this[param].style("display", "none");
         }
       }
     },
@@ -5709,17 +5709,17 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
         this._showMapMarker(ll, alt, type);
       }
 
-      this._distTspan.text(" " + dist.toFixed(1) + ' km');
+      this._distTspan.text(" " + (dist / 1.852).toFixed(1) + "nm");
 
-      this._altTspan.text(" " + alt + ' m');
+      this._altTspan.text(" " + (alt * 3.281).toFixed(0) + " ft");
 
-      this._areaTspan.text(" " + areaLength.toFixed(1) + ' km');
+      this._areaTspan.text(" " + (areaLength / 1.852).toFixed(1) + " nm");
 
       this._typeTspan.text(" " + type);
 
       this._focusRect.attr("width", boxWidth);
 
-      this._focusLine.style("display", "block").attr('x1', this._x(dist)).attr('x2', this._x(dist));
+      this._focusLine.style("display", "block").attr("x1", this._x(dist)).attr("x2", this._x(dist));
 
       var xPositionBox = this._x(dist) - (boxWidth + 5);
       var totalWidth = this._width - this._margin.left - this._margin.right;
@@ -5794,7 +5794,7 @@ var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9b
       if (this.options.translation[key]) return this.options.translation[key];
       if (this._defaultTranslation[key]) return this._defaultTranslation[key];
       console.error("Unexpected error when looking up the translation for " + key);
-      return 'No translation found';
+      return "No translation found";
     }
   });
 
diff --git a/dist/L.Control.Heightgraph.min.js b/dist/L.Control.Heightgraph.min.js
index 008c4c1b030ed7daa4ab240da26d54bf6a610b98..0d95ba03f27d10c45ed224f3486d191f8daafcdf 100644
--- a/dist/L.Control.Heightgraph.min.js
+++ b/dist/L.Control.Heightgraph.min.js
@@ -1 +1 @@
-!function(){"use strict";function t(n){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(n)}function n(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function e(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function r(t){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?e(Object(i),!0).forEach((function(e){n(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(i,n))}))}return t}function i(t,n){(null==n||n>t.length)&&(n=t.length);for(var e=0,r=new Array(n);e<n;e++)r[e]=t[e];return r}function o(t,n){var e;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(e=function(t,n){if(t){if("string"==typeof t)return i(t,n);var e=Object.prototype.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(t,n):void 0}}(t))||n&&t&&"number"==typeof t.length){e&&(t=e);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,s=!0,u=!1;return{s:function(){e=t[Symbol.iterator]()},n:function(){var t=e.next();return s=t.done,t},e:function(t){u=!0,a=t},f:function(){try{s||null==e.return||e.return()}finally{if(u)throw a}}}}var a="http://www.w3.org/1999/xhtml",s={svg:"http://www.w3.org/2000/svg",xhtml:a,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};function u(t){var n=t+="",e=n.indexOf(":");return e>=0&&"xmlns"!==(n=t.slice(0,e))&&(t=t.slice(e+1)),s.hasOwnProperty(n)?{space:s[n],local:t}:t}function l(t){return function(){var n=this.ownerDocument,e=this.namespaceURI;return e===a&&n.documentElement.namespaceURI===a?n.createElement(t):n.createElementNS(e,t)}}function h(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}function c(t){var n=u(t);return(n.local?h:l)(n)}function f(){}function d(t){return null==t?f:function(){return this.querySelector(t)}}function p(){return[]}function g(t){return null==t?p:function(){return this.querySelectorAll(t)}}function _(t){return function(){return this.matches(t)}}function v(t){return new Array(t.length)}function y(t,n){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=n}y.prototype={constructor:y,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,n){return this._parent.insertBefore(t,n)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}};function m(t,n,e,r,i,o){for(var a,s=0,u=n.length,l=o.length;s<l;++s)(a=n[s])?(a.__data__=o[s],r[s]=a):e[s]=new y(t,o[s]);for(;s<u;++s)(a=n[s])&&(i[s]=a)}function x(t,n,e,r,i,o,a){var s,u,l,h={},c=n.length,f=o.length,d=new Array(c);for(s=0;s<c;++s)(u=n[s])&&(d[s]=l="$"+a.call(u,u.__data__,s,n),l in h?i[s]=u:h[l]=u);for(s=0;s<f;++s)(u=h[l="$"+a.call(t,o[s],s,o)])?(r[s]=u,u.__data__=o[s],h[l]=null):e[s]=new y(t,o[s]);for(s=0;s<c;++s)(u=n[s])&&h[d[s]]===u&&(i[s]=u)}function w(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function b(t){return function(){this.removeAttribute(t)}}function M(t){return function(){this.removeAttributeNS(t.space,t.local)}}function k(t,n){return function(){this.setAttribute(t,n)}}function A(t,n){return function(){this.setAttributeNS(t.space,t.local,n)}}function S(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}}function T(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}}function N(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView}function C(t){return function(){this.style.removeProperty(t)}}function E(t,n,e){return function(){this.style.setProperty(t,n,e)}}function H(t,n,e){return function(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}}function D(t,n){return t.style.getPropertyValue(n)||N(t).getComputedStyle(t,null).getPropertyValue(n)}function F(t){return function(){delete this[t]}}function P(t,n){return function(){this[t]=n}}function B(t,n){return function(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}}function O(t){return t.trim().split(/^|\s+/)}function z(t){return t.classList||new I(t)}function I(t){this._node=t,this._names=O(t.getAttribute("class")||"")}function j(t,n){for(var e=z(t),r=-1,i=n.length;++r<i;)e.add(n[r])}function R(t,n){for(var e=z(t),r=-1,i=n.length;++r<i;)e.remove(n[r])}function q(t){return function(){j(this,t)}}function X(t){return function(){R(this,t)}}function $(t,n){return function(){(n.apply(this,arguments)?j:R)(this,t)}}function G(){this.textContent=""}function V(t){return function(){this.textContent=t}}function Y(t){return function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}}function U(){this.innerHTML=""}function W(t){return function(){this.innerHTML=t}}function Z(t){return function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}}function K(){this.nextSibling&&this.parentNode.appendChild(this)}function Q(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function J(){return null}function tt(){var t=this.parentNode;t&&t.removeChild(this)}function nt(){var t=this.cloneNode(!1),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}function et(){var t=this.cloneNode(!0),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}I.prototype={add:function(t){this._names.indexOf(t)<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var n=this._names.indexOf(t);n>=0&&(this._names.splice(n,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};var rt={},it=null;"undefined"!=typeof document&&("onmouseenter"in document.documentElement||(rt={mouseenter:"mouseover",mouseleave:"mouseout"}));function ot(t,n,e){return t=at(t,n,e),function(n){var e=n.relatedTarget;e&&(e===this||8&e.compareDocumentPosition(this))||t.call(this,n)}}function at(t,n,e){return function(r){var i=it;it=r;try{t.call(this,this.__data__,n,e)}finally{it=i}}}function st(t){return t.trim().split(/^|\s+/).map((function(t){var n="",e=t.indexOf(".");return e>=0&&(n=t.slice(e+1),t=t.slice(0,e)),{type:t,name:n}}))}function ut(t){return function(){var n=this.__on;if(n){for(var e,r=0,i=-1,o=n.length;r<o;++r)e=n[r],t.type&&e.type!==t.type||e.name!==t.name?n[++i]=e:this.removeEventListener(e.type,e.listener,e.capture);++i?n.length=i:delete this.__on}}}function lt(t,n,e){var r=rt.hasOwnProperty(t.type)?ot:at;return function(i,o,a){var s,u=this.__on,l=r(n,o,a);if(u)for(var h=0,c=u.length;h<c;++h)if((s=u[h]).type===t.type&&s.name===t.name)return this.removeEventListener(s.type,s.listener,s.capture),this.addEventListener(s.type,s.listener=l,s.capture=e),void(s.value=n);this.addEventListener(t.type,l,e),s={type:t.type,name:t.name,value:n,listener:l,capture:e},u?u.push(s):this.__on=[s]}}function ht(t,n,e,r){var i=it;t.sourceEvent=it,it=t;try{return n.apply(e,r)}finally{it=i}}function ct(t,n,e){var r=N(t),i=r.CustomEvent;"function"==typeof i?i=new i(n,e):(i=r.document.createEvent("Event"),e?(i.initEvent(n,e.bubbles,e.cancelable),i.detail=e.detail):i.initEvent(n,!1,!1)),t.dispatchEvent(i)}function ft(t,n){return function(){return ct(this,t,n)}}function dt(t,n){return function(){return ct(this,t,n.apply(this,arguments))}}var pt=[null];function gt(t,n){this._groups=t,this._parents=n}function _t(){return new gt([[document.documentElement]],pt)}function vt(t){return"string"==typeof t?new gt([[document.querySelector(t)]],[document.documentElement]):new gt([[t]],pt)}function yt(){for(var t,n=it;t=n.sourceEvent;)n=t;return n}function mt(t,n){var e=t.ownerSVGElement||t;if(e.createSVGPoint){var r=e.createSVGPoint();return r.x=n.clientX,r.y=n.clientY,[(r=r.matrixTransform(t.getScreenCTM().inverse())).x,r.y]}var i=t.getBoundingClientRect();return[n.clientX-i.left-t.clientLeft,n.clientY-i.top-t.clientTop]}function xt(t){var n=yt();return n.changedTouches&&(n=n.changedTouches[0]),mt(t,n)}function wt(t){return"string"==typeof t?new gt([document.querySelectorAll(t)],[document.documentElement]):new gt([null==t?[]:t],pt)}function bt(t,n,e){arguments.length<3&&(e=n,n=yt().changedTouches);for(var r,i=0,o=n?n.length:0;i<o;++i)if((r=n[i]).identifier===e)return mt(t,r);return null}gt.prototype=_t.prototype={constructor:gt,select:function(t){"function"!=typeof t&&(t=d(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a,s=n[i],u=s.length,l=r[i]=new Array(u),h=0;h<u;++h)(o=s[h])&&(a=t.call(o,o.__data__,h,s))&&("__data__"in o&&(a.__data__=o.__data__),l[h]=a);return new gt(r,this._parents)},selectAll:function(t){"function"!=typeof t&&(t=g(t));for(var n=this._groups,e=n.length,r=[],i=[],o=0;o<e;++o)for(var a,s=n[o],u=s.length,l=0;l<u;++l)(a=s[l])&&(r.push(t.call(a,a.__data__,l,s)),i.push(a));return new gt(r,i)},filter:function(t){"function"!=typeof t&&(t=_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],s=a.length,u=r[i]=[],l=0;l<s;++l)(o=a[l])&&t.call(o,o.__data__,l,a)&&u.push(o);return new gt(r,this._parents)},data:function(t,n){if(!t)return d=new Array(this.size()),l=-1,this.each((function(t){d[++l]=t})),d;var e=n?x:m,r=this._parents,i=this._groups;"function"!=typeof t&&(t=function(t){return function(){return t}}(t));for(var o=i.length,a=new Array(o),s=new Array(o),u=new Array(o),l=0;l<o;++l){var h=r[l],c=i[l],f=c.length,d=t.call(h,h&&h.__data__,l,r),p=d.length,g=s[l]=new Array(p),_=a[l]=new Array(p);e(h,c,g,_,u[l]=new Array(f),d,n);for(var v,y,w=0,b=0;w<p;++w)if(v=g[w]){for(w>=b&&(b=w+1);!(y=_[b])&&++b<p;);v._next=y||null}}return(a=new gt(a,r))._enter=s,a._exit=u,a},enter:function(){return new gt(this._enter||this._groups.map(v),this._parents)},exit:function(){return new gt(this._exit||this._groups.map(v),this._parents)},join:function(t,n,e){var r=this.enter(),i=this,o=this.exit();return r="function"==typeof t?t(r):r.append(t+""),null!=n&&(i=n(i)),null==e?o.remove():e(o),r&&i?r.merge(i).order():i},merge:function(t){for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,l=n[s],h=e[s],c=l.length,f=a[s]=new Array(c),d=0;d<c;++d)(u=l[d]||h[d])&&(f[d]=u);for(;s<r;++s)a[s]=n[s];return new gt(a,this._parents)},order:function(){for(var t=this._groups,n=-1,e=t.length;++n<e;)for(var r,i=t[n],o=i.length-1,a=i[o];--o>=0;)(r=i[o])&&(a&&4^r.compareDocumentPosition(a)&&a.parentNode.insertBefore(r,a),a=r);return this},sort:function(t){function n(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}t||(t=w);for(var e=this._groups,r=e.length,i=new Array(r),o=0;o<r;++o){for(var a,s=e[o],u=s.length,l=i[o]=new Array(u),h=0;h<u;++h)(a=s[h])&&(l[h]=a);l.sort(n)}return new gt(i,this._parents).order()},call:function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},nodes:function(){var t=new Array(this.size()),n=-1;return this.each((function(){t[++n]=this})),t},node:function(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r=t[n],i=0,o=r.length;i<o;++i){var a=r[i];if(a)return a}return null},size:function(){var t=0;return this.each((function(){++t})),t},empty:function(){return!this.node()},each:function(t){for(var n=this._groups,e=0,r=n.length;e<r;++e)for(var i,o=n[e],a=0,s=o.length;a<s;++a)(i=o[a])&&t.call(i,i.__data__,a,o);return this},attr:function(t,n){var e=u(t);if(arguments.length<2){var r=this.node();return e.local?r.getAttributeNS(e.space,e.local):r.getAttribute(e)}return this.each((null==n?e.local?M:b:"function"==typeof n?e.local?T:S:e.local?A:k)(e,n))},style:function(t,n,e){return arguments.length>1?this.each((null==n?C:"function"==typeof n?H:E)(t,n,null==e?"":e)):D(this.node(),t)},property:function(t,n){return arguments.length>1?this.each((null==n?F:"function"==typeof n?B:P)(t,n)):this.node()[t]},classed:function(t,n){var e=O(t+"");if(arguments.length<2){for(var r=z(this.node()),i=-1,o=e.length;++i<o;)if(!r.contains(e[i]))return!1;return!0}return this.each(("function"==typeof n?$:n?q:X)(e,n))},text:function(t){return arguments.length?this.each(null==t?G:("function"==typeof t?Y:V)(t)):this.node().textContent},html:function(t){return arguments.length?this.each(null==t?U:("function"==typeof t?Z:W)(t)):this.node().innerHTML},raise:function(){return this.each(K)},lower:function(){return this.each(Q)},append:function(t){var n="function"==typeof t?t:c(t);return this.select((function(){return this.appendChild(n.apply(this,arguments))}))},insert:function(t,n){var e="function"==typeof t?t:c(t),r=null==n?J:"function"==typeof n?n:d(n);return this.select((function(){return this.insertBefore(e.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(tt)},clone:function(t){return this.select(t?et:nt)},datum:function(t){return arguments.length?this.property("__data__",t):this.node().__data__},on:function(t,n,e){var r,i,o=st(t+""),a=o.length;if(!(arguments.length<2)){for(s=n?lt:ut,null==e&&(e=!1),r=0;r<a;++r)this.each(s(o[r],n,e));return this}var s=this.node().__on;if(s)for(var u,l=0,h=s.length;l<h;++l)for(r=0,u=s[l];r<a;++r)if((i=o[r]).type===u.type&&i.name===u.name)return u.value},dispatch:function(t,n){return this.each(("function"==typeof n?dt:ft)(t,n))}};var Mt={value:function(){}};function kt(){for(var t,n=0,e=arguments.length,r={};n<e;++n){if(!(t=arguments[n]+"")||t in r||/[\s.]/.test(t))throw new Error("illegal type: "+t);r[t]=[]}return new At(r)}function At(t){this._=t}function St(t,n){return t.trim().split(/^|\s+/).map((function(t){var e="",r=t.indexOf(".");if(r>=0&&(e=t.slice(r+1),t=t.slice(0,r)),t&&!n.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:e}}))}function Tt(t,n){for(var e,r=0,i=t.length;r<i;++r)if((e=t[r]).name===n)return e.value}function Nt(t,n,e){for(var r=0,i=t.length;r<i;++r)if(t[r].name===n){t[r]=Mt,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=e&&t.push({name:n,value:e}),t}At.prototype=kt.prototype={constructor:At,on:function(t,n){var e,r=this._,i=St(t+"",r),o=-1,a=i.length;if(!(arguments.length<2)){if(null!=n&&"function"!=typeof n)throw new Error("invalid callback: "+n);for(;++o<a;)if(e=(t=i[o]).type)r[e]=Nt(r[e],t.name,n);else if(null==n)for(e in r)r[e]=Nt(r[e],t.name,null);return this}for(;++o<a;)if((e=(t=i[o]).type)&&(e=Tt(r[e],t.name)))return e},copy:function(){var t={},n=this._;for(var e in n)t[e]=n[e].slice();return new At(t)},call:function(t,n){if((e=arguments.length-2)>0)for(var e,r,i=new Array(e),o=0;o<e;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(o=0,e=(r=this._[t]).length;o<e;++o)r[o].value.apply(n,i)},apply:function(t,n,e){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(n,e)}};var Ct,Et,Ht=0,Lt=0,Dt=0,Ft=0,Pt=0,Bt=0,Ot="object"==typeof performance&&performance.now?performance:Date,zt="object"==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(t){setTimeout(t,17)};function It(){return Pt||(zt(jt),Pt=Ot.now()+Bt)}function jt(){Pt=0}function Rt(){this._call=this._time=this._next=null}function qt(t,n,e){var r=new Rt;return r.restart(t,n,e),r}function Xt(){Pt=(Ft=Ot.now())+Bt,Ht=Lt=0;try{!function(){It(),++Ht;for(var t,n=Ct;n;)(t=Pt-n._time)>=0&&n._call.call(null,t),n=n._next;--Ht}()}finally{Ht=0,function(){var t,n,e=Ct,r=1/0;for(;e;)e._call?(r>e._time&&(r=e._time),t=e,e=e._next):(n=e._next,e._next=null,e=t?t._next=n:Ct=n);Et=t,Gt(r)}(),Pt=0}}function $t(){var t=Ot.now(),n=t-Ft;n>1e3&&(Bt-=n,Ft=t)}function Gt(t){Ht||(Lt&&(Lt=clearTimeout(Lt)),t-Pt>24?(t<1/0&&(Lt=setTimeout(Xt,t-Ot.now()-Bt)),Dt&&(Dt=clearInterval(Dt))):(Dt||(Ft=Ot.now(),Dt=setInterval($t,1e3)),Ht=1,zt(Xt)))}function Vt(t,n,e){var r=new Rt;return n=null==n?0:+n,r.restart((function(e){r.stop(),t(e+n)}),n,e),r}Rt.prototype=qt.prototype={constructor:Rt,restart:function(t,n,e){if("function"!=typeof t)throw new TypeError("callback is not a function");e=(null==e?It():+e)+(null==n?0:+n),this._next||Et===this||(Et?Et._next=this:Ct=this,Et=this),this._call=t,this._time=e,Gt()},stop:function(){this._call&&(this._call=null,this._time=1/0,Gt())}};var Yt=kt("start","end","cancel","interrupt"),Ut=[];function Wt(t,n,e,r,i,o){var a=t.__transition;if(a){if(e in a)return}else t.__transition={};!function(t,n,e){var r,i=t.__transition;function o(u){var l,h,c,f;if(1!==e.state)return s();for(l in i)if((f=i[l]).name===e.name){if(3===f.state)return Vt(o);4===f.state?(f.state=6,f.timer.stop(),f.on.call("interrupt",t,t.__data__,f.index,f.group),delete i[l]):+l<n&&(f.state=6,f.timer.stop(),f.on.call("cancel",t,t.__data__,f.index,f.group),delete i[l])}if(Vt((function(){3===e.state&&(e.state=4,e.timer.restart(a,e.delay,e.time),a(u))})),e.state=2,e.on.call("start",t,t.__data__,e.index,e.group),2===e.state){for(e.state=3,r=new Array(c=e.tween.length),l=0,h=-1;l<c;++l)(f=e.tween[l].value.call(t,t.__data__,e.index,e.group))&&(r[++h]=f);r.length=h+1}}function a(n){for(var i=n<e.duration?e.ease.call(null,n/e.duration):(e.timer.restart(s),e.state=5,1),o=-1,a=r.length;++o<a;)r[o].call(t,i);5===e.state&&(e.on.call("end",t,t.__data__,e.index,e.group),s())}function s(){for(var r in e.state=6,e.timer.stop(),delete i[n],i)return;delete t.__transition}i[n]=e,e.timer=qt((function(t){e.state=1,e.timer.restart(o,e.delay,e.time),e.delay<=t&&o(t-e.delay)}),0,e.time)}(t,e,{name:n,index:r,group:i,on:Yt,tween:Ut,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:0})}function Zt(t,n){var e=Qt(t,n);if(e.state>0)throw new Error("too late; already scheduled");return e}function Kt(t,n){var e=Qt(t,n);if(e.state>3)throw new Error("too late; already running");return e}function Qt(t,n){var e=t.__transition;if(!e||!(e=e[n]))throw new Error("transition not found");return e}function Jt(t,n,e){t.prototype=n.prototype=e,e.constructor=t}function tn(t,n){var e=Object.create(t.prototype);for(var r in n)e[r]=n[r];return e}function nn(){}var en="\\s*([+-]?\\d+)\\s*",rn="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",on="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",an=/^#([0-9a-f]{3,8})$/,sn=new RegExp("^rgb\\("+[en,en,en]+"\\)$"),un=new RegExp("^rgb\\("+[on,on,on]+"\\)$"),ln=new RegExp("^rgba\\("+[en,en,en,rn]+"\\)$"),hn=new RegExp("^rgba\\("+[on,on,on,rn]+"\\)$"),cn=new RegExp("^hsl\\("+[rn,on,on]+"\\)$"),fn=new RegExp("^hsla\\("+[rn,on,on,rn]+"\\)$"),dn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function pn(){return this.rgb().formatHex()}function gn(){return this.rgb().formatRgb()}function _n(t){var n,e;return t=(t+"").trim().toLowerCase(),(n=an.exec(t))?(e=n[1].length,n=parseInt(n[1],16),6===e?vn(n):3===e?new wn(n>>8&15|n>>4&240,n>>4&15|240&n,(15&n)<<4|15&n,1):8===e?yn(n>>24&255,n>>16&255,n>>8&255,(255&n)/255):4===e?yn(n>>12&15|n>>8&240,n>>8&15|n>>4&240,n>>4&15|240&n,((15&n)<<4|15&n)/255):null):(n=sn.exec(t))?new wn(n[1],n[2],n[3],1):(n=un.exec(t))?new wn(255*n[1]/100,255*n[2]/100,255*n[3]/100,1):(n=ln.exec(t))?yn(n[1],n[2],n[3],n[4]):(n=hn.exec(t))?yn(255*n[1]/100,255*n[2]/100,255*n[3]/100,n[4]):(n=cn.exec(t))?An(n[1],n[2]/100,n[3]/100,1):(n=fn.exec(t))?An(n[1],n[2]/100,n[3]/100,n[4]):dn.hasOwnProperty(t)?vn(dn[t]):"transparent"===t?new wn(NaN,NaN,NaN,0):null}function vn(t){return new wn(t>>16&255,t>>8&255,255&t,1)}function yn(t,n,e,r){return r<=0&&(t=n=e=NaN),new wn(t,n,e,r)}function mn(t){return t instanceof nn||(t=_n(t)),t?new wn((t=t.rgb()).r,t.g,t.b,t.opacity):new wn}function xn(t,n,e,r){return 1===arguments.length?mn(t):new wn(t,n,e,null==r?1:r)}function wn(t,n,e,r){this.r=+t,this.g=+n,this.b=+e,this.opacity=+r}function bn(){return"#"+kn(this.r)+kn(this.g)+kn(this.b)}function Mn(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}function kn(t){return((t=Math.max(0,Math.min(255,Math.round(t)||0)))<16?"0":"")+t.toString(16)}function An(t,n,e,r){return r<=0?t=n=e=NaN:e<=0||e>=1?t=n=NaN:n<=0&&(t=NaN),new Tn(t,n,e,r)}function Sn(t){if(t instanceof Tn)return new Tn(t.h,t.s,t.l,t.opacity);if(t instanceof nn||(t=_n(t)),!t)return new Tn;if(t instanceof Tn)return t;var n=(t=t.rgb()).r/255,e=t.g/255,r=t.b/255,i=Math.min(n,e,r),o=Math.max(n,e,r),a=NaN,s=o-i,u=(o+i)/2;return s?(a=n===o?(e-r)/s+6*(e<r):e===o?(r-n)/s+2:(n-e)/s+4,s/=u<.5?o+i:2-o-i,a*=60):s=u>0&&u<1?0:a,new Tn(a,s,u,t.opacity)}function Tn(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function Nn(t,n,e){return 255*(t<60?n+(e-n)*t/60:t<180?e:t<240?n+(e-n)*(240-t)/60:n)}function Cn(t){return function(){return t}}function En(t){return 1==(t=+t)?Hn:function(n,e){return e-n?function(t,n,e){return t=Math.pow(t,e),n=Math.pow(n,e)-t,e=1/e,function(r){return Math.pow(t+r*n,e)}}(n,e,t):Cn(isNaN(n)?e:n)}}function Hn(t,n){var e=n-t;return e?function(t,n){return function(e){return t+e*n}}(t,e):Cn(isNaN(t)?n:t)}Jt(nn,_n,{copy:function(t){return Object.assign(new this.constructor,this,t)},displayable:function(){return this.rgb().displayable()},hex:pn,formatHex:pn,formatHsl:function(){return Sn(this).formatHsl()},formatRgb:gn,toString:gn}),Jt(wn,xn,tn(nn,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new wn(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new wn(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:bn,formatHex:bn,formatRgb:Mn,toString:Mn})),Jt(Tn,(function(t,n,e,r){return 1===arguments.length?Sn(t):new Tn(t,n,e,null==r?1:r)}),tn(nn,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new Tn(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new Tn(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),n=isNaN(t)||isNaN(this.s)?0:this.s,e=this.l,r=e+(e<.5?e:1-e)*n,i=2*e-r;return new wn(Nn(t>=240?t-240:t+120,i,r),Nn(t,i,r),Nn(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl:function(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"hsl(":"hsla(")+(this.h||0)+", "+100*(this.s||0)+"%, "+100*(this.l||0)+"%"+(1===t?")":", "+t+")")}}));var Ln=function t(n){var e=En(n);function r(t,n){var r=e((t=xn(t)).r,(n=xn(n)).r),i=e(t.g,n.g),o=e(t.b,n.b),a=Hn(t.opacity,n.opacity);return function(n){return t.r=r(n),t.g=i(n),t.b=o(n),t.opacity=a(n),t+""}}return r.gamma=t,r}(1);function Dn(t,n){n||(n=[]);var e,r=t?Math.min(n.length,t.length):0,i=n.slice();return function(o){for(e=0;e<r;++e)i[e]=t[e]*(1-o)+n[e]*o;return i}}function Fn(t,n){var e,r=n?n.length:0,i=t?Math.min(r,t.length):0,o=new Array(i),a=new Array(r);for(e=0;e<i;++e)o[e]=Rn(t[e],n[e]);for(;e<r;++e)a[e]=n[e];return function(t){for(e=0;e<i;++e)a[e]=o[e](t);return a}}function Pn(t,n){var e=new Date;return t=+t,n=+n,function(r){return e.setTime(t*(1-r)+n*r),e}}function Bn(t,n){return t=+t,n=+n,function(e){return t*(1-e)+n*e}}function On(t,n){var e,r={},i={};for(e in null!==t&&"object"==typeof t||(t={}),null!==n&&"object"==typeof n||(n={}),n)e in t?r[e]=Rn(t[e],n[e]):i[e]=n[e];return function(t){for(e in r)i[e]=r[e](t);return i}}var zn=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,In=new RegExp(zn.source,"g");function jn(t,n){var e,r,i,o=zn.lastIndex=In.lastIndex=0,a=-1,s=[],u=[];for(t+="",n+="";(e=zn.exec(t))&&(r=In.exec(n));)(i=r.index)>o&&(i=n.slice(o,i),s[a]?s[a]+=i:s[++a]=i),(e=e[0])===(r=r[0])?s[a]?s[a]+=r:s[++a]=r:(s[++a]=null,u.push({i:a,x:Bn(e,r)})),o=In.lastIndex;return o<n.length&&(i=n.slice(o),s[a]?s[a]+=i:s[++a]=i),s.length<2?u[0]?function(t){return function(n){return t(n)+""}}(u[0].x):function(t){return function(){return t}}(n):(n=u.length,function(t){for(var e,r=0;r<n;++r)s[(e=u[r]).i]=e.x(t);return s.join("")})}function Rn(t,n){var e,r=typeof n;return null==n||"boolean"===r?Cn(n):("number"===r?Bn:"string"===r?(e=_n(n))?(n=e,Ln):jn:n instanceof _n?Ln:n instanceof Date?Pn:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}(n)?Dn:Array.isArray(n)?Fn:"function"!=typeof n.valueOf&&"function"!=typeof n.toString||isNaN(n)?On:Bn)(t,n)}function qn(t,n){return t=+t,n=+n,function(e){return Math.round(t*(1-e)+n*e)}}var Xn,$n,Gn,Vn,Yn=180/Math.PI,Un={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function Wn(t,n,e,r,i,o){var a,s,u;return(a=Math.sqrt(t*t+n*n))&&(t/=a,n/=a),(u=t*e+n*r)&&(e-=t*u,r-=n*u),(s=Math.sqrt(e*e+r*r))&&(e/=s,r/=s,u/=s),t*r<n*e&&(t=-t,n=-n,u=-u,a=-a),{translateX:i,translateY:o,rotate:Math.atan2(n,t)*Yn,skewX:Math.atan(u)*Yn,scaleX:a,scaleY:s}}function Zn(t,n,e,r){function i(t){return t.length?t.pop()+" ":""}return function(o,a){var s=[],u=[];return o=t(o),a=t(a),function(t,r,i,o,a,s){if(t!==i||r!==o){var u=a.push("translate(",null,n,null,e);s.push({i:u-4,x:Bn(t,i)},{i:u-2,x:Bn(r,o)})}else(i||o)&&a.push("translate("+i+n+o+e)}(o.translateX,o.translateY,a.translateX,a.translateY,s,u),function(t,n,e,o){t!==n?(t-n>180?n+=360:n-t>180&&(t+=360),o.push({i:e.push(i(e)+"rotate(",null,r)-2,x:Bn(t,n)})):n&&e.push(i(e)+"rotate("+n+r)}(o.rotate,a.rotate,s,u),function(t,n,e,o){t!==n?o.push({i:e.push(i(e)+"skewX(",null,r)-2,x:Bn(t,n)}):n&&e.push(i(e)+"skewX("+n+r)}(o.skewX,a.skewX,s,u),function(t,n,e,r,o,a){if(t!==e||n!==r){var s=o.push(i(o)+"scale(",null,",",null,")");a.push({i:s-4,x:Bn(t,e)},{i:s-2,x:Bn(n,r)})}else 1===e&&1===r||o.push(i(o)+"scale("+e+","+r+")")}(o.scaleX,o.scaleY,a.scaleX,a.scaleY,s,u),o=a=null,function(t){for(var n,e=-1,r=u.length;++e<r;)s[(n=u[e]).i]=n.x(t);return s.join("")}}}var Kn=Zn((function(t){return"none"===t?Un:(Xn||(Xn=document.createElement("DIV"),$n=document.documentElement,Gn=document.defaultView),Xn.style.transform=t,t=Gn.getComputedStyle($n.appendChild(Xn),null).getPropertyValue("transform"),$n.removeChild(Xn),Wn(+(t=t.slice(7,-1).split(","))[0],+t[1],+t[2],+t[3],+t[4],+t[5]))}),"px, ","px)","deg)"),Qn=Zn((function(t){return null==t?Un:(Vn||(Vn=document.createElementNS("http://www.w3.org/2000/svg","g")),Vn.setAttribute("transform",t),(t=Vn.transform.baseVal.consolidate())?Wn((t=t.matrix).a,t.b,t.c,t.d,t.e,t.f):Un)}),", ",")",")");function Jn(t,n){var e,r;return function(){var i=Kt(this,t),o=i.tween;if(o!==e)for(var a=0,s=(r=e=o).length;a<s;++a)if(r[a].name===n){(r=r.slice()).splice(a,1);break}i.tween=r}}function te(t,n,e){var r,i;if("function"!=typeof e)throw new Error;return function(){var o=Kt(this,t),a=o.tween;if(a!==r){i=(r=a).slice();for(var s={name:n,value:e},u=0,l=i.length;u<l;++u)if(i[u].name===n){i[u]=s;break}u===l&&i.push(s)}o.tween=i}}function ne(t,n,e){var r=t._id;return t.each((function(){var t=Kt(this,r);(t.value||(t.value={}))[n]=e.apply(this,arguments)})),function(t){return Qt(t,r).value[n]}}function ee(t,n){var e;return("number"==typeof n?Bn:n instanceof _n?Ln:(e=_n(n))?(n=e,Ln):jn)(t,n)}function re(t){return function(){this.removeAttribute(t)}}function ie(t){return function(){this.removeAttributeNS(t.space,t.local)}}function oe(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttribute(t);return a===o?null:a===r?i:i=n(r=a,e)}}function ae(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttributeNS(t.space,t.local);return a===o?null:a===r?i:i=n(r=a,e)}}function se(t,n,e){var r,i,o;return function(){var a,s,u=e(this);if(null!=u)return(a=this.getAttribute(t))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=n(r=a,u));this.removeAttribute(t)}}function ue(t,n,e){var r,i,o;return function(){var a,s,u=e(this);if(null!=u)return(a=this.getAttributeNS(t.space,t.local))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=n(r=a,u));this.removeAttributeNS(t.space,t.local)}}function le(t,n){return function(e){this.setAttribute(t,n.call(this,e))}}function he(t,n){return function(e){this.setAttributeNS(t.space,t.local,n.call(this,e))}}function ce(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&he(t,i)),e}return i._value=n,i}function fe(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&le(t,i)),e}return i._value=n,i}function de(t,n){return function(){Zt(this,t).delay=+n.apply(this,arguments)}}function pe(t,n){return n=+n,function(){Zt(this,t).delay=n}}function ge(t,n){return function(){Kt(this,t).duration=+n.apply(this,arguments)}}function _e(t,n){return n=+n,function(){Kt(this,t).duration=n}}function ve(t,n){if("function"!=typeof n)throw new Error;return function(){Kt(this,t).ease=n}}function ye(t,n,e){var r,i,o=function(t){return(t+"").trim().split(/^|\s+/).every((function(t){var n=t.indexOf(".");return n>=0&&(t=t.slice(0,n)),!t||"start"===t}))}(n)?Zt:Kt;return function(){var a=o(this,t),s=a.on;s!==r&&(i=(r=s).copy()).on(n,e),a.on=i}}var me=_t.prototype.constructor;function xe(t){return function(){this.style.removeProperty(t)}}function we(t,n,e){return function(r){this.style.setProperty(t,n.call(this,r),e)}}function be(t,n,e){var r,i;function o(){var o=n.apply(this,arguments);return o!==i&&(r=(i=o)&&we(t,o,e)),r}return o._value=n,o}function Me(t){return function(n){this.textContent=t.call(this,n)}}function ke(t){var n,e;function r(){var r=t.apply(this,arguments);return r!==e&&(n=(e=r)&&Me(r)),n}return r._value=t,r}var Ae=0;function Se(t,n,e,r){this._groups=t,this._parents=n,this._name=e,this._id=r}function Te(t){return _t().transition(t)}function Ne(){return++Ae}var Ce=_t.prototype;Se.prototype=Te.prototype={constructor:Se,select:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=d(t));for(var r=this._groups,i=r.length,o=new Array(i),a=0;a<i;++a)for(var s,u,l=r[a],h=l.length,c=o[a]=new Array(h),f=0;f<h;++f)(s=l[f])&&(u=t.call(s,s.__data__,f,l))&&("__data__"in s&&(u.__data__=s.__data__),c[f]=u,Wt(c[f],n,e,f,c,Qt(s,e)));return new Se(o,this._parents,n,e)},selectAll:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=g(t));for(var r=this._groups,i=r.length,o=[],a=[],s=0;s<i;++s)for(var u,l=r[s],h=l.length,c=0;c<h;++c)if(u=l[c]){for(var f,d=t.call(u,u.__data__,c,l),p=Qt(u,e),_=0,v=d.length;_<v;++_)(f=d[_])&&Wt(f,n,e,_,d,p);o.push(d),a.push(u)}return new Se(o,a,n,e)},filter:function(t){"function"!=typeof t&&(t=_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],s=a.length,u=r[i]=[],l=0;l<s;++l)(o=a[l])&&t.call(o,o.__data__,l,a)&&u.push(o);return new Se(r,this._parents,this._name,this._id)},merge:function(t){if(t._id!==this._id)throw new Error;for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,l=n[s],h=e[s],c=l.length,f=a[s]=new Array(c),d=0;d<c;++d)(u=l[d]||h[d])&&(f[d]=u);for(;s<r;++s)a[s]=n[s];return new Se(a,this._parents,this._name,this._id)},selection:function(){return new me(this._groups,this._parents)},transition:function(){for(var t=this._name,n=this._id,e=Ne(),r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,l=0;l<u;++l)if(a=s[l]){var h=Qt(a,n);Wt(a,t,e,l,s,{time:h.time+h.delay+h.duration,delay:0,duration:h.duration,ease:h.ease})}return new Se(r,this._parents,t,e)},call:Ce.call,nodes:Ce.nodes,node:Ce.node,size:Ce.size,empty:Ce.empty,each:Ce.each,on:function(t,n){var e=this._id;return arguments.length<2?Qt(this.node(),e).on.on(t):this.each(ye(e,t,n))},attr:function(t,n){var e=u(t),r="transform"===e?Qn:ee;return this.attrTween(t,"function"==typeof n?(e.local?ue:se)(e,r,ne(this,"attr."+t,n)):null==n?(e.local?ie:re)(e):(e.local?ae:oe)(e,r,n))},attrTween:function(t,n){var e="attr."+t;if(arguments.length<2)return(e=this.tween(e))&&e._value;if(null==n)return this.tween(e,null);if("function"!=typeof n)throw new Error;var r=u(t);return this.tween(e,(r.local?ce:fe)(r,n))},style:function(t,n,e){var r="transform"==(t+="")?Kn:ee;return null==n?this.styleTween(t,function(t,n){var e,r,i;return function(){var o=D(this,t),a=(this.style.removeProperty(t),D(this,t));return o===a?null:o===e&&a===r?i:i=n(e=o,r=a)}}(t,r)).on("end.style."+t,xe(t)):"function"==typeof n?this.styleTween(t,function(t,n,e){var r,i,o;return function(){var a=D(this,t),s=e(this),u=s+"";return null==s&&(this.style.removeProperty(t),u=s=D(this,t)),a===u?null:a===r&&u===i?o:(i=u,o=n(r=a,s))}}(t,r,ne(this,"style."+t,n))).each(function(t,n){var e,r,i,o,a="style."+n,s="end."+a;return function(){var u=Kt(this,t),l=u.on,h=null==u.value[a]?o||(o=xe(n)):void 0;l===e&&i===h||(r=(e=l).copy()).on(s,i=h),u.on=r}}(this._id,t)):this.styleTween(t,function(t,n,e){var r,i,o=e+"";return function(){var a=D(this,t);return a===o?null:a===r?i:i=n(r=a,e)}}(t,r,n),e).on("end.style."+t,null)},styleTween:function(t,n,e){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==n)return this.tween(r,null);if("function"!=typeof n)throw new Error;return this.tween(r,be(t,n,null==e?"":e))},text:function(t){return this.tween("text","function"==typeof t?function(t){return function(){var n=t(this);this.textContent=null==n?"":n}}(ne(this,"text",t)):function(t){return function(){this.textContent=t}}(null==t?"":t+""))},textTween:function(t){var n="text";if(arguments.length<1)return(n=this.tween(n))&&n._value;if(null==t)return this.tween(n,null);if("function"!=typeof t)throw new Error;return this.tween(n,ke(t))},remove:function(){return this.on("end.remove",function(t){return function(){var n=this.parentNode;for(var e in this.__transition)if(+e!==t)return;n&&n.removeChild(this)}}(this._id))},tween:function(t,n){var e=this._id;if(t+="",arguments.length<2){for(var r,i=Qt(this.node(),e).tween,o=0,a=i.length;o<a;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==n?Jn:te)(e,t,n))},delay:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?de:pe)(n,t)):Qt(this.node(),n).delay},duration:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?ge:_e)(n,t)):Qt(this.node(),n).duration},ease:function(t){var n=this._id;return arguments.length?this.each(ve(n,t)):Qt(this.node(),n).ease},end:function(){var t,n,e=this,r=e._id,i=e.size();return new Promise((function(o,a){var s={value:a},u={value:function(){0==--i&&o()}};e.each((function(){var e=Kt(this,r),i=e.on;i!==t&&((n=(t=i).copy())._.cancel.push(s),n._.interrupt.push(s),n._.end.push(u)),e.on=n}))}))}};var Ee={time:null,delay:0,duration:250,ease:function(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}};function He(t,n){for(var e;!(e=t.__transition)||!(e=e[n]);)if(!(t=t.parentNode))return Ee.time=It(),Ee;return e}function Le(t,n){return t.each((function(){var t=n.apply(this,arguments),e=vt(this);for(var r in t)e.attr(r,t[r])}))}function De(t,n){for(var e in n)t.attr(e,n[e]);return t}function Fe(t,n,e){return t.each((function(){var t=n.apply(this,arguments),r=vt(this);for(var i in t)r.style(i,t[i],e)}))}function Pe(t,n,e){for(var r in n)t.style(r,n[r],e);return t}function Be(t,n){return t.each((function(){var t=n.apply(this,arguments),e=vt(this);for(var r in t)e.property(r,t[r])}))}function Oe(t,n){for(var e in n)t.property(e,n[e]);return t}function ze(t,n){return t.each((function(){var e=n.apply(this,arguments),r=vt(this).transition(t);for(var i in e)r.attr(i,e[i])}))}function Ie(t,n){for(var e in n)t.attr(e,n[e]);return t}function je(t,n,e){return t.each((function(){var r=n.apply(this,arguments),i=vt(this).transition(t);for(var o in r)i.style(o,r[o],e)}))}function Re(t,n,e){for(var r in n)t.style(r,n[r],e);return t}function qe(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function Xe(t){var n;return 1===t.length&&(n=t,t=function(t,e){return qe(n(t),e)}),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)<0?r=o+1:i=o}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)>0?i=o:r=o+1}return r}}}_t.prototype.interrupt=function(t){return this.each((function(){!function(t,n){var e,r,i,o=t.__transition,a=!0;if(o){for(i in n=null==n?null:n+"",o)(e=o[i]).name===n?(r=e.state>2&&e.state<5,e.state=6,e.timer.stop(),e.on.call(r?"interrupt":"cancel",t,t.__data__,e.index,e.group),delete o[i]):a=!1;a&&delete t.__transition}}(this,t)}))},_t.prototype.transition=function(t){var n,e;t instanceof Se?(n=t._id,t=t._name):(n=Ne(),(e=Ee).time=It(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,l=0;l<u;++l)(a=s[l])&&Wt(a,t,n,l,s,e||He(a,n));return new Se(r,this._parents,t,n)},_t.prototype.attrs=function(t){return("function"==typeof t?Le:De)(this,t)},_t.prototype.styles=function(t,n){return("function"==typeof t?Fe:Pe)(this,t,null==n?"":n)},_t.prototype.properties=function(t){return("function"==typeof t?Be:Oe)(this,t)},Te.prototype.attrs=function(t){return("function"==typeof t?ze:Ie)(this,t)},Te.prototype.styles=function(t,n){return("function"==typeof t?je:Re)(this,t,null==n?"":n)};var $e=Xe(qe).right,Ge=Math.sqrt(50),Ve=Math.sqrt(10),Ye=Math.sqrt(2);function Ue(t,n,e){var r=(n-t)/Math.max(0,e),i=Math.floor(Math.log(r)/Math.LN10),o=r/Math.pow(10,i);return i>=0?(o>=Ge?10:o>=Ve?5:o>=Ye?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(o>=Ge?10:o>=Ve?5:o>=Ye?2:1)}function We(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&e>r&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&e>r&&(r=e);return r}function Ze(t,n){switch(arguments.length){case 0:break;case 1:this.range(t);break;default:this.range(n).domain(t)}return this}function Ke(){}function Qe(t,n){var e=new Ke;if(t instanceof Ke)t.each((function(t,n){e.set(n,t)}));else if(Array.isArray(t)){var r,i=-1,o=t.length;if(null==n)for(;++i<o;)e.set(i,t[i]);else for(;++i<o;)e.set(n(r=t[i],i,t),r)}else if(t)for(var a in t)e.set(a,t[a]);return e}function Je(){}Ke.prototype=Qe.prototype={constructor:Ke,has:function(t){return"$"+t in this},get:function(t){return this["$"+t]},set:function(t,n){return this["$"+t]=n,this},remove:function(t){var n="$"+t;return n in this&&delete this[n]},clear:function(){for(var t in this)"$"===t[0]&&delete this[t]},keys:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(n.slice(1));return t},values:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(this[n]);return t},entries:function(){var t=[];for(var n in this)"$"===n[0]&&t.push({key:n.slice(1),value:this[n]});return t},size:function(){var t=0;for(var n in this)"$"===n[0]&&++t;return t},empty:function(){for(var t in this)if("$"===t[0])return!1;return!0},each:function(t){for(var n in this)"$"===n[0]&&t(this[n],n.slice(1),this)}};var tr=Qe.prototype;Je.prototype=function(t,n){var e=new Je;if(t instanceof Je)t.each((function(t){e.add(t)}));else if(t){var r=-1,i=t.length;if(null==n)for(;++r<i;)e.add(t[r]);else for(;++r<i;)e.add(n(t[r],r,t))}return e}.prototype={constructor:Je,has:tr.has,add:function(t){return this["$"+(t+="")]=t,this},remove:tr.remove,clear:tr.clear,values:tr.keys,size:tr.size,empty:tr.empty,each:tr.each};var nr=Array.prototype,er=nr.map,rr=nr.slice,ir={name:"implicit"};function or(t){return+t}var ar=[0,1];function sr(t){return t}function ur(t,n){return(n-=t=+t)?function(e){return(e-t)/n}:function(t){return function(){return t}}(isNaN(n)?NaN:.5)}function lr(t){var n,e=t[0],r=t[t.length-1];return e>r&&(n=e,e=r,r=n),function(t){return Math.max(e,Math.min(r,t))}}function hr(t,n,e){var r=t[0],i=t[1],o=n[0],a=n[1];return i<r?(r=ur(i,r),o=e(a,o)):(r=ur(r,i),o=e(o,a)),function(t){return o(r(t))}}function cr(t,n,e){var r=Math.min(t.length,n.length)-1,i=new Array(r),o=new Array(r),a=-1;for(t[r]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<r;)i[a]=ur(t[a],t[a+1]),o[a]=e(n[a],n[a+1]);return function(n){var e=$e(t,n,1,r)-1;return o[e](i[e](n))}}function fr(t,n){return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())}function dr(t,n){return function(){var t,n,e,r,i,o,a=ar,s=ar,u=Rn,l=sr;function h(){return r=Math.min(a.length,s.length)>2?cr:hr,i=o=null,c}function c(n){return isNaN(n=+n)?e:(i||(i=r(a.map(t),s,u)))(t(l(n)))}return c.invert=function(e){return l(n((o||(o=r(s,a.map(t),Bn)))(e)))},c.domain=function(t){return arguments.length?(a=er.call(t,or),l===sr||(l=lr(a)),h()):a.slice()},c.range=function(t){return arguments.length?(s=rr.call(t),h()):s.slice()},c.rangeRound=function(t){return s=rr.call(t),u=qn,h()},c.clamp=function(t){return arguments.length?(l=t?lr(a):sr,c):l!==sr},c.interpolate=function(t){return arguments.length?(u=t,h()):u},c.unknown=function(t){return arguments.length?(e=t,c):e},function(e,r){return t=e,n=r,h()}}()(t,n)}function pr(t,n){if((e=(t=n?t.toExponential(n-1):t.toExponential()).indexOf("e"))<0)return null;var e,r=t.slice(0,e);return[r.length>1?r[0]+r.slice(2):r,+t.slice(e+1)]}function gr(t){return(t=pr(Math.abs(t)))?t[1]:NaN}var _r,vr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function yr(t){if(!(n=vr.exec(t)))throw new Error("invalid format: "+t);var n;return new mr({fill:n[1],align:n[2],sign:n[3],symbol:n[4],zero:n[5],width:n[6],comma:n[7],precision:n[8]&&n[8].slice(1),trim:n[9],type:n[10]})}function mr(t){this.fill=void 0===t.fill?" ":t.fill+"",this.align=void 0===t.align?">":t.align+"",this.sign=void 0===t.sign?"-":t.sign+"",this.symbol=void 0===t.symbol?"":t.symbol+"",this.zero=!!t.zero,this.width=void 0===t.width?void 0:+t.width,this.comma=!!t.comma,this.precision=void 0===t.precision?void 0:+t.precision,this.trim=!!t.trim,this.type=void 0===t.type?"":t.type+""}function xr(t,n){var e=pr(t,n);if(!e)return t+"";var r=e[0],i=e[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")}yr.prototype=mr.prototype,mr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var wr={"%":function(t,n){return(100*t).toFixed(n)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:function(t){return Math.round(t).toString(10)},e:function(t,n){return t.toExponential(n)},f:function(t,n){return t.toFixed(n)},g:function(t,n){return t.toPrecision(n)},o:function(t){return Math.round(t).toString(8)},p:function(t,n){return xr(100*t,n)},r:xr,s:function(t,n){var e=pr(t,n);if(!e)return t+"";var r=e[0],i=e[1],o=i-(_r=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,a=r.length;return o===a?r:o>a?r+new Array(o-a+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+pr(t,Math.max(0,n+o-1))[0]},X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}};function br(t){return t}var Mr,kr,Ar,Sr=Array.prototype.map,Tr=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function Nr(t){var n,e,r=void 0===t.grouping||void 0===t.thousands?br:(n=Sr.call(t.grouping,Number),e=t.thousands+"",function(t,r){for(var i=t.length,o=[],a=0,s=n[0],u=0;i>0&&s>0&&(u+s+1>r&&(s=Math.max(1,r-u)),o.push(t.substring(i-=s,i+s)),!((u+=s+1)>r));)s=n[a=(a+1)%n.length];return o.reverse().join(e)}),i=void 0===t.currency?"":t.currency[0]+"",o=void 0===t.currency?"":t.currency[1]+"",a=void 0===t.decimal?".":t.decimal+"",s=void 0===t.numerals?br:function(t){return function(n){return n.replace(/[0-9]/g,(function(n){return t[+n]}))}}(Sr.call(t.numerals,String)),u=void 0===t.percent?"%":t.percent+"",l=void 0===t.minus?"-":t.minus+"",h=void 0===t.nan?"NaN":t.nan+"";function c(t){var n=(t=yr(t)).fill,e=t.align,c=t.sign,f=t.symbol,d=t.zero,p=t.width,g=t.comma,_=t.precision,v=t.trim,y=t.type;"n"===y?(g=!0,y="g"):wr[y]||(void 0===_&&(_=12),v=!0,y="g"),(d||"0"===n&&"="===e)&&(d=!0,n="0",e="=");var m="$"===f?i:"#"===f&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",x="$"===f?o:/[%p]/.test(y)?u:"",w=wr[y],b=/[defgprs%]/.test(y);function M(t){var i,o,u,f=m,M=x;if("c"===y)M=w(t)+M,t="";else{var k=(t=+t)<0||1/t<0;if(t=isNaN(t)?h:w(Math.abs(t),_),v&&(t=function(t){t:for(var n,e=t.length,r=1,i=-1;r<e;++r)switch(t[r]){case".":i=n=r;break;case"0":0===i&&(i=r),n=r;break;default:if(!+t[r])break t;i>0&&(i=0)}return i>0?t.slice(0,i)+t.slice(n+1):t}(t)),k&&0==+t&&"+"!==c&&(k=!1),f=(k?"("===c?c:l:"-"===c||"("===c?"":c)+f,M=("s"===y?Tr[8+_r/3]:"")+M+(k&&"("===c?")":""),b)for(i=-1,o=t.length;++i<o;)if(48>(u=t.charCodeAt(i))||u>57){M=(46===u?a+t.slice(i+1):t.slice(i))+M,t=t.slice(0,i);break}}g&&!d&&(t=r(t,1/0));var A=f.length+t.length+M.length,S=A<p?new Array(p-A+1).join(n):"";switch(g&&d&&(t=r(S+t,S.length?p-M.length:1/0),S=""),e){case"<":t=f+t+M+S;break;case"=":t=f+S+t+M;break;case"^":t=S.slice(0,A=S.length>>1)+f+t+M+S.slice(A);break;default:t=S+f+t+M}return s(t)}return _=void 0===_?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,_)):Math.max(0,Math.min(20,_)),M.toString=function(){return t+""},M}return{format:c,formatPrefix:function(t,n){var e=c(((t=yr(t)).type="f",t)),r=3*Math.max(-8,Math.min(8,Math.floor(gr(n)/3))),i=Math.pow(10,-r),o=Tr[8+r/3];return function(t){return e(i*t)+o}}}}function Cr(t,n,e,r){var i,o=function(t,n,e){var r=Math.abs(n-t)/Math.max(0,e),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=Ge?i*=10:o>=Ve?i*=5:o>=Ye&&(i*=2),n<t?-i:i}(t,n,e);switch((r=yr(null==r?",f":r)).type){case"s":var a=Math.max(Math.abs(t),Math.abs(n));return null!=r.precision||isNaN(i=function(t,n){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(gr(n)/3)))-gr(Math.abs(t)))}(o,a))||(r.precision=i),Ar(r,a);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(i=function(t,n){return t=Math.abs(t),n=Math.abs(n)-t,Math.max(0,gr(n)-gr(t))+1}(o,Math.max(Math.abs(t),Math.abs(n))))||(r.precision=i-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(i=function(t){return Math.max(0,-gr(Math.abs(t)))}(o))||(r.precision=i-2*("%"===r.type))}return kr(r)}function Er(t){var n=t.domain;return t.ticks=function(t){var e=n();return function(t,n,e){var r,i,o,a,s=-1;if(e=+e,(t=+t)===(n=+n)&&e>0)return[t];if((r=n<t)&&(i=t,t=n,n=i),0===(a=Ue(t,n,e))||!isFinite(a))return[];if(a>0)for(t=Math.ceil(t/a),n=Math.floor(n/a),o=new Array(i=Math.ceil(n-t+1));++s<i;)o[s]=(t+s)*a;else for(t=Math.floor(t*a),n=Math.ceil(n*a),o=new Array(i=Math.ceil(t-n+1));++s<i;)o[s]=(t-s)/a;return r&&o.reverse(),o}(e[0],e[e.length-1],null==t?10:t)},t.tickFormat=function(t,e){var r=n();return Cr(r[0],r[r.length-1],null==t?10:t,e)},t.nice=function(e){null==e&&(e=10);var r,i=n(),o=0,a=i.length-1,s=i[o],u=i[a];return u<s&&(r=s,s=u,u=r,r=o,o=a,a=r),(r=Ue(s,u,e))>0?r=Ue(s=Math.floor(s/r)*r,u=Math.ceil(u/r)*r,e):r<0&&(r=Ue(s=Math.ceil(s*r)/r,u=Math.floor(u*r)/r,e)),r>0?(i[o]=Math.floor(s/r)*r,i[a]=Math.ceil(u/r)*r,n(i)):r<0&&(i[o]=Math.ceil(s*r)/r,i[a]=Math.floor(u*r)/r,n(i)),t},t}function Hr(){var t=dr(sr,sr);return t.copy=function(){return fr(t,Hr())},Ze.apply(t,arguments),Er(t)}function Lr(){it.stopImmediatePropagation()}function Dr(){it.preventDefault(),it.stopImmediatePropagation()}function Fr(t){var n=t.document.documentElement,e=vt(t).on("dragstart.drag",Dr,!0);"onselectstart"in n?e.on("selectstart.drag",Dr,!0):(n.__noselect=n.style.MozUserSelect,n.style.MozUserSelect="none")}function Pr(t){return function(){return t}}function Br(t,n,e,r,i,o,a,s,u,l){this.target=t,this.type=n,this.subject=e,this.identifier=r,this.active=i,this.x=o,this.y=a,this.dx=s,this.dy=u,this._=l}function Or(){return!it.ctrlKey&&!it.button}function zr(){return this.parentNode}function Ir(t){return null==t?{x:it.x,y:it.y}:t}function jr(){return navigator.maxTouchPoints||"ontouchstart"in this}function Rr(){var t,n,e,r,i=Or,o=zr,a=Ir,s=jr,u={},l=kt("start","drag","end"),h=0,c=0;function f(t){t.on("mousedown.drag",d).filter(s).on("touchstart.drag",_).on("touchmove.drag",v).on("touchend.drag touchcancel.drag",y).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function d(){if(!r&&i.apply(this,arguments)){var a=m("mouse",o.apply(this,arguments),xt,this,arguments);a&&(vt(it.view).on("mousemove.drag",p,!0).on("mouseup.drag",g,!0),Fr(it.view),Lr(),e=!1,t=it.clientX,n=it.clientY,a("start"))}}function p(){if(Dr(),!e){var r=it.clientX-t,i=it.clientY-n;e=r*r+i*i>c}u.mouse("drag")}function g(){vt(it.view).on("mousemove.drag mouseup.drag",null),function(t,n){var e=t.document.documentElement,r=vt(t).on("dragstart.drag",null);n&&(r.on("click.drag",Dr,!0),setTimeout((function(){r.on("click.drag",null)}),0)),"onselectstart"in e?r.on("selectstart.drag",null):(e.style.MozUserSelect=e.__noselect,delete e.__noselect)}(it.view,e),Dr(),u.mouse("end")}function _(){if(i.apply(this,arguments)){var t,n,e=it.changedTouches,r=o.apply(this,arguments),a=e.length;for(t=0;t<a;++t)(n=m(e[t].identifier,r,bt,this,arguments))&&(Lr(),n("start"))}}function v(){var t,n,e=it.changedTouches,r=e.length;for(t=0;t<r;++t)(n=u[e[t].identifier])&&(Dr(),n("drag"))}function y(){var t,n,e=it.changedTouches,i=e.length;for(r&&clearTimeout(r),r=setTimeout((function(){r=null}),500),t=0;t<i;++t)(n=u[e[t].identifier])&&(Lr(),n("end"))}function m(t,n,e,r,i){var o,s,c,d=e(n,t),p=l.copy();if(ht(new Br(f,"beforestart",o,t,h,d[0],d[1],0,0,p),(function(){return null!=(it.subject=o=a.apply(r,i))&&(s=o.x-d[0]||0,c=o.y-d[1]||0,!0)})))return function a(l){var g,_=d;switch(l){case"start":u[t]=a,g=h++;break;case"end":delete u[t],--h;case"drag":d=e(n,t),g=h}ht(new Br(f,l,o,t,g,d[0]+s,d[1]+c,d[0]-_[0],d[1]-_[1],p),p.apply,p,[l,r,i])}}return f.filter=function(t){return arguments.length?(i="function"==typeof t?t:Pr(!!t),f):i},f.container=function(t){return arguments.length?(o="function"==typeof t?t:Pr(t),f):o},f.subject=function(t){return arguments.length?(a="function"==typeof t?t:Pr(t),f):a},f.touchable=function(t){return arguments.length?(s="function"==typeof t?t:Pr(!!t),f):s},f.on=function(){var t=l.on.apply(l,arguments);return t===l?f:t},f.clickDistance=function(t){return arguments.length?(c=(t=+t)*t,f):Math.sqrt(c)},f}Mr=Nr({decimal:".",thousands:",",grouping:[3],currency:["$",""],minus:"-"}),kr=Mr.format,Ar=Mr.formatPrefix,Br.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t};var qr=Array.prototype.slice;function Xr(t){return t}function $r(t){return"translate("+(t+.5)+",0)"}function Gr(t){return"translate(0,"+(t+.5)+")"}function Vr(t){return function(n){return+t(n)}}function Yr(t){var n=Math.max(0,t.bandwidth()-1)/2;return t.round()&&(n=Math.round(n)),function(e){return+t(e)+n}}function Ur(){return!this.__axis}function Wr(t,n){var e=[],r=null,i=null,o=6,a=6,s=3,u=1===t||4===t?-1:1,l=4===t||2===t?"x":"y",h=1===t||3===t?$r:Gr;function c(c){var f=null==r?n.ticks?n.ticks.apply(n,e):n.domain():r,d=null==i?n.tickFormat?n.tickFormat.apply(n,e):Xr:i,p=Math.max(o,0)+s,g=n.range(),_=+g[0]+.5,v=+g[g.length-1]+.5,y=(n.bandwidth?Yr:Vr)(n.copy()),m=c.selection?c.selection():c,x=m.selectAll(".domain").data([null]),w=m.selectAll(".tick").data(f,n).order(),b=w.exit(),M=w.enter().append("g").attr("class","tick"),k=w.select("line"),A=w.select("text");x=x.merge(x.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor")),w=w.merge(M),k=k.merge(M.append("line").attr("stroke","currentColor").attr(l+"2",u*o)),A=A.merge(M.append("text").attr("fill","currentColor").attr(l,u*p).attr("dy",1===t?"0em":3===t?"0.71em":"0.32em")),c!==m&&(x=x.transition(c),w=w.transition(c),k=k.transition(c),A=A.transition(c),b=b.transition(c).attr("opacity",1e-6).attr("transform",(function(t){return isFinite(t=y(t))?h(t):this.getAttribute("transform")})),M.attr("opacity",1e-6).attr("transform",(function(t){var n=this.parentNode.__axis;return h(n&&isFinite(n=n(t))?n:y(t))}))),b.remove(),x.attr("d",4===t||2==t?a?"M"+u*a+","+_+"H0.5V"+v+"H"+u*a:"M0.5,"+_+"V"+v:a?"M"+_+","+u*a+"V0.5H"+v+"V"+u*a:"M"+_+",0.5H"+v),w.attr("opacity",1).attr("transform",(function(t){return h(y(t))})),k.attr(l+"2",u*o),A.attr(l,u*p).text(d),m.filter(Ur).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",2===t?"start":4===t?"end":"middle"),m.each((function(){this.__axis=y}))}return c.scale=function(t){return arguments.length?(n=t,c):n},c.ticks=function(){return e=qr.call(arguments),c},c.tickArguments=function(t){return arguments.length?(e=null==t?[]:qr.call(t),c):e.slice()},c.tickValues=function(t){return arguments.length?(r=null==t?null:qr.call(t),c):r&&r.slice()},c.tickFormat=function(t){return arguments.length?(i=t,c):i},c.tickSize=function(t){return arguments.length?(o=a=+t,c):o},c.tickSizeInner=function(t){return arguments.length?(o=+t,c):o},c.tickSizeOuter=function(t){return arguments.length?(a=+t,c):a},c.tickPadding=function(t){return arguments.length?(s=+t,c):s},c}function Zr(t){return Wr(3,t)}function Kr(t){return Wr(4,t)}var Qr=Math.PI,Jr=2*Qr,ti=Jr-1e-6;function ni(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function ei(){return new ni}function ri(t){return function(){return t}}ni.prototype=ei.prototype={constructor:ni,moveTo:function(t,n){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,n){this._+="L"+(this._x1=+t)+","+(this._y1=+n)},quadraticCurveTo:function(t,n,e,r){this._+="Q"+ +t+","+ +n+","+(this._x1=+e)+","+(this._y1=+r)},bezierCurveTo:function(t,n,e,r,i,o){this._+="C"+ +t+","+ +n+","+ +e+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,n,e,r,i){t=+t,n=+n,e=+e,r=+r,i=+i;var o=this._x1,a=this._y1,s=e-t,u=r-n,l=o-t,h=a-n,c=l*l+h*h;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=n);else if(c>1e-6)if(Math.abs(h*s-u*l)>1e-6&&i){var f=e-o,d=r-a,p=s*s+u*u,g=f*f+d*d,_=Math.sqrt(p),v=Math.sqrt(c),y=i*Math.tan((Qr-Math.acos((p+c-g)/(2*_*v)))/2),m=y/v,x=y/_;Math.abs(m-1)>1e-6&&(this._+="L"+(t+m*l)+","+(n+m*h)),this._+="A"+i+","+i+",0,0,"+ +(h*f>l*d)+","+(this._x1=t+x*s)+","+(this._y1=n+x*u)}else this._+="L"+(this._x1=t)+","+(this._y1=n);else;},arc:function(t,n,e,r,i,o){t=+t,n=+n,o=!!o;var a=(e=+e)*Math.cos(r),s=e*Math.sin(r),u=t+a,l=n+s,h=1^o,c=o?r-i:i-r;if(e<0)throw new Error("negative radius: "+e);null===this._x1?this._+="M"+u+","+l:(Math.abs(this._x1-u)>1e-6||Math.abs(this._y1-l)>1e-6)&&(this._+="L"+u+","+l),e&&(c<0&&(c=c%Jr+Jr),c>ti?this._+="A"+e+","+e+",0,1,"+h+","+(t-a)+","+(n-s)+"A"+e+","+e+",0,1,"+h+","+(this._x1=u)+","+(this._y1=l):c>1e-6&&(this._+="A"+e+","+e+",0,"+ +(c>=Qr)+","+h+","+(this._x1=t+e*Math.cos(i))+","+(this._y1=n+e*Math.sin(i))))},rect:function(t,n,e,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)+"h"+ +e+"v"+ +r+"h"+-e+"Z"},toString:function(){return this._}};var ii=Math.PI,oi=2*ii;function ai(t){this._context=t}function si(t){return new ai(t)}function ui(t){return t[0]}function li(t){return t[1]}function hi(){var t=ui,n=li,e=ri(!0),r=null,i=si,o=null;function a(a){var s,u,l,h=a.length,c=!1;for(null==r&&(o=i(l=ei())),s=0;s<=h;++s)!(s<h&&e(u=a[s],s,a))===c&&((c=!c)?o.lineStart():o.lineEnd()),c&&o.point(+t(u,s,a),+n(u,s,a));if(l)return o=null,l+""||null}return a.x=function(n){return arguments.length?(t="function"==typeof n?n:ri(+n),a):t},a.y=function(t){return arguments.length?(n="function"==typeof t?t:ri(+t),a):n},a.defined=function(t){return arguments.length?(e="function"==typeof t?t:ri(!!t),a):e},a.curve=function(t){return arguments.length?(i=t,null!=r&&(o=i(r)),a):i},a.context=function(t){return arguments.length?(null==t?r=o=null:o=i(r=t),a):r},a}ai.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._context.lineTo(t,n)}}};var ci={draw:function(t,n){var e=Math.sqrt(n/ii);t.moveTo(e,0),t.arc(0,0,e,0,oi)}},fi=Math.sqrt(3),di={draw:function(t,n){var e=-Math.sqrt(n/(3*fi));t.moveTo(0,2*e),t.lineTo(-fi*e,-e),t.lineTo(fi*e,-e),t.closePath()}};function pi(){var t=ri(ci),n=ri(64),e=null;function r(){var r;if(e||(e=r=ei()),t.apply(this,arguments).draw(e,+n.apply(this,arguments)),r)return e=null,r+""||null}return r.type=function(n){return arguments.length?(t="function"==typeof n?n:ri(n),r):t},r.size=function(t){return arguments.length?(n="function"==typeof t?t:ri(+t),r):n},r.context=function(t){return arguments.length?(e=null==t?null:t,r):e},r}function gi(t,n,e){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+n)/6,(t._y0+4*t._y1+e)/6)}function _i(t){this._context=t}function vi(t){return new _i(t)}function yi(t){for(var n=t.length/6|0,e=new Array(n),r=0;r<n;)e[r]="#"+t.slice(6*r,6*++r);return e}_i.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:gi(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:gi(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}};var mi=yi("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),xi=yi("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),wi=yi("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),bi=yi("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),Mi=yi("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),ki=yi("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");!function(n,e){"function"==typeof define&&define.amd?define(["leaflet"],n):"object"===("undefined"==typeof exports?"undefined":t(exports))&&(void 0!==e&&e.L?module.exports=n(L):module.exports=n(require("leaflet"))),void 0!==e&&e.L&&(e.L.Control.Heightgraph=n(L))}((function(t){return t.Control.Heightgraph=t.Control.extend({options:{position:"bottomright",width:800,height:280,margins:{top:10,right:30,bottom:55,left:50},mappings:void 0,expand:!0,expandControls:!0,translation:{},expandCallback:void 0,chooseSelectionCallback:void 0,selectedAttributeIdx:0,xTicks:void 0,yTicks:void 0,highlightStyle:void 0,graphStyle:void 0},_defaultTranslation:{distance:"Distance",elevation:"Elevation",segment_length:"Segment length",type:"Type",legend:"Legend"},_init_options:function(){this._margin=this.options.margins,this._width=this.options.width,this._height=this.options.height,this._mappings=this.options.mappings,this._svgWidth=this._width-this._margin.left-this._margin.right,this._svgHeight=this._height-this._margin.top-this._margin.bottom,this._highlightStyle=this.options.highlightStyle||{color:"red"},this._graphStyle=this.options.graphStyle||{},this._dragCache={}},onAdd:function(n){var e=this._container=t.DomUtil.create("div","heightgraph");if(t.DomEvent.disableClickPropagation(e),this.options.expandControls){var r=this._button=t.DomUtil.create("div","heightgraph-toggle",e);t.DomUtil.create("a","heightgraph-toggle-icon",r),this._closeButton=t.DomUtil.create("a","heightgraph-close-icon",e)}return this._showState=!1,this._initToggle(),this._init_options(),this._svg=vt(this._container).append("svg").attr("class","heightgraph-container").attr("width",this._width).attr("height",this._height).append("g").attr("transform","translate("+this._margin.left+","+this._margin.top+")"),this.options.expand&&this._expand(),e},onRemove:function(t){this._removeMarkedSegmentsOnMap(),this._container=null,this._svg=void 0},addData:function(t){this._addData(t)},_addData:function(t){void 0!==this._svg&&this._svg.selectAll("*").remove(),(!t||this.options.selectedAttributeIdx>=t.length)&&(this.options.selectedAttributeIdx=0),this._removeMarkedSegmentsOnMap(),this._resetDrag(!0),this._data=t,this._init_options(),this._prepareData(),this._calculateElevationBounds(),this._appendScales(),this._appendGrid(),0!==Object.keys(t).length&&this._createChart(this.options.selectedAttributeIdx),this._createSelectionBox()},resize:function(t){t.width&&(this.options.width=t.width),t.height&&(this.options.height=t.height),vt(this._container).selectAll("svg").attr("width",this.options.width).attr("height",this.options.height),this._addData(this._data)},_initToggle:function(){t.Browser.touch?t.DomEvent.on(this._container,"click",t.DomEvent.stopPropagation):t.DomEvent.disableClickPropagation(this._container),this.options.expandControls&&(t.DomEvent.on(this._button,"click",this._expand,this),t.DomEvent.on(this._closeButton,"click",this._expand,this))},_dragHandler:function(){"undefined"!=typeof event&&(event.preventDefault(),event.stopPropagation()),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=this._dragCache.end=xt(this._background.node()),n=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-n).attr("x",n);else{var r=vt(this._container).select("svg").select("g");this._dragRectangleG=r.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-n).attr("height",this._svgHeight).attr("x",n).attr("class","mouse-drag").style("fill","grey").style("opacity",.5).style("pointer-events","none")}}},_resetDrag:function(t){if(this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,!0!==t)){var n=this._calculateFullExtent(this._areasFlattended);n&&this._map.fitBounds(n)}},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();var t=this._findItemForX(this._dragStartCoords[0]),n=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,n),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){event.preventDefault(),event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=this._dragCache.start=xt(this._background.node())},_calculateFullExtent:function(n){if(!n||n.length<1)return null;var e=new t.latLngBounds(n[0].latlng,n[0].latlng);return n.forEach((function(t){e.contains(t.latlng)||e.extend(t.latlng)})),e},_fitSection:function(t,n){var e,r=Math.min(t,n),i=Math.max(t,n);r!==i?e=this._calculateFullExtent(this._areasFlattended.slice(r,i+1)):this._areasFlattended.length>0&&(e=[this._areasFlattended[r].latlng,this._areasFlattended[i].latlng]),e&&this._map.fitBounds(e)},_expand:function(){!0!==this.options.expandControls&&(this._showState=!1),this._showState?(vt(this._button).style("display","block"),vt(this._container).selectAll("svg").style("display","none"),vt(this._closeButton).style("display","none")):(vt(this._button).style("display","none"),vt(this._container).selectAll("svg").style("display","block"),vt(this._closeButton).style("display","block")),this._showState=!this._showState,"function"==typeof this.options.expandCallback&&this.options.expandCallback(this._showState)},_removeChart:function(){void 0!==this._svg&&(this._svg.selectAll("path.area").remove(),this._svg.selectAll("path.border-top").remove(),this._svg.selectAll(".legend").remove(),this._svg.selectAll(".lineSelection").remove(),this._svg.selectAll(".horizontalLine").remove(),this._svg.selectAll(".horizontalLineText").remove())},_randomNumber:function(t){return Math.round(Math.random()*(t-0))},_d3ColorCategorical:[xi,wi,Mi,mi,ki,bi],_prepareData:function(){this._coordinates=[],this._elevations=[],this._cumulatedDistances=[],this._cumulatedDistances.push(0),this._categories=[];var n,e=this._data;if(void 0===this._mappings){var r=this._randomNumber(this._d3ColorCategorical.length-1);n=function t(){var n=Qe(),e=[],r=[],i=ir;function o(t){var o=t+"",a=n.get(o);if(!a){if(i!==ir)return i;n.set(o,a=e.push(t))}return r[(a-1)%r.length]}return o.domain=function(t){if(!arguments.length)return e.slice();e=[],n=Qe();for(var r,i,a=-1,s=t.length;++a<s;)n.has(i=(r=t[a])+"")||n.set(i,e.push(r));return o},o.range=function(t){return arguments.length?(r=rr.call(t),o):r.slice()},o.unknown=function(t){return arguments.length?(i=t,o):i},o.copy=function(){return t(e,r).unknown(i)},Ze.apply(o,arguments),o}(this._d3ColorCategorical[r])}for(var i=0;i<e.length;i++){var o=0;this._categories[i]={info:{id:i,text:e[i].properties.label||e[i].properties.summary},distances:[],attributes:[],geometries:[],legend:{}};var a=void 0,s=0,u={},l=void 0!==this._mappings&&"function"==typeof this._mappings[e[i].properties.summary];for(a=0;a<e[i].features.length;a++){var h=void 0,c=void 0,f=void 0,d=[],p=e[i].features[a].geometry.coordinates.length,g=e[i].features[a].properties.attributeType,_=void 0,v=void 0;if(void 0===this._mappings)g in u?(_=g,v=u[g]):(_=g,v=n(a),u[g]=v);else if(l){var y=this._mappings[e[i].properties.summary](g);_=y.text,v=y.color}else _=this._mappings[e[i].properties.summary][g].text,v=this._mappings[e[i].properties.summary][g].color;var m={type:g,text:_,color:v};this._categories[i].attributes.push(m),g in this._categories[i].legend||(this._categories[i].legend[g]=m);for(var x=0;x<p;x++){c=new t.LatLng(e[i].features[a].geometry.coordinates[x][1],e[i].features[a].geometry.coordinates[x][0]),h=e[i].features[a].geometry.coordinates[x][2],x<p-1?(f=new t.LatLng(e[i].features[a].geometry.coordinates[x+1][1],e[i].features[a].geometry.coordinates[x+1][0]),o+=c.distanceTo(f)/1e3,0===i&&(this._elevations.push(h),this._coordinates.push(c),this._cumulatedDistances.push(o)),s+=1):x===p-1&&a===e[i].features.length-1&&(0===i&&(this._elevations.push(h),this._coordinates.push(f)),s+=1);var w=void 0;w=x===p-1&&a<e[i].features.length-1?this._cumulatedDistances[s]:this._cumulatedDistances[s-1],d.push({altitude:h,position:w,x:c.lng,y:c.lat,latlng:c,type:_,areaIdx:a})}this._categories[i].distances.push(o),this._categories[i].geometries.push(d)}i===e.length-1&&(this._totalDistance=o)}},_calculateElevationBounds:function(){var t=We(this._elevations),n=function(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&r>e&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&r>e&&(r=e);return r}(this._elevations),e=t-n;this._elevationBounds={min:e<10?n-10:n-.1*e,max:e<10?t+10:t+.1*e}},_showMapMarker:function(t,n,e){var r=this._map.latLngToLayerPoint(t),i=r.y-75;if(!this._mouseHeightFocus){var o=vt(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=o.append("svg:line").attr("class","height-focus line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._mouseHeightFocusLabel=o.append("g").attr("class","height-focus label"),this._mouseHeightFocusLabelRect=this._mouseHeightFocusLabel.append("rect").attr("class","bBox"),this._mouseHeightFocusLabelTextElev=this._mouseHeightFocusLabel.append("text").attr("class","tspan"),this._mouseHeightFocusLabelTextType=this._mouseHeightFocusLabel.append("text").attr("class","tspan"),(this._pointG=o.append("g").attr("class","height-focus circle")).append("svg:circle").attr("r",5).attr("cx",0).attr("cy",0).attr("class","height-focus circle-lower")}this._mouseHeightFocusLabel.style("display","block"),this._mouseHeightFocus.attr("x1",r.x).attr("x2",r.x).attr("y1",r.y).attr("y2",i).style("display","block"),this._pointG.attr("transform","translate("+r.x+","+r.y+")").style("display","block"),this._mouseHeightFocusLabelRect.attr("x",r.x+3).attr("y",i).attr("class","bBox"),this._mouseHeightFocusLabelTextElev.attr("x",r.x+5).attr("y",i+12).text(n+" m").attr("class","tspan mouse-height-box-text"),this._mouseHeightFocusLabelTextType.attr("x",r.x+5).attr("y",i+24).text(e).attr("class","tspan mouse-height-box-text");var a=this._dynamicBoxSize("text.tspan")[1],s=""===e?18:30;wt(".bBox").attr("width",a+10).attr("height",s)},_createChart:function(t){var n=0===this._categories.length?[]:this._categories[t].geometries;this._areasFlattended=[].concat.apply([],n);for(var e=0;e<n.length;e++)this._appendAreas(n[e],t,e);this._createFocus(),this._appendBackground(),this._createBorderTopLine(),this._createLegend(),this._createHorizontalLine()},_createFocus:function(){var t=this._elevationBounds.min;this._focus&&(this._focus.remove(),this._focusLineGroup.remove()),this._focus=this._svg.append("g").attr("class","focusbox"),this._focusRect=this._focus.append("rect").attr("x",3).attr("y",-this._y(t)).attr("display","none"),this._focusDistance=this._focus.append("text").attr("x",7).attr("y",15-this._y(t)).attr("id","heightgraph.distance").text(this._getTranslation("distance")+":"),this._focusHeight=this._focus.append("text").attr("x",7).attr("y",30-this._y(t)).attr("id","heightgraph.height").text(this._getTranslation("elevation")+":"),this._focusBlockDistance=this._focus.append("text").attr("x",7).attr("y",45-this._y(t)).attr("id","heightgraph.blockdistance").text(this._getTranslation("segment_length")+":"),this._focusType=this._focus.append("text").attr("x",7).attr("y",60-this._y(t)).attr("id","heightgraph.type").text(this._getTranslation("type")+":"),this._areaTspan=this._focusBlockDistance.append("tspan").attr("class","tspan"),this._typeTspan=this._focusType.append("tspan").attr("class","tspan");var n=this._dynamicBoxSize(".focusbox text")[0];wt(".focusbox rect").attr("height",15*n+7.5).attr("display","block"),this._focusLineGroup=this._svg.append("g").attr("class","focusLine"),this._focusLine=this._focusLineGroup.append("line").attr("y1",0).attr("y2",this._y(this._elevationBounds.min)),this._distTspan=this._focusDistance.append("tspan").attr("class","tspan"),this._altTspan=this._focusHeight.append("tspan").attr("class","tspan")},_createHorizontalLine:function(){var t=this;this._horizontalLine=this._svg.append("line").attr("class","horizontalLine").attr("x1",0).attr("x2",this._width-this._margin.left-this._margin.right).attr("y1",this._y(this._elevationBounds.min)).attr("y2",this._y(this._elevationBounds.min)).style("stroke","black"),this._elevationValueText=this._svg.append("text").attr("class","horizontalLineText").attr("x",this._width-this._margin.left-this._margin.right-20).attr("y",this._y(this._elevationBounds.min)-10).attr("fill","black");var n=[{x:this._width-this._margin.left-this._margin.right+7,y:this._y(this._elevationBounds.min),color:"black",type:di,angle:-90,size:100}];this._svg.selectAll(".horizontal-symbol").data(n).enter().append("path").attr("class","lineSelection").attr("d",pi().type((function(t){return t.type})).size((function(t){return t.size}))).attr("transform",(function(t){return"translate("+t.x+","+t.y+") rotate("+t.angle+")"})).attr("id",(function(t){return t.id})).style("fill",(function(t){return t.color})).call(Rr().on("start",(function(t){vt(this).raise().classed("active",!0),vt(".horizontalLine").raise().classed("active",!0)})).on("drag",(function(n){var e=t._svgHeight,r=xt(t._container)[1]-10;vt(this).attr("transform",(function(t){return"translate("+t.x+","+(r<0?0:r>e?e:r)+") rotate("+t.angle+")"})),vt(".horizontalLine").attr("y1",r<0?0:r>e?e:r).attr("y2",r<0?0:r>e?e:r),t._highlightedCoords=r>=e?[]:t._findCoordsForY(r),vt(".horizontalLineText").attr("y",r<=10?0:r>e?e-10:r-10).text(kr(".0f")(t._y.invert(r<0?0:r>e?e:r))+" m"),t._removeMarkedSegmentsOnMap(),t._markSegmentsOnMap(t._highlightedCoords)})).on("end",(function(n){vt(this).classed("active",!1),vt(".horizontalLine").classed("active",!1),t._removeMarkedSegmentsOnMap(),t._markSegmentsOnMap(t._highlightedCoords)})))},_markSegmentsOnMap:function(n){if(n)if(n.length>1){this._markedSegments=t.featureGroup();var e,i=o(n);try{for(i.s();!(e=i.n()).done;){var a=e.value;t.polyline(a,r(r({},this._highlightStyle),{interactive:!1})).addTo(this._markedSegments)}}catch(t){i.e(t)}finally{i.f()}this._markedSegments.addTo(this._map).bringToFront()}else this._markedSegments=t.polyline(n,this._highlightStyle).addTo(this._map)},_removeMarkedSegmentsOnMap:function(){void 0!==this._markedSegments&&this._map.removeLayer(this._markedSegments)},_appendScales:function(){var t=Boolean(this._totalDistance<=10);this._x=Hr().range([0,this._svgWidth]),this._y=Hr().range([this._svgHeight,0]),this._x.domain([0,this._totalDistance]),this._y.domain([this._elevationBounds.min,this._elevationBounds.max]),this._xAxis=Zr().scale(this._x),!0===t?this._xAxis.tickFormat((function(t){return kr(".2f")(t)+" km"})):this._xAxis.tickFormat((function(t){return kr(".0f")(t)+" km"})),this._xAxis.ticks(this.options.xTicks?Math.pow(2,this.options.xTicks):Math.round(this._svgWidth/75),"s"),this._yAxis=Kr().scale(this._y).tickFormat((function(t){return t+" m"})),this._yAxis.ticks(this.options.yTicks?Math.pow(2,this.options.yTicks):Math.round(this._svgHeight/30),"s")},_appendBackground:function(){var n=this._background=vt(this._container).select("svg").select("g").append("rect").attr("width",this._svgWidth).attr("height",this._svgHeight).style("fill","none").style("stroke","none").style("pointer-events","all").on("mousemove.focusbox",this._mousemoveHandler.bind(this)).on("mouseout.focusbox",this._mouseoutHandler.bind(this));t.Browser.android?(n.on("touchstart.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focusbox",this._mousemoveHandler.bind(this)),t.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(n.on("mousemove.focusbox",this._mousemoveHandler.bind(this)).on("mouseout.focusbox",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),t.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this))},_appendGrid:function(){this._svg.append("g").attr("class","grid").attr("transform","translate(0,"+this._svgHeight+")").call(this._make_x_axis().tickSize(-this._svgHeight,0,0).ticks(Math.round(this._svgWidth/75)).tickFormat("")),this._svg.append("g").attr("class","grid").call(this._make_y_axis().tickSize(-this._svgWidth,0,0).ticks(Math.round(this._svgHeight/30)).tickFormat("")),this._svg.append("g").attr("transform","translate(0,"+this._svgHeight+")").attr("class","x axis").call(this._xAxis),this._svg.append("g").attr("transform","translate(-2,0)").attr("class","y axis").call(this._yAxis)},_appendAreas:function(t,n,e){var r=this._categories[n].attributes[e].color,i=this;this._area=function(){var t=ui,n=null,e=ri(0),r=li,i=ri(!0),o=null,a=si,s=null;function u(u){var l,h,c,f,d,p=u.length,g=!1,_=new Array(p),v=new Array(p);for(null==o&&(s=a(d=ei())),l=0;l<=p;++l){if(!(l<p&&i(f=u[l],l,u))===g)if(g=!g)h=l,s.areaStart(),s.lineStart();else{for(s.lineEnd(),s.lineStart(),c=l-1;c>=h;--c)s.point(_[c],v[c]);s.lineEnd(),s.areaEnd()}g&&(_[l]=+t(f,l,u),v[l]=+e(f,l,u),s.point(n?+n(f,l,u):_[l],r?+r(f,l,u):v[l]))}if(d)return s=null,d+""||null}function l(){return hi().defined(i).curve(a).context(o)}return u.x=function(e){return arguments.length?(t="function"==typeof e?e:ri(+e),n=null,u):t},u.x0=function(n){return arguments.length?(t="function"==typeof n?n:ri(+n),u):t},u.x1=function(t){return arguments.length?(n=null==t?null:"function"==typeof t?t:ri(+t),u):n},u.y=function(t){return arguments.length?(e="function"==typeof t?t:ri(+t),r=null,u):e},u.y0=function(t){return arguments.length?(e="function"==typeof t?t:ri(+t),u):e},u.y1=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:ri(+t),u):r},u.lineX0=u.lineY0=function(){return l().x(t).y(e)},u.lineY1=function(){return l().x(t).y(r)},u.lineX1=function(){return l().x(n).y(e)},u.defined=function(t){return arguments.length?(i="function"==typeof t?t:ri(!!t),u):i},u.curve=function(t){return arguments.length?(a=t,null!=o&&(s=a(o)),u):a},u.context=function(t){return arguments.length?(null==t?o=s=null:s=a(o=t),u):o},u}().x((function(t){var n=i._x(t.position);return t.xDiagonalCoordinate=n,n})).y0(this._svgHeight).y1((function(t){return i._y(t.altitude)})).curve(si);this._areapath=this._svg.append("path").attr("class","area"),this._areapath.datum(t).attr("d",this._area).attr("stroke",r).styles(this._graphStyle).style("fill",r).style("pointer-events","none")},_make_x_axis:function(){return Zr().scale(this._x)},_make_y_axis:function(){return Kr().scale(this._y)},_createSelectionBox:function(){var t=this,n=vt(this._container).select("svg"),e=this._width-this._margin.right,r=this._height-this._margin.bottom+this._margin.bottom/2+6,i=[{x:e-25,y:r+3,color:"#000",type:di,id:"leftArrowSelection",angle:0},{x:e-10,y:r,color:"#000",type:di,id:"rightArrowSelection",angle:180}],o=n.selectAll(".select-symbol").data(i);o.remove(),o=n.selectAll(".select-symbol").data(i),t._data.length>1&&o.enter().append("path").merge(o).attr("class","select-symbol").attr("d",pi().type((function(t){return t.type}))).attr("transform",(function(t){return"translate("+t.x+","+t.y+") rotate("+t.angle+")"})).attr("id",(function(t){return t.id})).style("fill",(function(t){return t.color})).on("mousedown",(function(n){"rightArrowSelection"===n.id&&s(),"leftArrowSelection"===n.id&&u(),t._gotDragged=!0,t._dragStartCoords=t._dragCache.start,t._dragCurrentCoords=t._dragCache.end}));var a=function(i){if(t._selectionText&&t._selectionText.remove(),0!==t._categories.length){var o=t._categories[i].info;"function"==typeof t.options.chooseSelectionCallback&&t.options.chooseSelectionCallback(i,o);var a=[{selection:o.text}];t._selectionText=n.selectAll("selection_text").data(a).enter().append("text").attr("x",e-35).attr("y",r+4).text((function(t){return t.selection})).attr("class","select-info").attr("id","selectionText").attr("text-anchor","end")}};a(this.options.selectedAttributeIdx);var s=function(){var n=t.options.selectedAttributeIdx+=1;n===t._categories.length&&(t.options.selectedAttributeIdx=n=0),a(n),t._removeChart(),t._removeMarkedSegmentsOnMap(),t._createChart(n)},u=function(){var n=t.options.selectedAttributeIdx-=1;-1===n&&(t.options.selectedAttributeIdx=n=t._categories.length-1),a(n),t._removeChart(),t._removeMarkedSegmentsOnMap(),t._createChart(n)}},_createLegend:function(){var t=this,n=this,e=[];if(this._categories.length>0)for(var r in this._categories[this.options.selectedAttributeIdx].legend)e.push(this._categories[this.options.selectedAttributeIdx].legend[r]);var i=this._height-this._margin.bottom,o=i+this._margin.bottom/2,a=[{text:this._getTranslation("legend")}],s=this._svg.selectAll(".hlegend-hover").data(e).enter().append("g").attr("class","legend").style("display","none").attr("transform",(function(t,n){return"translate(-8,"+(14*n-28)+")"})),u=s.append("rect").attr("class","legend-rect").attr("x",15).attr("y",36).attr("width",6).attr("height",6);0!==Object.keys(this._graphStyle).length?u.styles(this._graphStyle).style("stroke",(function(t,n){return t.color})).style("fill",(function(t,n){return t.color})):u.style("stroke","black").style("fill",(function(t,n){return t.color})),s.append("text").attr("class","legend-text").attr("x",30).attr("y",42).text((function(t,e){var r=t.text;return n._boxBoundY=(i-2*i/3+7)*e,r}));var l=this._svg.selectAll(".legend-hover").data(a).enter().append("g").attr("class","legend-hover");this._showLegend=!1,l.append("text").attr("x",15).attr("y",o).attr("text-anchor","start").text((function(t,n){return t.text})).on("mouseover",(function(){wt(".legend").style("display","block")})).on("mouseleave",(function(){t._showLegend||wt(".legend").style("display","none")})).on("click",(function(){t._showLegend=!t._showLegend}))},_dynamicBoxSize:function(t){for(var n=wt(t).nodes().length,e=[],r=0;r<n;r++)e.push(wt(t).nodes()[r].getBoundingClientRect().width);return[n,We(e)]},_createBorderTopLine:function(){var t=this,n=this._areasFlattended,e=hi().x((function(n){return(0,t._x)(n.position)})).y((function(n){return(0,t._y)(n.altitude)})).curve(vi);this._svg.append("svg:path").attr("d",e(n)).attr("class","border-top")},_mouseoutHandler:function(){for(var t=0,n=["_focusLine","_focus","_pointG","_mouseHeightFocus","_mouseHeightFocusLabel"];t<n.length;t++){var e=n[t];this[e]&&this[e].style("display","none")}},mapMouseoutHandler:function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;this.mouseoutDelay&&window.clearTimeout(this.mouseoutDelay),this.mouseoutDelay=window.setTimeout((function(){t._mouseoutHandler()}),n)},mapMousemoveHandler:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},e=n.showMapMarker,r=void 0===e||e;if(!1!==this._areasFlattended){var i,a=null,s=2*Math.pow(100,2),u=1.1/111111,l=o(this._areasFlattended);try{for(l.s();!(i=l.n()).done;){var h=i.value,c=t.latlng.lat-h.latlng.lat,f=t.latlng.lng-h.latlng.lng;if(Math.abs(c)<u&&Math.abs(f)<u){this._internalMousemoveHandler(h,r);break}var d=Math.pow(c,2)+Math.pow(f,2);d<s&&(a=h,s=d)}}catch(t){l.e(t)}finally{l.f()}a&&this._internalMousemoveHandler(a,r)}},_mousemoveHandler:function(t,n,e){var r=xt(this._svg.node()),i=this._areasFlattended[this._findItemForX(r[0])];i&&this._internalMousemoveHandler(i)},_internalMousemoveHandler:function(t){var n,e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t.altitude,i=t.position,o=t.latlng,a=t.areaIdx,s=t.type,u=this._dynamicBoxSize(".focusbox text")[1]+10;n=0===a?this._categories[this.options.selectedAttributeIdx].distances[a]:this._categories[this.options.selectedAttributeIdx].distances[a]-this._categories[this.options.selectedAttributeIdx].distances[a-1],e&&this._showMapMarker(o,r,s),this._distTspan.text(" "+i.toFixed(1)+" km"),this._altTspan.text(" "+r+" m"),this._areaTspan.text(" "+n.toFixed(1)+" km"),this._typeTspan.text(" "+s),this._focusRect.attr("width",u),this._focusLine.style("display","block").attr("x1",this._x(i)).attr("x2",this._x(i));var l=this._x(i)-(u+5),h=this._width-this._margin.left-this._margin.right;this._x(i)+u<h&&this._focus.style("display","initial").attr("transform","translate("+this._x(i)+","+this._y(this._elevationBounds.min)+")"),this._x(i)+u>h&&this._focus.style("display","initial").attr("transform","translate("+l+","+this._y(this._elevationBounds.min)+")")},_findItemForX:function(t){var n=Xe((function(t){return t.position})).left,e=this._x.invert(t);return n(this._areasFlattended,e)},_findCoordsForY:function(t){var n=this._y.invert(t);return function(t,n){for(var e=[],r=0;r<t.length;r++)t[r].altitude>=n&&e.push(r);for(var i=[],o=0,a=0;a<e.length-1;a++)e[a+1]!==e[a]+1&&(i.push(e.slice(o,a+1)),o=a+1);i.push(e.slice(o,e.length));for(var s=0;s<i.length;s++)for(var u=0;u<i[s].length;u++)i[s][u]=t[i[s][u]].latlng;return i}(this._areasFlattended,n)},_getTranslation:function(t){return this.options.translation[t]?this.options.translation[t]:this._defaultTranslation[t]?this._defaultTranslation[t]:(console.error("Unexpected error when looking up the translation for "+t),"No translation found")}}),t.control.heightgraph=function(n){return new t.Control.Heightgraph(n)},t.Control.Heightgraph}),window)}();
+!function(){"use strict";function t(n){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(n)}function n(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function e(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function r(t){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?e(Object(i),!0).forEach((function(e){n(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(i,n))}))}return t}function i(t,n){(null==n||n>t.length)&&(n=t.length);for(var e=0,r=new Array(n);e<n;e++)r[e]=t[e];return r}function o(t,n){var e;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(e=function(t,n){if(t){if("string"==typeof t)return i(t,n);var e=Object.prototype.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(t,n):void 0}}(t))||n&&t&&"number"==typeof t.length){e&&(t=e);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,s=!0,u=!1;return{s:function(){e=t[Symbol.iterator]()},n:function(){var t=e.next();return s=t.done,t},e:function(t){u=!0,a=t},f:function(){try{s||null==e.return||e.return()}finally{if(u)throw a}}}}var a="http://www.w3.org/1999/xhtml",s={svg:"http://www.w3.org/2000/svg",xhtml:a,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};function u(t){var n=t+="",e=n.indexOf(":");return e>=0&&"xmlns"!==(n=t.slice(0,e))&&(t=t.slice(e+1)),s.hasOwnProperty(n)?{space:s[n],local:t}:t}function l(t){return function(){var n=this.ownerDocument,e=this.namespaceURI;return e===a&&n.documentElement.namespaceURI===a?n.createElement(t):n.createElementNS(e,t)}}function h(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}function c(t){var n=u(t);return(n.local?h:l)(n)}function f(){}function d(t){return null==t?f:function(){return this.querySelector(t)}}function p(){return[]}function g(t){return null==t?p:function(){return this.querySelectorAll(t)}}function _(t){return function(){return this.matches(t)}}function v(t){return new Array(t.length)}function y(t,n){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=n}y.prototype={constructor:y,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,n){return this._parent.insertBefore(t,n)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}};function m(t,n,e,r,i,o){for(var a,s=0,u=n.length,l=o.length;s<l;++s)(a=n[s])?(a.__data__=o[s],r[s]=a):e[s]=new y(t,o[s]);for(;s<u;++s)(a=n[s])&&(i[s]=a)}function x(t,n,e,r,i,o,a){var s,u,l,h={},c=n.length,f=o.length,d=new Array(c);for(s=0;s<c;++s)(u=n[s])&&(d[s]=l="$"+a.call(u,u.__data__,s,n),l in h?i[s]=u:h[l]=u);for(s=0;s<f;++s)(u=h[l="$"+a.call(t,o[s],s,o)])?(r[s]=u,u.__data__=o[s],h[l]=null):e[s]=new y(t,o[s]);for(s=0;s<c;++s)(u=n[s])&&h[d[s]]===u&&(i[s]=u)}function w(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function b(t){return function(){this.removeAttribute(t)}}function M(t){return function(){this.removeAttributeNS(t.space,t.local)}}function k(t,n){return function(){this.setAttribute(t,n)}}function A(t,n){return function(){this.setAttributeNS(t.space,t.local,n)}}function S(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}}function T(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}}function N(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView}function C(t){return function(){this.style.removeProperty(t)}}function E(t,n,e){return function(){this.style.setProperty(t,n,e)}}function H(t,n,e){return function(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}}function D(t,n){return t.style.getPropertyValue(n)||N(t).getComputedStyle(t,null).getPropertyValue(n)}function F(t){return function(){delete this[t]}}function P(t,n){return function(){this[t]=n}}function B(t,n){return function(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}}function O(t){return t.trim().split(/^|\s+/)}function z(t){return t.classList||new I(t)}function I(t){this._node=t,this._names=O(t.getAttribute("class")||"")}function j(t,n){for(var e=z(t),r=-1,i=n.length;++r<i;)e.add(n[r])}function R(t,n){for(var e=z(t),r=-1,i=n.length;++r<i;)e.remove(n[r])}function q(t){return function(){j(this,t)}}function X(t){return function(){R(this,t)}}function $(t,n){return function(){(n.apply(this,arguments)?j:R)(this,t)}}function G(){this.textContent=""}function V(t){return function(){this.textContent=t}}function Y(t){return function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}}function U(){this.innerHTML=""}function W(t){return function(){this.innerHTML=t}}function Z(t){return function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}}function K(){this.nextSibling&&this.parentNode.appendChild(this)}function Q(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function J(){return null}function tt(){var t=this.parentNode;t&&t.removeChild(this)}function nt(){var t=this.cloneNode(!1),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}function et(){var t=this.cloneNode(!0),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}I.prototype={add:function(t){this._names.indexOf(t)<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var n=this._names.indexOf(t);n>=0&&(this._names.splice(n,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};var rt={},it=null;"undefined"!=typeof document&&("onmouseenter"in document.documentElement||(rt={mouseenter:"mouseover",mouseleave:"mouseout"}));function ot(t,n,e){return t=at(t,n,e),function(n){var e=n.relatedTarget;e&&(e===this||8&e.compareDocumentPosition(this))||t.call(this,n)}}function at(t,n,e){return function(r){var i=it;it=r;try{t.call(this,this.__data__,n,e)}finally{it=i}}}function st(t){return t.trim().split(/^|\s+/).map((function(t){var n="",e=t.indexOf(".");return e>=0&&(n=t.slice(e+1),t=t.slice(0,e)),{type:t,name:n}}))}function ut(t){return function(){var n=this.__on;if(n){for(var e,r=0,i=-1,o=n.length;r<o;++r)e=n[r],t.type&&e.type!==t.type||e.name!==t.name?n[++i]=e:this.removeEventListener(e.type,e.listener,e.capture);++i?n.length=i:delete this.__on}}}function lt(t,n,e){var r=rt.hasOwnProperty(t.type)?ot:at;return function(i,o,a){var s,u=this.__on,l=r(n,o,a);if(u)for(var h=0,c=u.length;h<c;++h)if((s=u[h]).type===t.type&&s.name===t.name)return this.removeEventListener(s.type,s.listener,s.capture),this.addEventListener(s.type,s.listener=l,s.capture=e),void(s.value=n);this.addEventListener(t.type,l,e),s={type:t.type,name:t.name,value:n,listener:l,capture:e},u?u.push(s):this.__on=[s]}}function ht(t,n,e,r){var i=it;t.sourceEvent=it,it=t;try{return n.apply(e,r)}finally{it=i}}function ct(t,n,e){var r=N(t),i=r.CustomEvent;"function"==typeof i?i=new i(n,e):(i=r.document.createEvent("Event"),e?(i.initEvent(n,e.bubbles,e.cancelable),i.detail=e.detail):i.initEvent(n,!1,!1)),t.dispatchEvent(i)}function ft(t,n){return function(){return ct(this,t,n)}}function dt(t,n){return function(){return ct(this,t,n.apply(this,arguments))}}var pt=[null];function gt(t,n){this._groups=t,this._parents=n}function _t(){return new gt([[document.documentElement]],pt)}function vt(t){return"string"==typeof t?new gt([[document.querySelector(t)]],[document.documentElement]):new gt([[t]],pt)}function yt(){for(var t,n=it;t=n.sourceEvent;)n=t;return n}function mt(t,n){var e=t.ownerSVGElement||t;if(e.createSVGPoint){var r=e.createSVGPoint();return r.x=n.clientX,r.y=n.clientY,[(r=r.matrixTransform(t.getScreenCTM().inverse())).x,r.y]}var i=t.getBoundingClientRect();return[n.clientX-i.left-t.clientLeft,n.clientY-i.top-t.clientTop]}function xt(t){var n=yt();return n.changedTouches&&(n=n.changedTouches[0]),mt(t,n)}function wt(t){return"string"==typeof t?new gt([document.querySelectorAll(t)],[document.documentElement]):new gt([null==t?[]:t],pt)}function bt(t,n,e){arguments.length<3&&(e=n,n=yt().changedTouches);for(var r,i=0,o=n?n.length:0;i<o;++i)if((r=n[i]).identifier===e)return mt(t,r);return null}gt.prototype=_t.prototype={constructor:gt,select:function(t){"function"!=typeof t&&(t=d(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a,s=n[i],u=s.length,l=r[i]=new Array(u),h=0;h<u;++h)(o=s[h])&&(a=t.call(o,o.__data__,h,s))&&("__data__"in o&&(a.__data__=o.__data__),l[h]=a);return new gt(r,this._parents)},selectAll:function(t){"function"!=typeof t&&(t=g(t));for(var n=this._groups,e=n.length,r=[],i=[],o=0;o<e;++o)for(var a,s=n[o],u=s.length,l=0;l<u;++l)(a=s[l])&&(r.push(t.call(a,a.__data__,l,s)),i.push(a));return new gt(r,i)},filter:function(t){"function"!=typeof t&&(t=_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],s=a.length,u=r[i]=[],l=0;l<s;++l)(o=a[l])&&t.call(o,o.__data__,l,a)&&u.push(o);return new gt(r,this._parents)},data:function(t,n){if(!t)return d=new Array(this.size()),l=-1,this.each((function(t){d[++l]=t})),d;var e=n?x:m,r=this._parents,i=this._groups;"function"!=typeof t&&(t=function(t){return function(){return t}}(t));for(var o=i.length,a=new Array(o),s=new Array(o),u=new Array(o),l=0;l<o;++l){var h=r[l],c=i[l],f=c.length,d=t.call(h,h&&h.__data__,l,r),p=d.length,g=s[l]=new Array(p),_=a[l]=new Array(p);e(h,c,g,_,u[l]=new Array(f),d,n);for(var v,y,w=0,b=0;w<p;++w)if(v=g[w]){for(w>=b&&(b=w+1);!(y=_[b])&&++b<p;);v._next=y||null}}return(a=new gt(a,r))._enter=s,a._exit=u,a},enter:function(){return new gt(this._enter||this._groups.map(v),this._parents)},exit:function(){return new gt(this._exit||this._groups.map(v),this._parents)},join:function(t,n,e){var r=this.enter(),i=this,o=this.exit();return r="function"==typeof t?t(r):r.append(t+""),null!=n&&(i=n(i)),null==e?o.remove():e(o),r&&i?r.merge(i).order():i},merge:function(t){for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,l=n[s],h=e[s],c=l.length,f=a[s]=new Array(c),d=0;d<c;++d)(u=l[d]||h[d])&&(f[d]=u);for(;s<r;++s)a[s]=n[s];return new gt(a,this._parents)},order:function(){for(var t=this._groups,n=-1,e=t.length;++n<e;)for(var r,i=t[n],o=i.length-1,a=i[o];--o>=0;)(r=i[o])&&(a&&4^r.compareDocumentPosition(a)&&a.parentNode.insertBefore(r,a),a=r);return this},sort:function(t){function n(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}t||(t=w);for(var e=this._groups,r=e.length,i=new Array(r),o=0;o<r;++o){for(var a,s=e[o],u=s.length,l=i[o]=new Array(u),h=0;h<u;++h)(a=s[h])&&(l[h]=a);l.sort(n)}return new gt(i,this._parents).order()},call:function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},nodes:function(){var t=new Array(this.size()),n=-1;return this.each((function(){t[++n]=this})),t},node:function(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r=t[n],i=0,o=r.length;i<o;++i){var a=r[i];if(a)return a}return null},size:function(){var t=0;return this.each((function(){++t})),t},empty:function(){return!this.node()},each:function(t){for(var n=this._groups,e=0,r=n.length;e<r;++e)for(var i,o=n[e],a=0,s=o.length;a<s;++a)(i=o[a])&&t.call(i,i.__data__,a,o);return this},attr:function(t,n){var e=u(t);if(arguments.length<2){var r=this.node();return e.local?r.getAttributeNS(e.space,e.local):r.getAttribute(e)}return this.each((null==n?e.local?M:b:"function"==typeof n?e.local?T:S:e.local?A:k)(e,n))},style:function(t,n,e){return arguments.length>1?this.each((null==n?C:"function"==typeof n?H:E)(t,n,null==e?"":e)):D(this.node(),t)},property:function(t,n){return arguments.length>1?this.each((null==n?F:"function"==typeof n?B:P)(t,n)):this.node()[t]},classed:function(t,n){var e=O(t+"");if(arguments.length<2){for(var r=z(this.node()),i=-1,o=e.length;++i<o;)if(!r.contains(e[i]))return!1;return!0}return this.each(("function"==typeof n?$:n?q:X)(e,n))},text:function(t){return arguments.length?this.each(null==t?G:("function"==typeof t?Y:V)(t)):this.node().textContent},html:function(t){return arguments.length?this.each(null==t?U:("function"==typeof t?Z:W)(t)):this.node().innerHTML},raise:function(){return this.each(K)},lower:function(){return this.each(Q)},append:function(t){var n="function"==typeof t?t:c(t);return this.select((function(){return this.appendChild(n.apply(this,arguments))}))},insert:function(t,n){var e="function"==typeof t?t:c(t),r=null==n?J:"function"==typeof n?n:d(n);return this.select((function(){return this.insertBefore(e.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(tt)},clone:function(t){return this.select(t?et:nt)},datum:function(t){return arguments.length?this.property("__data__",t):this.node().__data__},on:function(t,n,e){var r,i,o=st(t+""),a=o.length;if(!(arguments.length<2)){for(s=n?lt:ut,null==e&&(e=!1),r=0;r<a;++r)this.each(s(o[r],n,e));return this}var s=this.node().__on;if(s)for(var u,l=0,h=s.length;l<h;++l)for(r=0,u=s[l];r<a;++r)if((i=o[r]).type===u.type&&i.name===u.name)return u.value},dispatch:function(t,n){return this.each(("function"==typeof n?dt:ft)(t,n))}};var Mt={value:function(){}};function kt(){for(var t,n=0,e=arguments.length,r={};n<e;++n){if(!(t=arguments[n]+"")||t in r||/[\s.]/.test(t))throw new Error("illegal type: "+t);r[t]=[]}return new At(r)}function At(t){this._=t}function St(t,n){return t.trim().split(/^|\s+/).map((function(t){var e="",r=t.indexOf(".");if(r>=0&&(e=t.slice(r+1),t=t.slice(0,r)),t&&!n.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:e}}))}function Tt(t,n){for(var e,r=0,i=t.length;r<i;++r)if((e=t[r]).name===n)return e.value}function Nt(t,n,e){for(var r=0,i=t.length;r<i;++r)if(t[r].name===n){t[r]=Mt,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=e&&t.push({name:n,value:e}),t}At.prototype=kt.prototype={constructor:At,on:function(t,n){var e,r=this._,i=St(t+"",r),o=-1,a=i.length;if(!(arguments.length<2)){if(null!=n&&"function"!=typeof n)throw new Error("invalid callback: "+n);for(;++o<a;)if(e=(t=i[o]).type)r[e]=Nt(r[e],t.name,n);else if(null==n)for(e in r)r[e]=Nt(r[e],t.name,null);return this}for(;++o<a;)if((e=(t=i[o]).type)&&(e=Tt(r[e],t.name)))return e},copy:function(){var t={},n=this._;for(var e in n)t[e]=n[e].slice();return new At(t)},call:function(t,n){if((e=arguments.length-2)>0)for(var e,r,i=new Array(e),o=0;o<e;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(o=0,e=(r=this._[t]).length;o<e;++o)r[o].value.apply(n,i)},apply:function(t,n,e){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(n,e)}};var Ct,Et,Ht=0,Lt=0,Dt=0,Ft=0,Pt=0,Bt=0,Ot="object"==typeof performance&&performance.now?performance:Date,zt="object"==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(t){setTimeout(t,17)};function It(){return Pt||(zt(jt),Pt=Ot.now()+Bt)}function jt(){Pt=0}function Rt(){this._call=this._time=this._next=null}function qt(t,n,e){var r=new Rt;return r.restart(t,n,e),r}function Xt(){Pt=(Ft=Ot.now())+Bt,Ht=Lt=0;try{!function(){It(),++Ht;for(var t,n=Ct;n;)(t=Pt-n._time)>=0&&n._call.call(null,t),n=n._next;--Ht}()}finally{Ht=0,function(){var t,n,e=Ct,r=1/0;for(;e;)e._call?(r>e._time&&(r=e._time),t=e,e=e._next):(n=e._next,e._next=null,e=t?t._next=n:Ct=n);Et=t,Gt(r)}(),Pt=0}}function $t(){var t=Ot.now(),n=t-Ft;n>1e3&&(Bt-=n,Ft=t)}function Gt(t){Ht||(Lt&&(Lt=clearTimeout(Lt)),t-Pt>24?(t<1/0&&(Lt=setTimeout(Xt,t-Ot.now()-Bt)),Dt&&(Dt=clearInterval(Dt))):(Dt||(Ft=Ot.now(),Dt=setInterval($t,1e3)),Ht=1,zt(Xt)))}function Vt(t,n,e){var r=new Rt;return n=null==n?0:+n,r.restart((function(e){r.stop(),t(e+n)}),n,e),r}Rt.prototype=qt.prototype={constructor:Rt,restart:function(t,n,e){if("function"!=typeof t)throw new TypeError("callback is not a function");e=(null==e?It():+e)+(null==n?0:+n),this._next||Et===this||(Et?Et._next=this:Ct=this,Et=this),this._call=t,this._time=e,Gt()},stop:function(){this._call&&(this._call=null,this._time=1/0,Gt())}};var Yt=kt("start","end","cancel","interrupt"),Ut=[];function Wt(t,n,e,r,i,o){var a=t.__transition;if(a){if(e in a)return}else t.__transition={};!function(t,n,e){var r,i=t.__transition;function o(u){var l,h,c,f;if(1!==e.state)return s();for(l in i)if((f=i[l]).name===e.name){if(3===f.state)return Vt(o);4===f.state?(f.state=6,f.timer.stop(),f.on.call("interrupt",t,t.__data__,f.index,f.group),delete i[l]):+l<n&&(f.state=6,f.timer.stop(),f.on.call("cancel",t,t.__data__,f.index,f.group),delete i[l])}if(Vt((function(){3===e.state&&(e.state=4,e.timer.restart(a,e.delay,e.time),a(u))})),e.state=2,e.on.call("start",t,t.__data__,e.index,e.group),2===e.state){for(e.state=3,r=new Array(c=e.tween.length),l=0,h=-1;l<c;++l)(f=e.tween[l].value.call(t,t.__data__,e.index,e.group))&&(r[++h]=f);r.length=h+1}}function a(n){for(var i=n<e.duration?e.ease.call(null,n/e.duration):(e.timer.restart(s),e.state=5,1),o=-1,a=r.length;++o<a;)r[o].call(t,i);5===e.state&&(e.on.call("end",t,t.__data__,e.index,e.group),s())}function s(){for(var r in e.state=6,e.timer.stop(),delete i[n],i)return;delete t.__transition}i[n]=e,e.timer=qt((function(t){e.state=1,e.timer.restart(o,e.delay,e.time),e.delay<=t&&o(t-e.delay)}),0,e.time)}(t,e,{name:n,index:r,group:i,on:Yt,tween:Ut,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:0})}function Zt(t,n){var e=Qt(t,n);if(e.state>0)throw new Error("too late; already scheduled");return e}function Kt(t,n){var e=Qt(t,n);if(e.state>3)throw new Error("too late; already running");return e}function Qt(t,n){var e=t.__transition;if(!e||!(e=e[n]))throw new Error("transition not found");return e}function Jt(t,n,e){t.prototype=n.prototype=e,e.constructor=t}function tn(t,n){var e=Object.create(t.prototype);for(var r in n)e[r]=n[r];return e}function nn(){}var en="\\s*([+-]?\\d+)\\s*",rn="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",on="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",an=/^#([0-9a-f]{3,8})$/,sn=new RegExp("^rgb\\("+[en,en,en]+"\\)$"),un=new RegExp("^rgb\\("+[on,on,on]+"\\)$"),ln=new RegExp("^rgba\\("+[en,en,en,rn]+"\\)$"),hn=new RegExp("^rgba\\("+[on,on,on,rn]+"\\)$"),cn=new RegExp("^hsl\\("+[rn,on,on]+"\\)$"),fn=new RegExp("^hsla\\("+[rn,on,on,rn]+"\\)$"),dn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function pn(){return this.rgb().formatHex()}function gn(){return this.rgb().formatRgb()}function _n(t){var n,e;return t=(t+"").trim().toLowerCase(),(n=an.exec(t))?(e=n[1].length,n=parseInt(n[1],16),6===e?vn(n):3===e?new wn(n>>8&15|n>>4&240,n>>4&15|240&n,(15&n)<<4|15&n,1):8===e?yn(n>>24&255,n>>16&255,n>>8&255,(255&n)/255):4===e?yn(n>>12&15|n>>8&240,n>>8&15|n>>4&240,n>>4&15|240&n,((15&n)<<4|15&n)/255):null):(n=sn.exec(t))?new wn(n[1],n[2],n[3],1):(n=un.exec(t))?new wn(255*n[1]/100,255*n[2]/100,255*n[3]/100,1):(n=ln.exec(t))?yn(n[1],n[2],n[3],n[4]):(n=hn.exec(t))?yn(255*n[1]/100,255*n[2]/100,255*n[3]/100,n[4]):(n=cn.exec(t))?An(n[1],n[2]/100,n[3]/100,1):(n=fn.exec(t))?An(n[1],n[2]/100,n[3]/100,n[4]):dn.hasOwnProperty(t)?vn(dn[t]):"transparent"===t?new wn(NaN,NaN,NaN,0):null}function vn(t){return new wn(t>>16&255,t>>8&255,255&t,1)}function yn(t,n,e,r){return r<=0&&(t=n=e=NaN),new wn(t,n,e,r)}function mn(t){return t instanceof nn||(t=_n(t)),t?new wn((t=t.rgb()).r,t.g,t.b,t.opacity):new wn}function xn(t,n,e,r){return 1===arguments.length?mn(t):new wn(t,n,e,null==r?1:r)}function wn(t,n,e,r){this.r=+t,this.g=+n,this.b=+e,this.opacity=+r}function bn(){return"#"+kn(this.r)+kn(this.g)+kn(this.b)}function Mn(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}function kn(t){return((t=Math.max(0,Math.min(255,Math.round(t)||0)))<16?"0":"")+t.toString(16)}function An(t,n,e,r){return r<=0?t=n=e=NaN:e<=0||e>=1?t=n=NaN:n<=0&&(t=NaN),new Tn(t,n,e,r)}function Sn(t){if(t instanceof Tn)return new Tn(t.h,t.s,t.l,t.opacity);if(t instanceof nn||(t=_n(t)),!t)return new Tn;if(t instanceof Tn)return t;var n=(t=t.rgb()).r/255,e=t.g/255,r=t.b/255,i=Math.min(n,e,r),o=Math.max(n,e,r),a=NaN,s=o-i,u=(o+i)/2;return s?(a=n===o?(e-r)/s+6*(e<r):e===o?(r-n)/s+2:(n-e)/s+4,s/=u<.5?o+i:2-o-i,a*=60):s=u>0&&u<1?0:a,new Tn(a,s,u,t.opacity)}function Tn(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function Nn(t,n,e){return 255*(t<60?n+(e-n)*t/60:t<180?e:t<240?n+(e-n)*(240-t)/60:n)}function Cn(t){return function(){return t}}function En(t){return 1==(t=+t)?Hn:function(n,e){return e-n?function(t,n,e){return t=Math.pow(t,e),n=Math.pow(n,e)-t,e=1/e,function(r){return Math.pow(t+r*n,e)}}(n,e,t):Cn(isNaN(n)?e:n)}}function Hn(t,n){var e=n-t;return e?function(t,n){return function(e){return t+e*n}}(t,e):Cn(isNaN(t)?n:t)}Jt(nn,_n,{copy:function(t){return Object.assign(new this.constructor,this,t)},displayable:function(){return this.rgb().displayable()},hex:pn,formatHex:pn,formatHsl:function(){return Sn(this).formatHsl()},formatRgb:gn,toString:gn}),Jt(wn,xn,tn(nn,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new wn(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new wn(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:bn,formatHex:bn,formatRgb:Mn,toString:Mn})),Jt(Tn,(function(t,n,e,r){return 1===arguments.length?Sn(t):new Tn(t,n,e,null==r?1:r)}),tn(nn,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new Tn(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new Tn(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),n=isNaN(t)||isNaN(this.s)?0:this.s,e=this.l,r=e+(e<.5?e:1-e)*n,i=2*e-r;return new wn(Nn(t>=240?t-240:t+120,i,r),Nn(t,i,r),Nn(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl:function(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"hsl(":"hsla(")+(this.h||0)+", "+100*(this.s||0)+"%, "+100*(this.l||0)+"%"+(1===t?")":", "+t+")")}}));var Ln=function t(n){var e=En(n);function r(t,n){var r=e((t=xn(t)).r,(n=xn(n)).r),i=e(t.g,n.g),o=e(t.b,n.b),a=Hn(t.opacity,n.opacity);return function(n){return t.r=r(n),t.g=i(n),t.b=o(n),t.opacity=a(n),t+""}}return r.gamma=t,r}(1);function Dn(t,n){n||(n=[]);var e,r=t?Math.min(n.length,t.length):0,i=n.slice();return function(o){for(e=0;e<r;++e)i[e]=t[e]*(1-o)+n[e]*o;return i}}function Fn(t,n){var e,r=n?n.length:0,i=t?Math.min(r,t.length):0,o=new Array(i),a=new Array(r);for(e=0;e<i;++e)o[e]=Rn(t[e],n[e]);for(;e<r;++e)a[e]=n[e];return function(t){for(e=0;e<i;++e)a[e]=o[e](t);return a}}function Pn(t,n){var e=new Date;return t=+t,n=+n,function(r){return e.setTime(t*(1-r)+n*r),e}}function Bn(t,n){return t=+t,n=+n,function(e){return t*(1-e)+n*e}}function On(t,n){var e,r={},i={};for(e in null!==t&&"object"==typeof t||(t={}),null!==n&&"object"==typeof n||(n={}),n)e in t?r[e]=Rn(t[e],n[e]):i[e]=n[e];return function(t){for(e in r)i[e]=r[e](t);return i}}var zn=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,In=new RegExp(zn.source,"g");function jn(t,n){var e,r,i,o=zn.lastIndex=In.lastIndex=0,a=-1,s=[],u=[];for(t+="",n+="";(e=zn.exec(t))&&(r=In.exec(n));)(i=r.index)>o&&(i=n.slice(o,i),s[a]?s[a]+=i:s[++a]=i),(e=e[0])===(r=r[0])?s[a]?s[a]+=r:s[++a]=r:(s[++a]=null,u.push({i:a,x:Bn(e,r)})),o=In.lastIndex;return o<n.length&&(i=n.slice(o),s[a]?s[a]+=i:s[++a]=i),s.length<2?u[0]?function(t){return function(n){return t(n)+""}}(u[0].x):function(t){return function(){return t}}(n):(n=u.length,function(t){for(var e,r=0;r<n;++r)s[(e=u[r]).i]=e.x(t);return s.join("")})}function Rn(t,n){var e,r=typeof n;return null==n||"boolean"===r?Cn(n):("number"===r?Bn:"string"===r?(e=_n(n))?(n=e,Ln):jn:n instanceof _n?Ln:n instanceof Date?Pn:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}(n)?Dn:Array.isArray(n)?Fn:"function"!=typeof n.valueOf&&"function"!=typeof n.toString||isNaN(n)?On:Bn)(t,n)}function qn(t,n){return t=+t,n=+n,function(e){return Math.round(t*(1-e)+n*e)}}var Xn,$n,Gn,Vn,Yn=180/Math.PI,Un={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function Wn(t,n,e,r,i,o){var a,s,u;return(a=Math.sqrt(t*t+n*n))&&(t/=a,n/=a),(u=t*e+n*r)&&(e-=t*u,r-=n*u),(s=Math.sqrt(e*e+r*r))&&(e/=s,r/=s,u/=s),t*r<n*e&&(t=-t,n=-n,u=-u,a=-a),{translateX:i,translateY:o,rotate:Math.atan2(n,t)*Yn,skewX:Math.atan(u)*Yn,scaleX:a,scaleY:s}}function Zn(t,n,e,r){function i(t){return t.length?t.pop()+" ":""}return function(o,a){var s=[],u=[];return o=t(o),a=t(a),function(t,r,i,o,a,s){if(t!==i||r!==o){var u=a.push("translate(",null,n,null,e);s.push({i:u-4,x:Bn(t,i)},{i:u-2,x:Bn(r,o)})}else(i||o)&&a.push("translate("+i+n+o+e)}(o.translateX,o.translateY,a.translateX,a.translateY,s,u),function(t,n,e,o){t!==n?(t-n>180?n+=360:n-t>180&&(t+=360),o.push({i:e.push(i(e)+"rotate(",null,r)-2,x:Bn(t,n)})):n&&e.push(i(e)+"rotate("+n+r)}(o.rotate,a.rotate,s,u),function(t,n,e,o){t!==n?o.push({i:e.push(i(e)+"skewX(",null,r)-2,x:Bn(t,n)}):n&&e.push(i(e)+"skewX("+n+r)}(o.skewX,a.skewX,s,u),function(t,n,e,r,o,a){if(t!==e||n!==r){var s=o.push(i(o)+"scale(",null,",",null,")");a.push({i:s-4,x:Bn(t,e)},{i:s-2,x:Bn(n,r)})}else 1===e&&1===r||o.push(i(o)+"scale("+e+","+r+")")}(o.scaleX,o.scaleY,a.scaleX,a.scaleY,s,u),o=a=null,function(t){for(var n,e=-1,r=u.length;++e<r;)s[(n=u[e]).i]=n.x(t);return s.join("")}}}var Kn=Zn((function(t){return"none"===t?Un:(Xn||(Xn=document.createElement("DIV"),$n=document.documentElement,Gn=document.defaultView),Xn.style.transform=t,t=Gn.getComputedStyle($n.appendChild(Xn),null).getPropertyValue("transform"),$n.removeChild(Xn),Wn(+(t=t.slice(7,-1).split(","))[0],+t[1],+t[2],+t[3],+t[4],+t[5]))}),"px, ","px)","deg)"),Qn=Zn((function(t){return null==t?Un:(Vn||(Vn=document.createElementNS("http://www.w3.org/2000/svg","g")),Vn.setAttribute("transform",t),(t=Vn.transform.baseVal.consolidate())?Wn((t=t.matrix).a,t.b,t.c,t.d,t.e,t.f):Un)}),", ",")",")");function Jn(t,n){var e,r;return function(){var i=Kt(this,t),o=i.tween;if(o!==e)for(var a=0,s=(r=e=o).length;a<s;++a)if(r[a].name===n){(r=r.slice()).splice(a,1);break}i.tween=r}}function te(t,n,e){var r,i;if("function"!=typeof e)throw new Error;return function(){var o=Kt(this,t),a=o.tween;if(a!==r){i=(r=a).slice();for(var s={name:n,value:e},u=0,l=i.length;u<l;++u)if(i[u].name===n){i[u]=s;break}u===l&&i.push(s)}o.tween=i}}function ne(t,n,e){var r=t._id;return t.each((function(){var t=Kt(this,r);(t.value||(t.value={}))[n]=e.apply(this,arguments)})),function(t){return Qt(t,r).value[n]}}function ee(t,n){var e;return("number"==typeof n?Bn:n instanceof _n?Ln:(e=_n(n))?(n=e,Ln):jn)(t,n)}function re(t){return function(){this.removeAttribute(t)}}function ie(t){return function(){this.removeAttributeNS(t.space,t.local)}}function oe(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttribute(t);return a===o?null:a===r?i:i=n(r=a,e)}}function ae(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttributeNS(t.space,t.local);return a===o?null:a===r?i:i=n(r=a,e)}}function se(t,n,e){var r,i,o;return function(){var a,s,u=e(this);if(null!=u)return(a=this.getAttribute(t))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=n(r=a,u));this.removeAttribute(t)}}function ue(t,n,e){var r,i,o;return function(){var a,s,u=e(this);if(null!=u)return(a=this.getAttributeNS(t.space,t.local))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=n(r=a,u));this.removeAttributeNS(t.space,t.local)}}function le(t,n){return function(e){this.setAttribute(t,n.call(this,e))}}function he(t,n){return function(e){this.setAttributeNS(t.space,t.local,n.call(this,e))}}function ce(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&he(t,i)),e}return i._value=n,i}function fe(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&le(t,i)),e}return i._value=n,i}function de(t,n){return function(){Zt(this,t).delay=+n.apply(this,arguments)}}function pe(t,n){return n=+n,function(){Zt(this,t).delay=n}}function ge(t,n){return function(){Kt(this,t).duration=+n.apply(this,arguments)}}function _e(t,n){return n=+n,function(){Kt(this,t).duration=n}}function ve(t,n){if("function"!=typeof n)throw new Error;return function(){Kt(this,t).ease=n}}function ye(t,n,e){var r,i,o=function(t){return(t+"").trim().split(/^|\s+/).every((function(t){var n=t.indexOf(".");return n>=0&&(t=t.slice(0,n)),!t||"start"===t}))}(n)?Zt:Kt;return function(){var a=o(this,t),s=a.on;s!==r&&(i=(r=s).copy()).on(n,e),a.on=i}}var me=_t.prototype.constructor;function xe(t){return function(){this.style.removeProperty(t)}}function we(t,n,e){return function(r){this.style.setProperty(t,n.call(this,r),e)}}function be(t,n,e){var r,i;function o(){var o=n.apply(this,arguments);return o!==i&&(r=(i=o)&&we(t,o,e)),r}return o._value=n,o}function Me(t){return function(n){this.textContent=t.call(this,n)}}function ke(t){var n,e;function r(){var r=t.apply(this,arguments);return r!==e&&(n=(e=r)&&Me(r)),n}return r._value=t,r}var Ae=0;function Se(t,n,e,r){this._groups=t,this._parents=n,this._name=e,this._id=r}function Te(t){return _t().transition(t)}function Ne(){return++Ae}var Ce=_t.prototype;Se.prototype=Te.prototype={constructor:Se,select:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=d(t));for(var r=this._groups,i=r.length,o=new Array(i),a=0;a<i;++a)for(var s,u,l=r[a],h=l.length,c=o[a]=new Array(h),f=0;f<h;++f)(s=l[f])&&(u=t.call(s,s.__data__,f,l))&&("__data__"in s&&(u.__data__=s.__data__),c[f]=u,Wt(c[f],n,e,f,c,Qt(s,e)));return new Se(o,this._parents,n,e)},selectAll:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=g(t));for(var r=this._groups,i=r.length,o=[],a=[],s=0;s<i;++s)for(var u,l=r[s],h=l.length,c=0;c<h;++c)if(u=l[c]){for(var f,d=t.call(u,u.__data__,c,l),p=Qt(u,e),_=0,v=d.length;_<v;++_)(f=d[_])&&Wt(f,n,e,_,d,p);o.push(d),a.push(u)}return new Se(o,a,n,e)},filter:function(t){"function"!=typeof t&&(t=_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],s=a.length,u=r[i]=[],l=0;l<s;++l)(o=a[l])&&t.call(o,o.__data__,l,a)&&u.push(o);return new Se(r,this._parents,this._name,this._id)},merge:function(t){if(t._id!==this._id)throw new Error;for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,l=n[s],h=e[s],c=l.length,f=a[s]=new Array(c),d=0;d<c;++d)(u=l[d]||h[d])&&(f[d]=u);for(;s<r;++s)a[s]=n[s];return new Se(a,this._parents,this._name,this._id)},selection:function(){return new me(this._groups,this._parents)},transition:function(){for(var t=this._name,n=this._id,e=Ne(),r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,l=0;l<u;++l)if(a=s[l]){var h=Qt(a,n);Wt(a,t,e,l,s,{time:h.time+h.delay+h.duration,delay:0,duration:h.duration,ease:h.ease})}return new Se(r,this._parents,t,e)},call:Ce.call,nodes:Ce.nodes,node:Ce.node,size:Ce.size,empty:Ce.empty,each:Ce.each,on:function(t,n){var e=this._id;return arguments.length<2?Qt(this.node(),e).on.on(t):this.each(ye(e,t,n))},attr:function(t,n){var e=u(t),r="transform"===e?Qn:ee;return this.attrTween(t,"function"==typeof n?(e.local?ue:se)(e,r,ne(this,"attr."+t,n)):null==n?(e.local?ie:re)(e):(e.local?ae:oe)(e,r,n))},attrTween:function(t,n){var e="attr."+t;if(arguments.length<2)return(e=this.tween(e))&&e._value;if(null==n)return this.tween(e,null);if("function"!=typeof n)throw new Error;var r=u(t);return this.tween(e,(r.local?ce:fe)(r,n))},style:function(t,n,e){var r="transform"==(t+="")?Kn:ee;return null==n?this.styleTween(t,function(t,n){var e,r,i;return function(){var o=D(this,t),a=(this.style.removeProperty(t),D(this,t));return o===a?null:o===e&&a===r?i:i=n(e=o,r=a)}}(t,r)).on("end.style."+t,xe(t)):"function"==typeof n?this.styleTween(t,function(t,n,e){var r,i,o;return function(){var a=D(this,t),s=e(this),u=s+"";return null==s&&(this.style.removeProperty(t),u=s=D(this,t)),a===u?null:a===r&&u===i?o:(i=u,o=n(r=a,s))}}(t,r,ne(this,"style."+t,n))).each(function(t,n){var e,r,i,o,a="style."+n,s="end."+a;return function(){var u=Kt(this,t),l=u.on,h=null==u.value[a]?o||(o=xe(n)):void 0;l===e&&i===h||(r=(e=l).copy()).on(s,i=h),u.on=r}}(this._id,t)):this.styleTween(t,function(t,n,e){var r,i,o=e+"";return function(){var a=D(this,t);return a===o?null:a===r?i:i=n(r=a,e)}}(t,r,n),e).on("end.style."+t,null)},styleTween:function(t,n,e){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==n)return this.tween(r,null);if("function"!=typeof n)throw new Error;return this.tween(r,be(t,n,null==e?"":e))},text:function(t){return this.tween("text","function"==typeof t?function(t){return function(){var n=t(this);this.textContent=null==n?"":n}}(ne(this,"text",t)):function(t){return function(){this.textContent=t}}(null==t?"":t+""))},textTween:function(t){var n="text";if(arguments.length<1)return(n=this.tween(n))&&n._value;if(null==t)return this.tween(n,null);if("function"!=typeof t)throw new Error;return this.tween(n,ke(t))},remove:function(){return this.on("end.remove",function(t){return function(){var n=this.parentNode;for(var e in this.__transition)if(+e!==t)return;n&&n.removeChild(this)}}(this._id))},tween:function(t,n){var e=this._id;if(t+="",arguments.length<2){for(var r,i=Qt(this.node(),e).tween,o=0,a=i.length;o<a;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==n?Jn:te)(e,t,n))},delay:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?de:pe)(n,t)):Qt(this.node(),n).delay},duration:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?ge:_e)(n,t)):Qt(this.node(),n).duration},ease:function(t){var n=this._id;return arguments.length?this.each(ve(n,t)):Qt(this.node(),n).ease},end:function(){var t,n,e=this,r=e._id,i=e.size();return new Promise((function(o,a){var s={value:a},u={value:function(){0==--i&&o()}};e.each((function(){var e=Kt(this,r),i=e.on;i!==t&&((n=(t=i).copy())._.cancel.push(s),n._.interrupt.push(s),n._.end.push(u)),e.on=n}))}))}};var Ee={time:null,delay:0,duration:250,ease:function(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}};function He(t,n){for(var e;!(e=t.__transition)||!(e=e[n]);)if(!(t=t.parentNode))return Ee.time=It(),Ee;return e}function Le(t,n){return t.each((function(){var t=n.apply(this,arguments),e=vt(this);for(var r in t)e.attr(r,t[r])}))}function De(t,n){for(var e in n)t.attr(e,n[e]);return t}function Fe(t,n,e){return t.each((function(){var t=n.apply(this,arguments),r=vt(this);for(var i in t)r.style(i,t[i],e)}))}function Pe(t,n,e){for(var r in n)t.style(r,n[r],e);return t}function Be(t,n){return t.each((function(){var t=n.apply(this,arguments),e=vt(this);for(var r in t)e.property(r,t[r])}))}function Oe(t,n){for(var e in n)t.property(e,n[e]);return t}function ze(t,n){return t.each((function(){var e=n.apply(this,arguments),r=vt(this).transition(t);for(var i in e)r.attr(i,e[i])}))}function Ie(t,n){for(var e in n)t.attr(e,n[e]);return t}function je(t,n,e){return t.each((function(){var r=n.apply(this,arguments),i=vt(this).transition(t);for(var o in r)i.style(o,r[o],e)}))}function Re(t,n,e){for(var r in n)t.style(r,n[r],e);return t}_t.prototype.interrupt=function(t){return this.each((function(){!function(t,n){var e,r,i,o=t.__transition,a=!0;if(o){for(i in n=null==n?null:n+"",o)(e=o[i]).name===n?(r=e.state>2&&e.state<5,e.state=6,e.timer.stop(),e.on.call(r?"interrupt":"cancel",t,t.__data__,e.index,e.group),delete o[i]):a=!1;a&&delete t.__transition}}(this,t)}))},_t.prototype.transition=function(t){var n,e;t instanceof Se?(n=t._id,t=t._name):(n=Ne(),(e=Ee).time=It(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,l=0;l<u;++l)(a=s[l])&&Wt(a,t,n,l,s,e||He(a,n));return new Se(r,this._parents,t,n)},_t.prototype.attrs=function(t){return("function"==typeof t?Le:De)(this,t)},_t.prototype.styles=function(t,n){return("function"==typeof t?Fe:Pe)(this,t,null==n?"":n)},_t.prototype.properties=function(t){return("function"==typeof t?Be:Oe)(this,t)},Te.prototype.attrs=function(t){return("function"==typeof t?ze:Ie)(this,t)},Te.prototype.styles=function(t,n){return("function"==typeof t?je:Re)(this,t,null==n?"":n)};var qe=Array.prototype.slice;function Xe(t){return t}function $e(t){return"translate("+(t+.5)+",0)"}function Ge(t){return"translate(0,"+(t+.5)+")"}function Ve(t){return function(n){return+t(n)}}function Ye(t){var n=Math.max(0,t.bandwidth()-1)/2;return t.round()&&(n=Math.round(n)),function(e){return+t(e)+n}}function Ue(){return!this.__axis}function We(t,n){var e=[],r=null,i=null,o=6,a=6,s=3,u=1===t||4===t?-1:1,l=4===t||2===t?"x":"y",h=1===t||3===t?$e:Ge;function c(c){var f=null==r?n.ticks?n.ticks.apply(n,e):n.domain():r,d=null==i?n.tickFormat?n.tickFormat.apply(n,e):Xe:i,p=Math.max(o,0)+s,g=n.range(),_=+g[0]+.5,v=+g[g.length-1]+.5,y=(n.bandwidth?Ye:Ve)(n.copy()),m=c.selection?c.selection():c,x=m.selectAll(".domain").data([null]),w=m.selectAll(".tick").data(f,n).order(),b=w.exit(),M=w.enter().append("g").attr("class","tick"),k=w.select("line"),A=w.select("text");x=x.merge(x.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor")),w=w.merge(M),k=k.merge(M.append("line").attr("stroke","currentColor").attr(l+"2",u*o)),A=A.merge(M.append("text").attr("fill","currentColor").attr(l,u*p).attr("dy",1===t?"0em":3===t?"0.71em":"0.32em")),c!==m&&(x=x.transition(c),w=w.transition(c),k=k.transition(c),A=A.transition(c),b=b.transition(c).attr("opacity",1e-6).attr("transform",(function(t){return isFinite(t=y(t))?h(t):this.getAttribute("transform")})),M.attr("opacity",1e-6).attr("transform",(function(t){var n=this.parentNode.__axis;return h(n&&isFinite(n=n(t))?n:y(t))}))),b.remove(),x.attr("d",4===t||2==t?a?"M"+u*a+","+_+"H0.5V"+v+"H"+u*a:"M0.5,"+_+"V"+v:a?"M"+_+","+u*a+"V0.5H"+v+"V"+u*a:"M"+_+",0.5H"+v),w.attr("opacity",1).attr("transform",(function(t){return h(y(t))})),k.attr(l+"2",u*o),A.attr(l,u*p).text(d),m.filter(Ue).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",2===t?"start":4===t?"end":"middle"),m.each((function(){this.__axis=y}))}return c.scale=function(t){return arguments.length?(n=t,c):n},c.ticks=function(){return e=qe.call(arguments),c},c.tickArguments=function(t){return arguments.length?(e=null==t?[]:qe.call(t),c):e.slice()},c.tickValues=function(t){return arguments.length?(r=null==t?null:qe.call(t),c):r&&r.slice()},c.tickFormat=function(t){return arguments.length?(i=t,c):i},c.tickSize=function(t){return arguments.length?(o=a=+t,c):o},c.tickSizeInner=function(t){return arguments.length?(o=+t,c):o},c.tickSizeOuter=function(t){return arguments.length?(a=+t,c):a},c.tickPadding=function(t){return arguments.length?(s=+t,c):s},c}function Ze(t){return We(3,t)}function Ke(t){return We(4,t)}function Qe(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function Je(t){var n;return 1===t.length&&(n=t,t=function(t,e){return Qe(n(t),e)}),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)<0?r=o+1:i=o}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)>0?i=o:r=o+1}return r}}}var tr=Je(Qe).right,nr=Math.sqrt(50),er=Math.sqrt(10),rr=Math.sqrt(2);function ir(t,n,e){var r=(n-t)/Math.max(0,e),i=Math.floor(Math.log(r)/Math.LN10),o=r/Math.pow(10,i);return i>=0?(o>=nr?10:o>=er?5:o>=rr?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(o>=nr?10:o>=er?5:o>=rr?2:1)}function or(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&e>r&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&e>r&&(r=e);return r}var ar=Math.PI,sr=2*ar,ur=sr-1e-6;function lr(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function hr(){return new lr}function cr(t){return function(){return t}}lr.prototype=hr.prototype={constructor:lr,moveTo:function(t,n){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,n){this._+="L"+(this._x1=+t)+","+(this._y1=+n)},quadraticCurveTo:function(t,n,e,r){this._+="Q"+ +t+","+ +n+","+(this._x1=+e)+","+(this._y1=+r)},bezierCurveTo:function(t,n,e,r,i,o){this._+="C"+ +t+","+ +n+","+ +e+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,n,e,r,i){t=+t,n=+n,e=+e,r=+r,i=+i;var o=this._x1,a=this._y1,s=e-t,u=r-n,l=o-t,h=a-n,c=l*l+h*h;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=n);else if(c>1e-6)if(Math.abs(h*s-u*l)>1e-6&&i){var f=e-o,d=r-a,p=s*s+u*u,g=f*f+d*d,_=Math.sqrt(p),v=Math.sqrt(c),y=i*Math.tan((ar-Math.acos((p+c-g)/(2*_*v)))/2),m=y/v,x=y/_;Math.abs(m-1)>1e-6&&(this._+="L"+(t+m*l)+","+(n+m*h)),this._+="A"+i+","+i+",0,0,"+ +(h*f>l*d)+","+(this._x1=t+x*s)+","+(this._y1=n+x*u)}else this._+="L"+(this._x1=t)+","+(this._y1=n);else;},arc:function(t,n,e,r,i,o){t=+t,n=+n,o=!!o;var a=(e=+e)*Math.cos(r),s=e*Math.sin(r),u=t+a,l=n+s,h=1^o,c=o?r-i:i-r;if(e<0)throw new Error("negative radius: "+e);null===this._x1?this._+="M"+u+","+l:(Math.abs(this._x1-u)>1e-6||Math.abs(this._y1-l)>1e-6)&&(this._+="L"+u+","+l),e&&(c<0&&(c=c%sr+sr),c>ur?this._+="A"+e+","+e+",0,1,"+h+","+(t-a)+","+(n-s)+"A"+e+","+e+",0,1,"+h+","+(this._x1=u)+","+(this._y1=l):c>1e-6&&(this._+="A"+e+","+e+",0,"+ +(c>=ar)+","+h+","+(this._x1=t+e*Math.cos(i))+","+(this._y1=n+e*Math.sin(i))))},rect:function(t,n,e,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)+"h"+ +e+"v"+ +r+"h"+-e+"Z"},toString:function(){return this._}};var fr=Math.PI,dr=2*fr;function pr(t){this._context=t}function gr(t){return new pr(t)}function _r(t){return t[0]}function vr(t){return t[1]}function yr(){var t=_r,n=vr,e=cr(!0),r=null,i=gr,o=null;function a(a){var s,u,l,h=a.length,c=!1;for(null==r&&(o=i(l=hr())),s=0;s<=h;++s)!(s<h&&e(u=a[s],s,a))===c&&((c=!c)?o.lineStart():o.lineEnd()),c&&o.point(+t(u,s,a),+n(u,s,a));if(l)return o=null,l+""||null}return a.x=function(n){return arguments.length?(t="function"==typeof n?n:cr(+n),a):t},a.y=function(t){return arguments.length?(n="function"==typeof t?t:cr(+t),a):n},a.defined=function(t){return arguments.length?(e="function"==typeof t?t:cr(!!t),a):e},a.curve=function(t){return arguments.length?(i=t,null!=r&&(o=i(r)),a):i},a.context=function(t){return arguments.length?(null==t?r=o=null:o=i(r=t),a):r},a}pr.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._context.lineTo(t,n)}}};var mr={draw:function(t,n){var e=Math.sqrt(n/fr);t.moveTo(e,0),t.arc(0,0,e,0,dr)}},xr=Math.sqrt(3),wr={draw:function(t,n){var e=-Math.sqrt(n/(3*xr));t.moveTo(0,2*e),t.lineTo(-xr*e,-e),t.lineTo(xr*e,-e),t.closePath()}};function br(){var t=cr(mr),n=cr(64),e=null;function r(){var r;if(e||(e=r=hr()),t.apply(this,arguments).draw(e,+n.apply(this,arguments)),r)return e=null,r+""||null}return r.type=function(n){return arguments.length?(t="function"==typeof n?n:cr(n),r):t},r.size=function(t){return arguments.length?(n="function"==typeof t?t:cr(+t),r):n},r.context=function(t){return arguments.length?(e=null==t?null:t,r):e},r}function Mr(t,n,e){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+n)/6,(t._y0+4*t._y1+e)/6)}function kr(t){this._context=t}function Ar(t){return new kr(t)}function Sr(t,n){switch(arguments.length){case 0:break;case 1:this.range(t);break;default:this.range(n).domain(t)}return this}kr.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:Mr(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:Mr(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}};function Tr(){}function Nr(t,n){var e=new Tr;if(t instanceof Tr)t.each((function(t,n){e.set(n,t)}));else if(Array.isArray(t)){var r,i=-1,o=t.length;if(null==n)for(;++i<o;)e.set(i,t[i]);else for(;++i<o;)e.set(n(r=t[i],i,t),r)}else if(t)for(var a in t)e.set(a,t[a]);return e}function Cr(){}Tr.prototype=Nr.prototype={constructor:Tr,has:function(t){return"$"+t in this},get:function(t){return this["$"+t]},set:function(t,n){return this["$"+t]=n,this},remove:function(t){var n="$"+t;return n in this&&delete this[n]},clear:function(){for(var t in this)"$"===t[0]&&delete this[t]},keys:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(n.slice(1));return t},values:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(this[n]);return t},entries:function(){var t=[];for(var n in this)"$"===n[0]&&t.push({key:n.slice(1),value:this[n]});return t},size:function(){var t=0;for(var n in this)"$"===n[0]&&++t;return t},empty:function(){for(var t in this)if("$"===t[0])return!1;return!0},each:function(t){for(var n in this)"$"===n[0]&&t(this[n],n.slice(1),this)}};var Er=Nr.prototype;Cr.prototype=function(t,n){var e=new Cr;if(t instanceof Cr)t.each((function(t){e.add(t)}));else if(t){var r=-1,i=t.length;if(null==n)for(;++r<i;)e.add(t[r]);else for(;++r<i;)e.add(n(t[r],r,t))}return e}.prototype={constructor:Cr,has:Er.has,add:function(t){return this["$"+(t+="")]=t,this},remove:Er.remove,clear:Er.clear,values:Er.keys,size:Er.size,empty:Er.empty,each:Er.each};var Hr=Array.prototype,Lr=Hr.map,Dr=Hr.slice,Fr={name:"implicit"};function Pr(t){return+t}var Br=[0,1];function Or(t){return t}function zr(t,n){return(n-=t=+t)?function(e){return(e-t)/n}:function(t){return function(){return t}}(isNaN(n)?NaN:.5)}function Ir(t){var n,e=t[0],r=t[t.length-1];return e>r&&(n=e,e=r,r=n),function(t){return Math.max(e,Math.min(r,t))}}function jr(t,n,e){var r=t[0],i=t[1],o=n[0],a=n[1];return i<r?(r=zr(i,r),o=e(a,o)):(r=zr(r,i),o=e(o,a)),function(t){return o(r(t))}}function Rr(t,n,e){var r=Math.min(t.length,n.length)-1,i=new Array(r),o=new Array(r),a=-1;for(t[r]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<r;)i[a]=zr(t[a],t[a+1]),o[a]=e(n[a],n[a+1]);return function(n){var e=tr(t,n,1,r)-1;return o[e](i[e](n))}}function qr(t,n){return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())}function Xr(t,n){return function(){var t,n,e,r,i,o,a=Br,s=Br,u=Rn,l=Or;function h(){return r=Math.min(a.length,s.length)>2?Rr:jr,i=o=null,c}function c(n){return isNaN(n=+n)?e:(i||(i=r(a.map(t),s,u)))(t(l(n)))}return c.invert=function(e){return l(n((o||(o=r(s,a.map(t),Bn)))(e)))},c.domain=function(t){return arguments.length?(a=Lr.call(t,Pr),l===Or||(l=Ir(a)),h()):a.slice()},c.range=function(t){return arguments.length?(s=Dr.call(t),h()):s.slice()},c.rangeRound=function(t){return s=Dr.call(t),u=qn,h()},c.clamp=function(t){return arguments.length?(l=t?Ir(a):Or,c):l!==Or},c.interpolate=function(t){return arguments.length?(u=t,h()):u},c.unknown=function(t){return arguments.length?(e=t,c):e},function(e,r){return t=e,n=r,h()}}()(t,n)}function $r(t,n){if((e=(t=n?t.toExponential(n-1):t.toExponential()).indexOf("e"))<0)return null;var e,r=t.slice(0,e);return[r.length>1?r[0]+r.slice(2):r,+t.slice(e+1)]}function Gr(t){return(t=$r(Math.abs(t)))?t[1]:NaN}var Vr,Yr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function Ur(t){if(!(n=Yr.exec(t)))throw new Error("invalid format: "+t);var n;return new Wr({fill:n[1],align:n[2],sign:n[3],symbol:n[4],zero:n[5],width:n[6],comma:n[7],precision:n[8]&&n[8].slice(1),trim:n[9],type:n[10]})}function Wr(t){this.fill=void 0===t.fill?" ":t.fill+"",this.align=void 0===t.align?">":t.align+"",this.sign=void 0===t.sign?"-":t.sign+"",this.symbol=void 0===t.symbol?"":t.symbol+"",this.zero=!!t.zero,this.width=void 0===t.width?void 0:+t.width,this.comma=!!t.comma,this.precision=void 0===t.precision?void 0:+t.precision,this.trim=!!t.trim,this.type=void 0===t.type?"":t.type+""}function Zr(t,n){var e=$r(t,n);if(!e)return t+"";var r=e[0],i=e[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")}Ur.prototype=Wr.prototype,Wr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Kr={"%":function(t,n){return(100*t).toFixed(n)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:function(t){return Math.round(t).toString(10)},e:function(t,n){return t.toExponential(n)},f:function(t,n){return t.toFixed(n)},g:function(t,n){return t.toPrecision(n)},o:function(t){return Math.round(t).toString(8)},p:function(t,n){return Zr(100*t,n)},r:Zr,s:function(t,n){var e=$r(t,n);if(!e)return t+"";var r=e[0],i=e[1],o=i-(Vr=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,a=r.length;return o===a?r:o>a?r+new Array(o-a+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+$r(t,Math.max(0,n+o-1))[0]},X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}};function Qr(t){return t}var Jr,ti,ni,ei=Array.prototype.map,ri=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function ii(t){var n,e,r=void 0===t.grouping||void 0===t.thousands?Qr:(n=ei.call(t.grouping,Number),e=t.thousands+"",function(t,r){for(var i=t.length,o=[],a=0,s=n[0],u=0;i>0&&s>0&&(u+s+1>r&&(s=Math.max(1,r-u)),o.push(t.substring(i-=s,i+s)),!((u+=s+1)>r));)s=n[a=(a+1)%n.length];return o.reverse().join(e)}),i=void 0===t.currency?"":t.currency[0]+"",o=void 0===t.currency?"":t.currency[1]+"",a=void 0===t.decimal?".":t.decimal+"",s=void 0===t.numerals?Qr:function(t){return function(n){return n.replace(/[0-9]/g,(function(n){return t[+n]}))}}(ei.call(t.numerals,String)),u=void 0===t.percent?"%":t.percent+"",l=void 0===t.minus?"-":t.minus+"",h=void 0===t.nan?"NaN":t.nan+"";function c(t){var n=(t=Ur(t)).fill,e=t.align,c=t.sign,f=t.symbol,d=t.zero,p=t.width,g=t.comma,_=t.precision,v=t.trim,y=t.type;"n"===y?(g=!0,y="g"):Kr[y]||(void 0===_&&(_=12),v=!0,y="g"),(d||"0"===n&&"="===e)&&(d=!0,n="0",e="=");var m="$"===f?i:"#"===f&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",x="$"===f?o:/[%p]/.test(y)?u:"",w=Kr[y],b=/[defgprs%]/.test(y);function M(t){var i,o,u,f=m,M=x;if("c"===y)M=w(t)+M,t="";else{var k=(t=+t)<0||1/t<0;if(t=isNaN(t)?h:w(Math.abs(t),_),v&&(t=function(t){t:for(var n,e=t.length,r=1,i=-1;r<e;++r)switch(t[r]){case".":i=n=r;break;case"0":0===i&&(i=r),n=r;break;default:if(!+t[r])break t;i>0&&(i=0)}return i>0?t.slice(0,i)+t.slice(n+1):t}(t)),k&&0==+t&&"+"!==c&&(k=!1),f=(k?"("===c?c:l:"-"===c||"("===c?"":c)+f,M=("s"===y?ri[8+Vr/3]:"")+M+(k&&"("===c?")":""),b)for(i=-1,o=t.length;++i<o;)if(48>(u=t.charCodeAt(i))||u>57){M=(46===u?a+t.slice(i+1):t.slice(i))+M,t=t.slice(0,i);break}}g&&!d&&(t=r(t,1/0));var A=f.length+t.length+M.length,S=A<p?new Array(p-A+1).join(n):"";switch(g&&d&&(t=r(S+t,S.length?p-M.length:1/0),S=""),e){case"<":t=f+t+M+S;break;case"=":t=f+S+t+M;break;case"^":t=S.slice(0,A=S.length>>1)+f+t+M+S.slice(A);break;default:t=S+f+t+M}return s(t)}return _=void 0===_?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,_)):Math.max(0,Math.min(20,_)),M.toString=function(){return t+""},M}return{format:c,formatPrefix:function(t,n){var e=c(((t=Ur(t)).type="f",t)),r=3*Math.max(-8,Math.min(8,Math.floor(Gr(n)/3))),i=Math.pow(10,-r),o=ri[8+r/3];return function(t){return e(i*t)+o}}}}function oi(t,n,e,r){var i,o=function(t,n,e){var r=Math.abs(n-t)/Math.max(0,e),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=nr?i*=10:o>=er?i*=5:o>=rr&&(i*=2),n<t?-i:i}(t,n,e);switch((r=Ur(null==r?",f":r)).type){case"s":var a=Math.max(Math.abs(t),Math.abs(n));return null!=r.precision||isNaN(i=function(t,n){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(Gr(n)/3)))-Gr(Math.abs(t)))}(o,a))||(r.precision=i),ni(r,a);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(i=function(t,n){return t=Math.abs(t),n=Math.abs(n)-t,Math.max(0,Gr(n)-Gr(t))+1}(o,Math.max(Math.abs(t),Math.abs(n))))||(r.precision=i-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(i=function(t){return Math.max(0,-Gr(Math.abs(t)))}(o))||(r.precision=i-2*("%"===r.type))}return ti(r)}function ai(t){var n=t.domain;return t.ticks=function(t){var e=n();return function(t,n,e){var r,i,o,a,s=-1;if(e=+e,(t=+t)===(n=+n)&&e>0)return[t];if((r=n<t)&&(i=t,t=n,n=i),0===(a=ir(t,n,e))||!isFinite(a))return[];if(a>0)for(t=Math.ceil(t/a),n=Math.floor(n/a),o=new Array(i=Math.ceil(n-t+1));++s<i;)o[s]=(t+s)*a;else for(t=Math.floor(t*a),n=Math.ceil(n*a),o=new Array(i=Math.ceil(t-n+1));++s<i;)o[s]=(t-s)/a;return r&&o.reverse(),o}(e[0],e[e.length-1],null==t?10:t)},t.tickFormat=function(t,e){var r=n();return oi(r[0],r[r.length-1],null==t?10:t,e)},t.nice=function(e){null==e&&(e=10);var r,i=n(),o=0,a=i.length-1,s=i[o],u=i[a];return u<s&&(r=s,s=u,u=r,r=o,o=a,a=r),(r=ir(s,u,e))>0?r=ir(s=Math.floor(s/r)*r,u=Math.ceil(u/r)*r,e):r<0&&(r=ir(s=Math.ceil(s*r)/r,u=Math.floor(u*r)/r,e)),r>0?(i[o]=Math.floor(s/r)*r,i[a]=Math.ceil(u/r)*r,n(i)):r<0&&(i[o]=Math.ceil(s*r)/r,i[a]=Math.floor(u*r)/r,n(i)),t},t}function si(){var t=Xr(Or,Or);return t.copy=function(){return qr(t,si())},Sr.apply(t,arguments),ai(t)}function ui(t){for(var n=t.length/6|0,e=new Array(n),r=0;r<n;)e[r]="#"+t.slice(6*r,6*++r);return e}Jr=ii({decimal:".",thousands:",",grouping:[3],currency:["$",""],minus:"-"}),ti=Jr.format,ni=Jr.formatPrefix;var li=ui("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),hi=ui("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),ci=ui("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),fi=ui("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),di=ui("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),pi=ui("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");function gi(){it.stopImmediatePropagation()}function _i(){it.preventDefault(),it.stopImmediatePropagation()}function vi(t){var n=t.document.documentElement,e=vt(t).on("dragstart.drag",_i,!0);"onselectstart"in n?e.on("selectstart.drag",_i,!0):(n.__noselect=n.style.MozUserSelect,n.style.MozUserSelect="none")}function yi(t){return function(){return t}}function mi(t,n,e,r,i,o,a,s,u,l){this.target=t,this.type=n,this.subject=e,this.identifier=r,this.active=i,this.x=o,this.y=a,this.dx=s,this.dy=u,this._=l}function xi(){return!it.ctrlKey&&!it.button}function wi(){return this.parentNode}function bi(t){return null==t?{x:it.x,y:it.y}:t}function Mi(){return navigator.maxTouchPoints||"ontouchstart"in this}function ki(){var t,n,e,r,i=xi,o=wi,a=bi,s=Mi,u={},l=kt("start","drag","end"),h=0,c=0;function f(t){t.on("mousedown.drag",d).filter(s).on("touchstart.drag",_).on("touchmove.drag",v).on("touchend.drag touchcancel.drag",y).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function d(){if(!r&&i.apply(this,arguments)){var a=m("mouse",o.apply(this,arguments),xt,this,arguments);a&&(vt(it.view).on("mousemove.drag",p,!0).on("mouseup.drag",g,!0),vi(it.view),gi(),e=!1,t=it.clientX,n=it.clientY,a("start"))}}function p(){if(_i(),!e){var r=it.clientX-t,i=it.clientY-n;e=r*r+i*i>c}u.mouse("drag")}function g(){vt(it.view).on("mousemove.drag mouseup.drag",null),function(t,n){var e=t.document.documentElement,r=vt(t).on("dragstart.drag",null);n&&(r.on("click.drag",_i,!0),setTimeout((function(){r.on("click.drag",null)}),0)),"onselectstart"in e?r.on("selectstart.drag",null):(e.style.MozUserSelect=e.__noselect,delete e.__noselect)}(it.view,e),_i(),u.mouse("end")}function _(){if(i.apply(this,arguments)){var t,n,e=it.changedTouches,r=o.apply(this,arguments),a=e.length;for(t=0;t<a;++t)(n=m(e[t].identifier,r,bt,this,arguments))&&(gi(),n("start"))}}function v(){var t,n,e=it.changedTouches,r=e.length;for(t=0;t<r;++t)(n=u[e[t].identifier])&&(_i(),n("drag"))}function y(){var t,n,e=it.changedTouches,i=e.length;for(r&&clearTimeout(r),r=setTimeout((function(){r=null}),500),t=0;t<i;++t)(n=u[e[t].identifier])&&(gi(),n("end"))}function m(t,n,e,r,i){var o,s,c,d=e(n,t),p=l.copy();if(ht(new mi(f,"beforestart",o,t,h,d[0],d[1],0,0,p),(function(){return null!=(it.subject=o=a.apply(r,i))&&(s=o.x-d[0]||0,c=o.y-d[1]||0,!0)})))return function a(l){var g,_=d;switch(l){case"start":u[t]=a,g=h++;break;case"end":delete u[t],--h;case"drag":d=e(n,t),g=h}ht(new mi(f,l,o,t,g,d[0]+s,d[1]+c,d[0]-_[0],d[1]-_[1],p),p.apply,p,[l,r,i])}}return f.filter=function(t){return arguments.length?(i="function"==typeof t?t:yi(!!t),f):i},f.container=function(t){return arguments.length?(o="function"==typeof t?t:yi(t),f):o},f.subject=function(t){return arguments.length?(a="function"==typeof t?t:yi(t),f):a},f.touchable=function(t){return arguments.length?(s="function"==typeof t?t:yi(!!t),f):s},f.on=function(){var t=l.on.apply(l,arguments);return t===l?f:t},f.clickDistance=function(t){return arguments.length?(c=(t=+t)*t,f):Math.sqrt(c)},f}mi.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t},function(n,e){"function"==typeof define&&define.amd?define(["leaflet"],n):"object"===("undefined"==typeof exports?"undefined":t(exports))&&(void 0!==e&&e.L?module.exports=n(L):module.exports=n(require("leaflet"))),void 0!==e&&e.L&&(e.L.Control.Heightgraph=n(L))}((function(t){return t.Control.Heightgraph=t.Control.extend({options:{position:"bottomright",width:800,height:280,margins:{top:10,right:30,bottom:55,left:50},mappings:void 0,expand:!0,expandControls:!0,translation:{},expandCallback:void 0,chooseSelectionCallback:void 0,selectedAttributeIdx:0,xTicks:void 0,yTicks:void 0,highlightStyle:void 0,graphStyle:void 0},_defaultTranslation:{distance:"Distance",elevation:"Elevation",segment_length:"Segment length",type:"Type",legend:"Legend"},_init_options:function(){this._margin=this.options.margins,this._width=this.options.width,this._height=this.options.height,this._mappings=this.options.mappings,this._svgWidth=this._width-this._margin.left-this._margin.right,this._svgHeight=this._height-this._margin.top-this._margin.bottom,this._highlightStyle=this.options.highlightStyle||{color:"red"},this._graphStyle=this.options.graphStyle||{},this._dragCache={}},onAdd:function(n){var e=this._container=t.DomUtil.create("div","heightgraph");if(t.DomEvent.disableClickPropagation(e),this.options.expandControls){var r=this._button=t.DomUtil.create("div","heightgraph-toggle",e);t.DomUtil.create("a","heightgraph-toggle-icon",r),this._closeButton=t.DomUtil.create("a","heightgraph-close-icon",e)}return this._showState=!1,this._initToggle(),this._init_options(),this._svg=vt(this._container).append("svg").attr("class","heightgraph-container").attr("width",this._width).attr("height",this._height).append("g").attr("transform","translate("+this._margin.left+","+this._margin.top+")"),this.options.expand&&this._expand(),e},onRemove:function(t){this._removeMarkedSegmentsOnMap(),this._container=null,this._svg=void 0},addData:function(t){this._addData(t)},_addData:function(t){void 0!==this._svg&&this._svg.selectAll("*").remove(),(!t||this.options.selectedAttributeIdx>=t.length)&&(this.options.selectedAttributeIdx=0),this._removeMarkedSegmentsOnMap(),this._resetDrag(!0),this._data=t,this._init_options(),this._prepareData(),this._calculateElevationBounds(),this._appendScales(),this._appendGrid(),0!==Object.keys(t).length&&this._createChart(this.options.selectedAttributeIdx),this._createSelectionBox()},resize:function(t){t.width&&(this.options.width=t.width),t.height&&(this.options.height=t.height),vt(this._container).selectAll("svg").attr("width",this.options.width).attr("height",this.options.height),this._addData(this._data)},_initToggle:function(){t.Browser.touch?t.DomEvent.on(this._container,"click",t.DomEvent.stopPropagation):t.DomEvent.disableClickPropagation(this._container),this.options.expandControls&&(t.DomEvent.on(this._button,"click",this._expand,this),t.DomEvent.on(this._closeButton,"click",this._expand,this))},_dragHandler:function(){"undefined"!=typeof event&&(event.preventDefault(),event.stopPropagation()),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=this._dragCache.end=xt(this._background.node()),n=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-n).attr("x",n);else{var r=vt(this._container).select("svg").select("g");this._dragRectangleG=r.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-n).attr("height",this._svgHeight).attr("x",n).attr("class","mouse-drag").style("fill","grey").style("opacity",.5).style("pointer-events","none")}}},_resetDrag:function(t){if(this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,!0!==t)){var n=this._calculateFullExtent(this._areasFlattended);n&&this._map.fitBounds(n)}},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();var t=this._findItemForX(this._dragStartCoords[0]),n=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,n),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){event.preventDefault(),event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=this._dragCache.start=xt(this._background.node())},_calculateFullExtent:function(n){if(!n||n.length<1)return null;var e=new t.latLngBounds(n[0].latlng,n[0].latlng);return n.forEach((function(t){e.contains(t.latlng)||e.extend(t.latlng)})),e},_fitSection:function(t,n){var e,r=Math.min(t,n),i=Math.max(t,n);r!==i?e=this._calculateFullExtent(this._areasFlattended.slice(r,i+1)):this._areasFlattended.length>0&&(e=[this._areasFlattended[r].latlng,this._areasFlattended[i].latlng]),e&&this._map.fitBounds(e)},_expand:function(){!0!==this.options.expandControls&&(this._showState=!1),this._showState?(vt(this._button).style("display","block"),vt(this._container).selectAll("svg").style("display","none"),vt(this._closeButton).style("display","none")):(vt(this._button).style("display","none"),vt(this._container).selectAll("svg").style("display","block"),vt(this._closeButton).style("display","block")),this._showState=!this._showState,"function"==typeof this.options.expandCallback&&this.options.expandCallback(this._showState)},_removeChart:function(){void 0!==this._svg&&(this._svg.selectAll("path.area").remove(),this._svg.selectAll("path.border-top").remove(),this._svg.selectAll(".legend").remove(),this._svg.selectAll(".lineSelection").remove(),this._svg.selectAll(".horizontalLine").remove(),this._svg.selectAll(".horizontalLineText").remove())},_randomNumber:function(t){return Math.round(Math.random()*(t-0))},_d3ColorCategorical:[hi,ci,di,li,pi,fi],_prepareData:function(){this._coordinates=[],this._elevations=[],this._cumulatedDistances=[],this._cumulatedDistances.push(0),this._categories=[];var n,e=this._data;if(void 0===this._mappings){var r=this._randomNumber(this._d3ColorCategorical.length-1);n=function t(){var n=Nr(),e=[],r=[],i=Fr;function o(t){var o=t+"",a=n.get(o);if(!a){if(i!==Fr)return i;n.set(o,a=e.push(t))}return r[(a-1)%r.length]}return o.domain=function(t){if(!arguments.length)return e.slice();e=[],n=Nr();for(var r,i,a=-1,s=t.length;++a<s;)n.has(i=(r=t[a])+"")||n.set(i,e.push(r));return o},o.range=function(t){return arguments.length?(r=Dr.call(t),o):r.slice()},o.unknown=function(t){return arguments.length?(i=t,o):i},o.copy=function(){return t(e,r).unknown(i)},Sr.apply(o,arguments),o}(this._d3ColorCategorical[r])}for(var i=0;i<e.length;i++){var o=0;this._categories[i]={info:{id:i,text:e[i].properties.label||e[i].properties.summary},distances:[],attributes:[],geometries:[],legend:{}};var a=void 0,s=0,u={},l=void 0!==this._mappings&&"function"==typeof this._mappings[e[i].properties.summary];for(a=0;a<e[i].features.length;a++){var h=void 0,c=void 0,f=void 0,d=[],p=e[i].features[a].geometry.coordinates.length,g=e[i].features[a].properties.attributeType,_=void 0,v=void 0;if(void 0===this._mappings)g in u?(_=g,v=u[g]):(_=g,v=n(a),u[g]=v);else if(l){var y=this._mappings[e[i].properties.summary](g);_=y.text,v=y.color}else _=this._mappings[e[i].properties.summary][g].text,v=this._mappings[e[i].properties.summary][g].color;var m={type:g,text:_,color:v};this._categories[i].attributes.push(m),g in this._categories[i].legend||(this._categories[i].legend[g]=m);for(var x=0;x<p;x++){c=new t.LatLng(e[i].features[a].geometry.coordinates[x][1],e[i].features[a].geometry.coordinates[x][0]),h=e[i].features[a].geometry.coordinates[x][2],x<p-1?(f=new t.LatLng(e[i].features[a].geometry.coordinates[x+1][1],e[i].features[a].geometry.coordinates[x+1][0]),o+=c.distanceTo(f)/1e3,0===i&&(this._elevations.push(h),this._coordinates.push(c),this._cumulatedDistances.push(o)),s+=1):x===p-1&&a===e[i].features.length-1&&(0===i&&(this._elevations.push(h),this._coordinates.push(f)),s+=1);var w=void 0;w=x===p-1&&a<e[i].features.length-1?this._cumulatedDistances[s]:this._cumulatedDistances[s-1],d.push({altitude:h,position:w,x:c.lng,y:c.lat,latlng:c,type:_,areaIdx:a})}this._categories[i].distances.push(o),this._categories[i].geometries.push(d)}i===e.length-1&&(this._totalDistance=o)}},_calculateElevationBounds:function(){var t=or(this._elevations),n=function(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&r>e&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&r>e&&(r=e);return r}(this._elevations),e=t-n;this._elevationBounds={min:e<10?n-10:n-.1*e,max:e<10?t+10:t+.1*e}},_showMapMarker:function(t,n,e){var r=this._map.latLngToLayerPoint(t),i=r.y-75;if(!this._mouseHeightFocus){var o=vt(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=o.append("svg:line").attr("class","height-focus line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._mouseHeightFocusLabel=o.append("g").attr("class","height-focus label"),this._mouseHeightFocusLabelRect=this._mouseHeightFocusLabel.append("rect").attr("class","bBox"),this._mouseHeightFocusLabelTextElev=this._mouseHeightFocusLabel.append("text").attr("class","tspan"),this._mouseHeightFocusLabelTextType=this._mouseHeightFocusLabel.append("text").attr("class","tspan"),(this._pointG=o.append("g").attr("class","height-focus circle")).append("svg:circle").attr("r",5).attr("cx",0).attr("cy",0).attr("class","height-focus circle-lower")}this._mouseHeightFocusLabel.style("display","block"),this._mouseHeightFocus.attr("x1",r.x).attr("x2",r.x).attr("y1",r.y).attr("y2",i).style("display","block"),this._pointG.attr("transform","translate("+r.x+","+r.y+")").style("display","block"),this._mouseHeightFocusLabelRect.attr("x",r.x+3).attr("y",i).attr("class","bBox"),this._mouseHeightFocusLabelTextElev.attr("x",r.x+5).attr("y",i+12).text((3.281*n).toFixed(0)+" ft").attr("class","tspan mouse-height-box-text"),this._mouseHeightFocusLabelTextType.attr("x",r.x+5).attr("y",i+24).text(e).attr("class","tspan mouse-height-box-text");var a=this._dynamicBoxSize("text.tspan")[1],s=""===e?18:30;wt(".bBox").attr("width",a+10).attr("height",s)},_createChart:function(t){var n=0===this._categories.length?[]:this._categories[t].geometries;this._areasFlattended=[].concat.apply([],n);for(var e=0;e<n.length;e++)this._appendAreas(n[e],t,e);this._createFocus(),this._appendBackground(),this._createBorderTopLine(),this._createLegend(),this._createHorizontalLine()},_createFocus:function(){var t=this._elevationBounds.min;this._focus&&(this._focus.remove(),this._focusLineGroup.remove()),this._focus=this._svg.append("g").attr("class","focusbox"),this._focusRect=this._focus.append("rect").attr("x",3).attr("y",-this._y(t)).attr("display","none"),this._focusDistance=this._focus.append("text").attr("x",7).attr("y",15-this._y(t)).attr("id","heightgraph.distance").text(this._getTranslation("distance")+":"),this._focusHeight=this._focus.append("text").attr("x",7).attr("y",30-this._y(t)).attr("id","heightgraph.height").text(this._getTranslation("elevation")+":"),this._focusBlockDistance=this._focus.append("text").attr("x",7).attr("y",45-this._y(t)).attr("id","heightgraph.blockdistance").text(this._getTranslation("segment_length")+":"),this._focusType=this._focus.append("text").attr("x",7).attr("y",60-this._y(t)).attr("id","heightgraph.type").text(this._getTranslation("type")+":"),this._areaTspan=this._focusBlockDistance.append("tspan").attr("class","tspan"),this._typeTspan=this._focusType.append("tspan").attr("class","tspan");var n=this._dynamicBoxSize(".focusbox text")[0];wt(".focusbox rect").attr("height",15*n+7.5).attr("display","block"),this._focusLineGroup=this._svg.append("g").attr("class","focusLine"),this._focusLine=this._focusLineGroup.append("line").attr("y1",0).attr("y2",this._y(this._elevationBounds.min)),this._distTspan=this._focusDistance.append("tspan").attr("class","tspan"),this._altTspan=this._focusHeight.append("tspan").attr("class","tspan")},_createHorizontalLine:function(){var t=this;this._horizontalLine=this._svg.append("line").attr("class","horizontalLine").attr("x1",0).attr("x2",this._width-this._margin.left-this._margin.right).attr("y1",this._y(this._elevationBounds.min)).attr("y2",this._y(this._elevationBounds.min)).style("stroke","black"),this._elevationValueText=this._svg.append("text").attr("class","horizontalLineText").attr("x",this._width-this._margin.left-this._margin.right-20).attr("y",this._y(this._elevationBounds.min)-10).attr("fill","black");var n=[{x:this._width-this._margin.left-this._margin.right+7,y:this._y(this._elevationBounds.min),color:"black",type:wr,angle:-90,size:100}];this._svg.selectAll(".horizontal-symbol").data(n).enter().append("path").attr("class","lineSelection").attr("d",br().type((function(t){return t.type})).size((function(t){return t.size}))).attr("transform",(function(t){return"translate("+t.x+","+t.y+") rotate("+t.angle+")"})).attr("id",(function(t){return t.id})).style("fill",(function(t){return t.color})).call(ki().on("start",(function(t){vt(this).raise().classed("active",!0),vt(".horizontalLine").raise().classed("active",!0)})).on("drag",(function(n){var e=t._svgHeight,r=xt(t._container)[1]-10;vt(this).attr("transform",(function(t){return"translate("+t.x+","+(r<0?0:r>e?e:r)+") rotate("+t.angle+")"})),vt(".horizontalLine").attr("y1",r<0?0:r>e?e:r).attr("y2",r<0?0:r>e?e:r),t._highlightedCoords=r>=e?[]:t._findCoordsForY(r),vt(".horizontalLineText").attr("y",r<=10?0:r>e?e-10:r-10).text(ti(".0f")((3.281*t._y.invert(r<0?0:r>e?e:r)).toFixed(0))+" ft"),t._removeMarkedSegmentsOnMap(),t._markSegmentsOnMap(t._highlightedCoords)})).on("end",(function(n){vt(this).classed("active",!1),vt(".horizontalLine").classed("active",!1),t._removeMarkedSegmentsOnMap(),t._markSegmentsOnMap(t._highlightedCoords)})))},_markSegmentsOnMap:function(n){if(n)if(n.length>1){this._markedSegments=t.featureGroup();var e,i=o(n);try{for(i.s();!(e=i.n()).done;){var a=e.value;t.polyline(a,r(r({},this._highlightStyle),{interactive:!1})).addTo(this._markedSegments)}}catch(t){i.e(t)}finally{i.f()}this._markedSegments.addTo(this._map).bringToFront()}else this._markedSegments=t.polyline(n,this._highlightStyle).addTo(this._map)},_removeMarkedSegmentsOnMap:function(){void 0!==this._markedSegments&&this._map.removeLayer(this._markedSegments)},_appendScales:function(){var t=Boolean(this._totalDistance<=10);this._x=si().range([0,this._svgWidth]),this._y=si().range([this._svgHeight,0]),this._x.domain([0,this._totalDistance]),this._y.domain([this._elevationBounds.min,this._elevationBounds.max]),this._xAxis=Ze().scale(this._x),!0===t?this._xAxis.tickFormat((function(t){return ti(".2f")(t/1.852)+" nm"})):this._xAxis.tickFormat((function(t){return ti(".0f")(t/1.852)+" nm"})),this._xAxis.ticks(this.options.xTicks?Math.pow(2,this.options.xTicks):Math.round(this._svgWidth/75),"s"),this._yAxis=Ke().scale(this._y).tickFormat((function(t){return(3.281*t).toFixed(0)+" ft"})),this._yAxis.ticks(this.options.yTicks?Math.pow(2,this.options.yTicks):Math.round(this._svgHeight/30),"s")},_appendBackground:function(){var n=this._background=vt(this._container).select("svg").select("g").append("rect").attr("width",this._svgWidth).attr("height",this._svgHeight).style("fill","none").style("stroke","none").style("pointer-events","all").on("mousemove.focusbox",this._mousemoveHandler.bind(this)).on("mouseout.focusbox",this._mouseoutHandler.bind(this));t.Browser.android?(n.on("touchstart.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focusbox",this._mousemoveHandler.bind(this)),t.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(n.on("mousemove.focusbox",this._mousemoveHandler.bind(this)).on("mouseout.focusbox",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),t.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this))},_appendGrid:function(){this._svg.append("g").attr("class","grid").attr("transform","translate(0,"+this._svgHeight+")").call(this._make_x_axis().tickSize(-this._svgHeight,0,0).ticks(Math.round(this._svgWidth/75)).tickFormat("")),this._svg.append("g").attr("class","grid").call(this._make_y_axis().tickSize(-this._svgWidth,0,0).ticks(Math.round(this._svgHeight/30)).tickFormat("")),this._svg.append("g").attr("transform","translate(0,"+this._svgHeight+")").attr("class","x axis").call(this._xAxis),this._svg.append("g").attr("transform","translate(-2,0)").attr("class","y axis").call(this._yAxis)},_appendAreas:function(t,n,e){var r=this._categories[n].attributes[e].color,i=this;this._area=function(){var t=_r,n=null,e=cr(0),r=vr,i=cr(!0),o=null,a=gr,s=null;function u(u){var l,h,c,f,d,p=u.length,g=!1,_=new Array(p),v=new Array(p);for(null==o&&(s=a(d=hr())),l=0;l<=p;++l){if(!(l<p&&i(f=u[l],l,u))===g)if(g=!g)h=l,s.areaStart(),s.lineStart();else{for(s.lineEnd(),s.lineStart(),c=l-1;c>=h;--c)s.point(_[c],v[c]);s.lineEnd(),s.areaEnd()}g&&(_[l]=+t(f,l,u),v[l]=+e(f,l,u),s.point(n?+n(f,l,u):_[l],r?+r(f,l,u):v[l]))}if(d)return s=null,d+""||null}function l(){return yr().defined(i).curve(a).context(o)}return u.x=function(e){return arguments.length?(t="function"==typeof e?e:cr(+e),n=null,u):t},u.x0=function(n){return arguments.length?(t="function"==typeof n?n:cr(+n),u):t},u.x1=function(t){return arguments.length?(n=null==t?null:"function"==typeof t?t:cr(+t),u):n},u.y=function(t){return arguments.length?(e="function"==typeof t?t:cr(+t),r=null,u):e},u.y0=function(t){return arguments.length?(e="function"==typeof t?t:cr(+t),u):e},u.y1=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:cr(+t),u):r},u.lineX0=u.lineY0=function(){return l().x(t).y(e)},u.lineY1=function(){return l().x(t).y(r)},u.lineX1=function(){return l().x(n).y(e)},u.defined=function(t){return arguments.length?(i="function"==typeof t?t:cr(!!t),u):i},u.curve=function(t){return arguments.length?(a=t,null!=o&&(s=a(o)),u):a},u.context=function(t){return arguments.length?(null==t?o=s=null:s=a(o=t),u):o},u}().x((function(t){var n=i._x(t.position);return t.xDiagonalCoordinate=n,n})).y0(this._svgHeight).y1((function(t){return i._y(t.altitude)})).curve(gr);this._areapath=this._svg.append("path").attr("class","area"),this._areapath.datum(t).attr("d",this._area).attr("stroke",r).styles(this._graphStyle).style("fill",r).style("pointer-events","none")},_make_x_axis:function(){return Ze().scale(this._x)},_make_y_axis:function(){return Ke().scale(this._y)},_createSelectionBox:function(){var t=this,n=vt(this._container).select("svg"),e=this._width-this._margin.right,r=this._height-this._margin.bottom+this._margin.bottom/2+6,i=[{x:e-25,y:r+3,color:"#000",type:wr,id:"leftArrowSelection",angle:0},{x:e-10,y:r,color:"#000",type:wr,id:"rightArrowSelection",angle:180}],o=n.selectAll(".select-symbol").data(i);o.remove(),o=n.selectAll(".select-symbol").data(i),t._data.length>1&&o.enter().append("path").merge(o).attr("class","select-symbol").attr("d",br().type((function(t){return t.type}))).attr("transform",(function(t){return"translate("+t.x+","+t.y+") rotate("+t.angle+")"})).attr("id",(function(t){return t.id})).style("fill",(function(t){return t.color})).on("mousedown",(function(n){"rightArrowSelection"===n.id&&s(),"leftArrowSelection"===n.id&&u(),t._gotDragged=!0,t._dragStartCoords=t._dragCache.start,t._dragCurrentCoords=t._dragCache.end}));var a=function(i){if(t._selectionText&&t._selectionText.remove(),0!==t._categories.length){var o=t._categories[i].info;"function"==typeof t.options.chooseSelectionCallback&&t.options.chooseSelectionCallback(i,o);var a=[{selection:o.text}];t._selectionText=n.selectAll("selection_text").data(a).enter().append("text").attr("x",e-35).attr("y",r+4).text((function(t){return t.selection})).attr("class","select-info").attr("id","selectionText").attr("text-anchor","end")}};a(this.options.selectedAttributeIdx);var s=function(){var n=t.options.selectedAttributeIdx+=1;n===t._categories.length&&(t.options.selectedAttributeIdx=n=0),a(n),t._removeChart(),t._removeMarkedSegmentsOnMap(),t._createChart(n)},u=function(){var n=t.options.selectedAttributeIdx-=1;-1===n&&(t.options.selectedAttributeIdx=n=t._categories.length-1),a(n),t._removeChart(),t._removeMarkedSegmentsOnMap(),t._createChart(n)}},_createLegend:function(){var t=this,n=this,e=[];if(this._categories.length>0)for(var r in this._categories[this.options.selectedAttributeIdx].legend)e.push(this._categories[this.options.selectedAttributeIdx].legend[r]);var i=this._height-this._margin.bottom,o=i+this._margin.bottom/2,a=[{text:this._getTranslation("legend")}],s=this._svg.selectAll(".hlegend-hover").data(e).enter().append("g").attr("class","legend").style("display","none").attr("transform",(function(t,n){return"translate(-8,"+(14*n-28)+")"})),u=s.append("rect").attr("class","legend-rect").attr("x",15).attr("y",36).attr("width",6).attr("height",6);0!==Object.keys(this._graphStyle).length?u.styles(this._graphStyle).style("stroke",(function(t,n){return t.color})).style("fill",(function(t,n){return t.color})):u.style("stroke","black").style("fill",(function(t,n){return t.color})),s.append("text").attr("class","legend-text").attr("x",30).attr("y",42).text((function(t,e){var r=t.text;return n._boxBoundY=(i-2*i/3+7)*e,r}));var l=this._svg.selectAll(".legend-hover").data(a).enter().append("g").attr("class","legend-hover");this._showLegend=!1,l.append("text").attr("x",15).attr("y",o).attr("text-anchor","start").text((function(t,n){return t.text})).on("mouseover",(function(){wt(".legend").style("display","block")})).on("mouseleave",(function(){t._showLegend||wt(".legend").style("display","none")})).on("click",(function(){t._showLegend=!t._showLegend}))},_dynamicBoxSize:function(t){for(var n=wt(t).nodes().length,e=[],r=0;r<n;r++)e.push(wt(t).nodes()[r].getBoundingClientRect().width);return[n,or(e)]},_createBorderTopLine:function(){var t=this,n=this._areasFlattended,e=yr().x((function(n){return(0,t._x)(n.position)})).y((function(n){return(0,t._y)(n.altitude)})).curve(Ar);this._svg.append("svg:path").attr("d",e(n)).attr("class","border-top")},_mouseoutHandler:function(){for(var t=0,n=["_focusLine","_focus","_pointG","_mouseHeightFocus","_mouseHeightFocusLabel"];t<n.length;t++){var e=n[t];this[e]&&this[e].style("display","none")}},mapMouseoutHandler:function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;this.mouseoutDelay&&window.clearTimeout(this.mouseoutDelay),this.mouseoutDelay=window.setTimeout((function(){t._mouseoutHandler()}),n)},mapMousemoveHandler:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},e=n.showMapMarker,r=void 0===e||e;if(!1!==this._areasFlattended){var i,a=null,s=2*Math.pow(100,2),u=1.1/111111,l=o(this._areasFlattended);try{for(l.s();!(i=l.n()).done;){var h=i.value,c=t.latlng.lat-h.latlng.lat,f=t.latlng.lng-h.latlng.lng;if(Math.abs(c)<u&&Math.abs(f)<u){this._internalMousemoveHandler(h,r);break}var d=Math.pow(c,2)+Math.pow(f,2);d<s&&(a=h,s=d)}}catch(t){l.e(t)}finally{l.f()}a&&this._internalMousemoveHandler(a,r)}},_mousemoveHandler:function(t,n,e){var r=xt(this._svg.node()),i=this._areasFlattended[this._findItemForX(r[0])];i&&this._internalMousemoveHandler(i)},_internalMousemoveHandler:function(t){var n,e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t.altitude,i=t.position,o=t.latlng,a=t.areaIdx,s=t.type,u=this._dynamicBoxSize(".focusbox text")[1]+10;n=0===a?this._categories[this.options.selectedAttributeIdx].distances[a]:this._categories[this.options.selectedAttributeIdx].distances[a]-this._categories[this.options.selectedAttributeIdx].distances[a-1],e&&this._showMapMarker(o,r,s),this._distTspan.text(" "+(i/1.852).toFixed(1)+"nm"),this._altTspan.text(" "+(3.281*r).toFixed(0)+" ft"),this._areaTspan.text(" "+(n/1.852).toFixed(1)+" nm"),this._typeTspan.text(" "+s),this._focusRect.attr("width",u),this._focusLine.style("display","block").attr("x1",this._x(i)).attr("x2",this._x(i));var l=this._x(i)-(u+5),h=this._width-this._margin.left-this._margin.right;this._x(i)+u<h&&this._focus.style("display","initial").attr("transform","translate("+this._x(i)+","+this._y(this._elevationBounds.min)+")"),this._x(i)+u>h&&this._focus.style("display","initial").attr("transform","translate("+l+","+this._y(this._elevationBounds.min)+")")},_findItemForX:function(t){var n=Je((function(t){return t.position})).left,e=this._x.invert(t);return n(this._areasFlattended,e)},_findCoordsForY:function(t){var n=this._y.invert(t);return function(t,n){for(var e=[],r=0;r<t.length;r++)t[r].altitude>=n&&e.push(r);for(var i=[],o=0,a=0;a<e.length-1;a++)e[a+1]!==e[a]+1&&(i.push(e.slice(o,a+1)),o=a+1);i.push(e.slice(o,e.length));for(var s=0;s<i.length;s++)for(var u=0;u<i[s].length;u++)i[s][u]=t[i[s][u]].latlng;return i}(this._areasFlattended,n)},_getTranslation:function(t){return this.options.translation[t]?this.options.translation[t]:this._defaultTranslation[t]?this._defaultTranslation[t]:(console.error("Unexpected error when looking up the translation for "+t),"No translation found")}}),t.control.heightgraph=function(n){return new t.Control.Heightgraph(n)},t.Control.Heightgraph}),window)}();
\ No newline at end of file
diff --git a/src/L.Control.Heightgraph.js b/src/L.Control.Heightgraph.js
index 8079096d6dba6d906517de9c93294a5de1af7bf2..cb1066f095ce07a7b82ce4f113146fb09fe44f1e 100644
--- a/src/L.Control.Heightgraph.js
+++ b/src/L.Control.Heightgraph.js
@@ -1,1169 +1,1338 @@
-import { select, selectAll, mouse } from 'd3-selection'
-import 'd3-selection-multi'
-import { scaleOrdinal, scaleLinear } from 'd3-scale'
-import { min as d3Min, max as d3Max, bisector } from 'd3-array'
-import { drag } from 'd3-drag'
-import { axisLeft, axisBottom } from 'd3-axis'
-import { format } from 'd3-format'
-import { curveBasis, curveLinear, line, area as d3Area, symbol, symbolTriangle } from 'd3-shape'
+import "d3-selection-multi";
+
+import { axisBottom, axisLeft } from "d3-axis";
+import { bisector, max as d3Max, min as d3Min } from "d3-array";
 import {
-    schemeAccent,
-    schemeDark2,
-    schemeSet2,
-    schemeCategory10,
-    schemeSet3,
-    schemePaired
-} from 'd3-scale-chromatic'
-(function (factory, window) {
+  curveBasis,
+  curveLinear,
+  area as d3Area,
+  line,
+  symbol,
+  symbolTriangle,
+} from "d3-shape";
+import { mouse, select, selectAll } from "d3-selection";
+import { scaleLinear, scaleOrdinal } from "d3-scale";
+import {
+  schemeAccent,
+  schemeCategory10,
+  schemeDark2,
+  schemePaired,
+  schemeSet2,
+  schemeSet3,
+} from "d3-scale-chromatic";
 
-    // define an AMD module that relies on 'leaflet'
-    if (typeof define === 'function' && define.amd) {
-        define(['leaflet'], factory);
+import { drag } from "d3-drag";
+import { format } from "d3-format";
 
-        // define a Common JS module that relies on 'leaflet'
-    } else if (typeof exports === 'object') {
-        if (typeof window !== 'undefined' && window.L) {
-            module.exports = factory(L);
-        } else {
-            module.exports = factory(require('leaflet'));
-        }
-    }
+(function (factory, window) {
+  // define an AMD module that relies on 'leaflet'
+  if (typeof define === "function" && define.amd) {
+    define(["leaflet"], factory);
 
-    // attach your plugin to the global 'L' variable
-    if (typeof window !== 'undefined' && window.L) {
-        window.L.Control.Heightgraph = factory(L);
+    // define a Common JS module that relies on 'leaflet'
+  } else if (typeof exports === "object") {
+    if (typeof window !== "undefined" && window.L) {
+      module.exports = factory(L);
+    } else {
+      module.exports = factory(require("leaflet"));
     }
-}(function (L) {
-    L.Control.Heightgraph = L.Control.extend({
-        options: {
-            position: "bottomright",
-            width: 800,
-            height: 280,
-            margins: {
-                top: 10,
-                right: 30,
-                bottom: 55,
-                left: 50
-            },
-            mappings: undefined,
-            expand: true,
-            expandControls: true,
-            translation: {},
-            expandCallback: undefined,
-            chooseSelectionCallback: undefined,
-            selectedAttributeIdx: 0,
-            xTicks: undefined,
-            yTicks: undefined,
-            highlightStyle: undefined,
-            graphStyle: undefined
-        },
-        _defaultTranslation: {
-            distance: "Distance",
-            elevation: "Elevation",
-            segment_length: "Segment length",
-            type: "Type",
-            legend: "Legend"
-        },
-        _init_options() {
-            this._margin = this.options.margins;
-            this._width = this.options.width;
-            this._height = this.options.height;
-            this._mappings = this.options.mappings;
-            this._svgWidth = this._width - this._margin.left - this._margin.right;
-            this._svgHeight = this._height - this._margin.top - this._margin.bottom;
-            this._highlightStyle = this.options.highlightStyle || { color: 'red' }
-            this._graphStyle = this.options.graphStyle || {}
-            this._dragCache = {}
-        },
-        onAdd(map) {
-            let container = this._container = L.DomUtil.create("div", "heightgraph")
-            L.DomEvent.disableClickPropagation(container);
-            if (this.options.expandControls) {
-                let buttonContainer = this._button = L.DomUtil.create('div', "heightgraph-toggle", container);
-                const link = L.DomUtil.create("a", "heightgraph-toggle-icon", buttonContainer)
-                const closeButton = this._closeButton = L.DomUtil.create("a", "heightgraph-close-icon", container)
-            }
-            this._showState = false;
-            this._initToggle();
-            this._init_options();
-            // Note: this._svg really contains the <g> inside the <svg>
-            this._svg = select(this._container).append("svg").attr("class", "heightgraph-container")
-                .attr("width", this._width)
-                .attr("height", this._height).append("g")
-                .attr("transform", "translate(" + this._margin.left + "," + this._margin.top + ")")
-            if (this.options.expand) this._expand();
-            return container;
-        },
-        onRemove(map) {
-            this._removeMarkedSegmentsOnMap();
-            this._container = null;
-            this._svg = undefined;
-        },
-        /**
-         * add Data from geoJson and call all functions
-         * @param {Object} data
-         */
-        addData(data) {
-            this._addData(data)
-        }, /**
-         * Internal function. Overloads public addData().
-         * Call with resize = true when resizing instead of actually adding data.
-         * TODO: this should be refactored to avoid calling addData on resize
-         * @param data
-         * @param resize
-         * @private
-         */
-        _addData(data) {
-            if (this._svg !== undefined) {
-                this._svg.selectAll("*")
-                    .remove();
-            }
-            if (!data || this.options.selectedAttributeIdx >= data.length) {
-                this.options.selectedAttributeIdx = 0;
-            }
-            this._removeMarkedSegmentsOnMap();
-            this._resetDrag(true);
+  }
 
-            this._data = data;
-            this._init_options();
-            this._prepareData();
-            this._calculateElevationBounds();
-            this._appendScales();
-            this._appendGrid();
-            if (Object.keys(data).length !== 0) {
-                this._createChart(this.options.selectedAttributeIdx);
-            }
-            this._createSelectionBox();
-        },
-        resize(size) {
-            if (size.width)
-                this.options.width = size.width;
-            if (size.height)
-                this.options.height = size.height;
+  // attach your plugin to the global 'L' variable
+  if (typeof window !== "undefined" && window.L) {
+    window.L.Control.Heightgraph = factory(L);
+  }
+})(function (L) {
+  L.Control.Heightgraph = L.Control.extend({
+    options: {
+      position: "bottomright",
+      width: 800,
+      height: 280,
+      margins: {
+        top: 10,
+        right: 30,
+        bottom: 55,
+        left: 50,
+      },
+      mappings: undefined,
+      expand: true,
+      expandControls: true,
+      translation: {},
+      expandCallback: undefined,
+      chooseSelectionCallback: undefined,
+      selectedAttributeIdx: 0,
+      xTicks: undefined,
+      yTicks: undefined,
+      highlightStyle: undefined,
+      graphStyle: undefined,
+    },
+    _defaultTranslation: {
+      distance: "Distance",
+      elevation: "Elevation",
+      segment_length: "Segment length",
+      type: "Type",
+      legend: "Legend",
+    },
+    _init_options() {
+      this._margin = this.options.margins;
+      this._width = this.options.width;
+      this._height = this.options.height;
+      this._mappings = this.options.mappings;
+      this._svgWidth = this._width - this._margin.left - this._margin.right;
+      this._svgHeight = this._height - this._margin.top - this._margin.bottom;
+      this._highlightStyle = this.options.highlightStyle || { color: "red" };
+      this._graphStyle = this.options.graphStyle || {};
+      this._dragCache = {};
+    },
+    onAdd(map) {
+      let container = (this._container = L.DomUtil.create(
+        "div",
+        "heightgraph"
+      ));
+      L.DomEvent.disableClickPropagation(container);
+      if (this.options.expandControls) {
+        let buttonContainer = (this._button = L.DomUtil.create(
+          "div",
+          "heightgraph-toggle",
+          container
+        ));
+        const link = L.DomUtil.create(
+          "a",
+          "heightgraph-toggle-icon",
+          buttonContainer
+        );
+        const closeButton = (this._closeButton = L.DomUtil.create(
+          "a",
+          "heightgraph-close-icon",
+          container
+        ));
+      }
+      this._showState = false;
+      this._initToggle();
+      this._init_options();
+      // Note: this._svg really contains the <g> inside the <svg>
+      this._svg = select(this._container)
+        .append("svg")
+        .attr("class", "heightgraph-container")
+        .attr("width", this._width)
+        .attr("height", this._height)
+        .append("g")
+        .attr(
+          "transform",
+          "translate(" + this._margin.left + "," + this._margin.top + ")"
+        );
+      if (this.options.expand) this._expand();
+      return container;
+    },
+    onRemove(map) {
+      this._removeMarkedSegmentsOnMap();
+      this._container = null;
+      this._svg = undefined;
+    },
+    /**
+     * add Data from geoJson and call all functions
+     * @param {Object} data
+     */
+    addData(data) {
+      this._addData(data);
+    },
+    /**
+     * Internal function. Overloads public addData().
+     * Call with resize = true when resizing instead of actually adding data.
+     * TODO: this should be refactored to avoid calling addData on resize
+     * @param data
+     * @param resize
+     * @private
+     */ _addData(data) {
+      if (this._svg !== undefined) {
+        this._svg.selectAll("*").remove();
+      }
+      if (!data || this.options.selectedAttributeIdx >= data.length) {
+        this.options.selectedAttributeIdx = 0;
+      }
+      this._removeMarkedSegmentsOnMap();
+      this._resetDrag(true);
 
-            // Resize the <svg> along with its container
-            select(this._container).selectAll("svg")
-                .attr("width", this.options.width)
-                .attr("height", this.options.height);
+      this._data = data;
+      this._init_options();
+      this._prepareData();
+      this._calculateElevationBounds();
+      this._appendScales();
+      this._appendGrid();
+      if (Object.keys(data).length !== 0) {
+        this._createChart(this.options.selectedAttributeIdx);
+      }
+      this._createSelectionBox();
+    },
+    resize(size) {
+      if (size.width) this.options.width = size.width;
+      if (size.height) this.options.height = size.height;
 
-            // Re-add the data to redraw the chart.
-            this._addData(this._data);
-        },
-        _initToggle() {
-            if (!L.Browser.touch) {
-                L.DomEvent.disableClickPropagation(this._container);
+      // Resize the <svg> along with its container
+      select(this._container)
+        .selectAll("svg")
+        .attr("width", this.options.width)
+        .attr("height", this.options.height);
+
+      // Re-add the data to redraw the chart.
+      this._addData(this._data);
+    },
+    _initToggle() {
+      if (!L.Browser.touch) {
+        L.DomEvent.disableClickPropagation(this._container);
+      } else {
+        L.DomEvent.on(this._container, "click", L.DomEvent.stopPropagation);
+      }
+      if (this.options.expandControls) {
+        L.DomEvent.on(this._button, "click", this._expand, this);
+        L.DomEvent.on(this._closeButton, "click", this._expand, this);
+      }
+    },
+    _dragHandler() {
+      //we don´t want map events to occur here
+      if (typeof event !== "undefined") {
+        event.preventDefault();
+        event.stopPropagation();
+      }
+      this._gotDragged = true;
+      this._drawDragRectangle();
+    },
+    /**
+     * Draws the currently dragged rectangle over the chart.
+     */
+    _drawDragRectangle() {
+      if (!this._dragStartCoords) {
+        return;
+      }
+      const dragEndCoords = (this._dragCurrentCoords = this._dragCache.end = mouse(
+        this._background.node()
+      ));
+      const x1 = Math.min(this._dragStartCoords[0], dragEndCoords[0]),
+        x2 = Math.max(this._dragStartCoords[0], dragEndCoords[0]);
+      if (!this._dragRectangle && !this._dragRectangleG) {
+        const g = select(this._container).select("svg").select("g");
+        this._dragRectangleG = g.append("g");
+        this._dragRectangle = this._dragRectangleG
+          .append("rect")
+          .attr("width", x2 - x1)
+          .attr("height", this._svgHeight)
+          .attr("x", x1)
+          .attr("class", "mouse-drag")
+          .style("fill", "grey")
+          .style("opacity", 0.5)
+          .style("pointer-events", "none");
+      } else {
+        this._dragRectangle.attr("width", x2 - x1).attr("x", x1);
+      }
+    },
+    /**
+     * Removes the drag rectangle
+     * @param {boolean} skipMapFitBounds - whether to zoom the map back to the total extent of the data
+     */
+    _resetDrag(skipMapFitBounds) {
+      if (this._dragRectangleG) {
+        this._dragRectangleG.remove();
+        this._dragRectangleG = null;
+        this._dragRectangle = null;
+
+        if (skipMapFitBounds !== true) {
+          // potential performance improvement:
+          // we could cache the full extend when addData() is called
+          let fullExtent = this._calculateFullExtent(this._areasFlattended);
+          if (fullExtent) this._map.fitBounds(fullExtent);
+        }
+      }
+    },
+    /**
+     * Handles end of drag operations. Zooms the map to the selected items extent.
+     */
+    _dragEndHandler() {
+      if (!this._dragStartCoords || !this._gotDragged) {
+        this._dragStartCoords = null;
+        this._gotDragged = false;
+        this._resetDrag();
+        return;
+      }
+      const item1 = this._findItemForX(this._dragStartCoords[0]),
+        item2 = this._findItemForX(this._dragCurrentCoords[0]);
+      this._fitSection(item1, item2);
+      this._dragStartCoords = null;
+      this._gotDragged = false;
+    },
+    _dragStartHandler() {
+      event.preventDefault();
+      event.stopPropagation();
+      this._gotDragged = false;
+      this._dragStartCoords = this._dragCache.start = mouse(
+        this._background.node()
+      );
+    },
+    /*
+     * Calculates the full extent of the data array
+     */
+    _calculateFullExtent(data) {
+      if (!data || data.length < 1) {
+        return null;
+      }
+      let full_extent = new L.latLngBounds(data[0].latlng, data[0].latlng);
+      data.forEach((item) => {
+        if (!full_extent.contains(item.latlng)) {
+          full_extent.extend(item.latlng);
+        }
+      });
+      return full_extent;
+    },
+    /**
+     * Make the map fit the route section between given indexes.
+     */
+    _fitSection(index1, index2) {
+      const start = Math.min(index1, index2),
+        end = Math.max(index1, index2);
+      let ext;
+      if (start !== end) {
+        ext = this._calculateFullExtent(
+          this._areasFlattended.slice(start, end + 1)
+        );
+      } else if (this._areasFlattended.length > 0) {
+        ext = [
+          this._areasFlattended[start].latlng,
+          this._areasFlattended[end].latlng,
+        ];
+      }
+      if (ext) this._map.fitBounds(ext);
+    },
+    /**
+     * Expand container when button clicked and shrink when close-Button clicked
+     */
+    _expand() {
+      if (this.options.expandControls !== true) {
+        // always expand, never collapse
+        this._showState = false;
+      }
+      if (!this._showState) {
+        select(this._button).style("display", "none");
+        select(this._container).selectAll("svg").style("display", "block");
+        select(this._closeButton).style("display", "block");
+      } else {
+        select(this._button).style("display", "block");
+        select(this._container).selectAll("svg").style("display", "none");
+        select(this._closeButton).style("display", "none");
+      }
+      this._showState = !this._showState;
+      if (typeof this.options.expandCallback === "function") {
+        this.options.expandCallback(this._showState);
+      }
+    },
+    /**
+     * Removes the svg elements from the d3 chart
+     */
+    _removeChart() {
+      if (this._svg !== undefined) {
+        // remove areas
+        this._svg.selectAll("path.area").remove();
+        // remove top border
+        this._svg.selectAll("path.border-top").remove();
+        // remove legend
+        this._svg.selectAll(".legend").remove();
+        // remove horizontal Line
+        this._svg.selectAll(".lineSelection").remove();
+        this._svg.selectAll(".horizontalLine").remove();
+        this._svg.selectAll(".horizontalLineText").remove();
+      }
+    },
+    /**
+     * Creates a random int between 0 and max
+     */
+    _randomNumber: (max) => Math.round(Math.random() * (max - 0)),
+    _d3ColorCategorical: [
+      schemeAccent,
+      schemeDark2,
+      schemeSet2,
+      schemeCategory10,
+      schemeSet3,
+      schemePaired,
+    ],
+    /**
+     * Prepares the data needed for the height graph
+     */ _prepareData() {
+      this._coordinates = [];
+      this._elevations = [];
+      this._cumulatedDistances = [];
+      this._cumulatedDistances.push(0);
+      this._categories = [];
+      const data = this._data;
+      let colorScale;
+      if (this._mappings === undefined) {
+        const randomNumber = this._randomNumber(
+          this._d3ColorCategorical.length - 1
+        );
+        colorScale = scaleOrdinal(this._d3ColorCategorical[randomNumber]);
+      }
+      for (let y = 0; y < data.length; y++) {
+        let cumDistance = 0;
+        this._categories[y] = {
+          info: {
+            id: y,
+            text: data[y].properties.label || data[y].properties.summary,
+          },
+          distances: [],
+          attributes: [],
+          geometries: [],
+          legend: {},
+        };
+        let i,
+          cnt = 0;
+        const usedColors = {};
+        const isMappingFunction =
+          this._mappings !== undefined &&
+          typeof this._mappings[data[y].properties.summary] === "function";
+        for (i = 0; i < data[y].features.length; i++) {
+          // data is redundant in every element of data which is why we collect it once
+          let altitude, ptA, ptB, ptDistance;
+          const geometry = [];
+          const coordsLength = data[y].features[i].geometry.coordinates.length;
+          // save attribute types related to blocks
+          const attributeType = data[y].features[i].properties.attributeType;
+          // check if mappings are defined, otherwise random colors
+          let text, color;
+          if (this._mappings === undefined) {
+            if (attributeType in usedColors) {
+              text = attributeType;
+              color = usedColors[attributeType];
             } else {
-                L.DomEvent.on(this._container, 'click', L.DomEvent.stopPropagation);
+              text = attributeType;
+              color = colorScale(i);
+              usedColors[attributeType] = color;
             }
-            if (this.options.expandControls) {
-                L.DomEvent.on(this._button, 'click', this._expand, this);
-                L.DomEvent.on(this._closeButton, 'click', this._expand, this);
-            }
-        },
-        _dragHandler() {
-            //we don´t want map events to occur here
-            if (typeof event !== 'undefined') {
-                event.preventDefault();
-                event.stopPropagation();
-            }
-            this._gotDragged = true;
-            this._drawDragRectangle();
-        },
-        /**
-         * Draws the currently dragged rectangle over the chart.
-         */
-        _drawDragRectangle() {
-            if (!this._dragStartCoords) {
-                return;
-            }
-            const dragEndCoords = this._dragCurrentCoords = this._dragCache.end = mouse(this._background.node())
-            const x1 = Math.min(this._dragStartCoords[0], dragEndCoords[0]),
-                x2 = Math.max(this._dragStartCoords[0], dragEndCoords[0])
-            if (!this._dragRectangle && !this._dragRectangleG) {
-                const g = select(this._container).select("svg").select("g")
-                this._dragRectangleG = g.append("g");
-                this._dragRectangle = this._dragRectangleG.append("rect")
-                    .attr("width", x2 - x1)
-                    .attr("height", this._svgHeight)
-                    .attr("x", x1)
-                    .attr('class', 'mouse-drag')
-                    .style("fill", "grey")
-                    .style("opacity", 0.5)
-                    .style("pointer-events", "none");
+          } else {
+            if (isMappingFunction) {
+              const result = this._mappings[data[y].properties.summary](
+                attributeType
+              );
+              text = result.text;
+              color = result.color;
             } else {
-                this._dragRectangle.attr("width", x2 - x1)
-                    .attr("x", x1);
+              text = this._mappings[data[y].properties.summary][attributeType]
+                .text;
+              color = this._mappings[data[y].properties.summary][attributeType]
+                .color;
             }
-        },
-        /**
-         * Removes the drag rectangle
-         * @param {boolean} skipMapFitBounds - whether to zoom the map back to the total extent of the data
-         */
-        _resetDrag(skipMapFitBounds) {
-            if (this._dragRectangleG) {
-                this._dragRectangleG.remove();
-                this._dragRectangleG = null;
-                this._dragRectangle = null;
-
-                if (skipMapFitBounds !== true) {
-                    // potential performance improvement:
-                    // we could cache the full extend when addData() is called
-                    let fullExtent = this._calculateFullExtent(this._areasFlattended);
-                    if (fullExtent) this._map.fitBounds(fullExtent);
-                }
+          }
+          const attribute = {
+            type: attributeType,
+            text: text,
+            color: color,
+          };
+          this._categories[y].attributes.push(attribute);
+          // add to legend
+          if (!(attributeType in this._categories[y].legend)) {
+            this._categories[y].legend[attributeType] = attribute;
+          }
+          for (let j = 0; j < coordsLength; j++) {
+            ptA = new L.LatLng(
+              data[y].features[i].geometry.coordinates[j][1],
+              data[y].features[i].geometry.coordinates[j][0]
+            );
+            altitude = data[y].features[i].geometry.coordinates[j][2];
+            // add elevations, coordinates and point distances only once
+            // last point in feature is first of next which is why we have to juggle with indices
+            if (j < coordsLength - 1) {
+              ptB = new L.LatLng(
+                data[y].features[i].geometry.coordinates[j + 1][1],
+                data[y].features[i].geometry.coordinates[j + 1][0]
+              );
+              ptDistance = ptA.distanceTo(ptB) / 1000;
+              // calculate distances of specific block
+              cumDistance += ptDistance;
+              if (y === 0) {
+                this._elevations.push(altitude);
+                this._coordinates.push(ptA);
+                this._cumulatedDistances.push(cumDistance);
+              }
+              cnt += 1;
+            } else if (
+              j === coordsLength - 1 &&
+              i === data[y].features.length - 1
+            ) {
+              if (y === 0) {
+                this._elevations.push(altitude);
+                this._coordinates.push(ptB);
+              }
+              cnt += 1;
             }
-        },
-        /**
-         * Handles end of drag operations. Zooms the map to the selected items extent.
-         */
-        _dragEndHandler() {
-            if (!this._dragStartCoords || !this._gotDragged) {
-                this._dragStartCoords = null;
-                this._gotDragged = false;
-                this._resetDrag();
-                return;
-            }
-            const item1 = this._findItemForX(this._dragStartCoords[0]),
-                item2 = this._findItemForX(this._dragCurrentCoords[0])
-            this._fitSection(item1, item2);
-            this._dragStartCoords = null;
-            this._gotDragged = false;
-        },
-        _dragStartHandler() {
-            event.preventDefault();
-            event.stopPropagation();
-            this._gotDragged = false;
-            this._dragStartCoords = this._dragCache.start = mouse(this._background.node());
-        },
-        /*
-         * Calculates the full extent of the data array
-         */
-        _calculateFullExtent(data) {
-            if (!data || data.length < 1) {
-                return null;
-            }
-            let full_extent = new L.latLngBounds(data[0].latlng, data[0].latlng);
-            data.forEach((item) => {
-                if (!full_extent.contains(item.latlng)) {
-                    full_extent.extend(item.latlng);
-                }
-            });
-            return full_extent;
-        },
-        /**
-         * Make the map fit the route section between given indexes.
-         */
-        _fitSection(index1, index2) {
-            const start = Math.min(index1, index2), end = Math.max(index1, index2)
-            let ext
-            if (start !== end) {
-                ext = this._calculateFullExtent(this._areasFlattended.slice(start, end + 1));
-            } else if (this._areasFlattended.length > 0) {
-                ext = [this._areasFlattended[start].latlng, this._areasFlattended[end].latlng];
-            }
-            if (ext) this._map.fitBounds(ext);
-        },
-        /**
-         * Expand container when button clicked and shrink when close-Button clicked
-         */
-        _expand() {
-            if (this.options.expandControls !== true) {
-                // always expand, never collapse
-                this._showState = false;
-            }
-            if (!this._showState) {
-                select(this._button)
-                    .style("display", "none");
-                select(this._container)
-                    .selectAll('svg')
-                    .style("display", "block");
-                select(this._closeButton)
-                    .style("display", "block");
+            // save the position which corresponds to the distance along the route.
+            let position;
+            if (j === coordsLength - 1 && i < data[y].features.length - 1) {
+              position = this._cumulatedDistances[cnt];
             } else {
-                select(this._button)
-                    .style("display", "block");
-                select(this._container)
-                    .selectAll('svg')
-                    .style("display", "none");
-                select(this._closeButton)
-                    .style("display", "none");
-            }
-            this._showState = !this._showState;
-            if (typeof this.options.expandCallback === "function") {
-                this.options.expandCallback(this._showState);
-            }
-        },
-        /**
-         * Removes the svg elements from the d3 chart
-         */
-        _removeChart() {
-            if (this._svg !== undefined) {
-                // remove areas
-                this._svg.selectAll("path.area")
-                    .remove();
-                // remove top border
-                this._svg.selectAll("path.border-top")
-                    .remove();
-                // remove legend
-                this._svg.selectAll(".legend")
-                    .remove();
-                // remove horizontal Line
-                this._svg.selectAll(".lineSelection")
-                    .remove();
-                this._svg.selectAll(".horizontalLine")
-                    .remove();
-                this._svg.selectAll(".horizontalLineText")
-                    .remove();
-            }
-        },
-        /**
-         * Creates a random int between 0 and max
-         */
-        _randomNumber: max => Math.round((Math.random() * (max - 0))),
-        _d3ColorCategorical: [
-            schemeAccent,
-            schemeDark2,
-            schemeSet2,
-            schemeCategory10,
-            schemeSet3,
-            schemePaired
-        ], /**
-         * Prepares the data needed for the height graph
-         */
-        _prepareData() {
-            this._coordinates = [];
-            this._elevations = [];
-            this._cumulatedDistances = [];
-            this._cumulatedDistances.push(0);
-            this._categories = [];
-            const data = this._data
-            let colorScale
-            if (this._mappings === undefined) {
-                const randomNumber = this._randomNumber(this._d3ColorCategorical.length - 1)
-                colorScale = scaleOrdinal(this._d3ColorCategorical[randomNumber]);
-            }
-            for (let y = 0; y < data.length; y++) {
-                let cumDistance = 0
-                this._categories[y] = {
-                    info: {
-                        id: y,
-                        text: data[y].properties.label || data[y].properties.summary
-                    },
-                    distances: [],
-                    attributes: [],
-                    geometries: [],
-                    legend: {}
-                };
-                let i, cnt = 0
-                const usedColors = {}
-                const isMappingFunction = this._mappings !== undefined && typeof this._mappings[data[y].properties.summary] === 'function';
-                for (i = 0; i < data[y].features.length; i++) {
-                    // data is redundant in every element of data which is why we collect it once
-                    let altitude, ptA, ptB, ptDistance
-                    const geometry = []
-                    const coordsLength = data[y].features[i].geometry.coordinates.length
-                    // save attribute types related to blocks
-                    const attributeType = data[y].features[i].properties.attributeType
-                    // check if mappings are defined, otherwise random colors
-                    let text, color
-                    if (this._mappings === undefined) {
-                        if (attributeType in usedColors) {
-                            text = attributeType;
-                            color = usedColors[attributeType];
-                        } else {
-                            text = attributeType;
-                            color = colorScale(i);
-                            usedColors[attributeType] = color;
-                        }
-                    } else {
-                        if (isMappingFunction) {
-                            const result = this._mappings[data[y].properties.summary](attributeType);
-                            text = result.text;
-                            color = result.color;
-                        } else {
-                            text = this._mappings[data[y].properties.summary][attributeType].text;
-                            color = this._mappings[data[y].properties.summary][attributeType].color;
-                        }
-                    }
-                    const attribute = {
-                        type: attributeType, text: text, color: color
-                    }
-                    this._categories[y].attributes.push(attribute);
-                    // add to legend
-                    if (!(attributeType in this._categories[y].legend)) {
-                        this._categories[y].legend[attributeType] = attribute;
-                    }
-                    for (let j = 0; j < coordsLength; j++) {
-                        ptA = new L.LatLng(data[y].features[i].geometry.coordinates[j][1], data[y].features[i].geometry.coordinates[j][0]);
-                        altitude = data[y].features[i].geometry.coordinates[j][2];
-                        // add elevations, coordinates and point distances only once
-                        // last point in feature is first of next which is why we have to juggle with indices
-                        if (j < coordsLength - 1) {
-                            ptB = new L.LatLng(data[y].features[i].geometry.coordinates[j + 1][1], data[y].features[i].geometry.coordinates[j + 1][0]);
-                            ptDistance = ptA.distanceTo(ptB) / 1000;
-                            // calculate distances of specific block
-                            cumDistance += ptDistance;
-                            if (y === 0) {
-                                this._elevations.push(altitude);
-                                this._coordinates.push(ptA);
-                                this._cumulatedDistances.push(cumDistance);
-                            }
-                            cnt += 1;
-                        } else if (j === coordsLength - 1 && i === data[y].features.length - 1) {
-                            if (y === 0) {
-                                this._elevations.push(altitude);
-                                this._coordinates.push(ptB);
-                            }
-                            cnt += 1;
-                        }
-                        // save the position which corresponds to the distance along the route.
-                        let position
-                        if (j === coordsLength - 1 && i < data[y].features.length - 1) {
-                            position = this._cumulatedDistances[cnt];
-                        } else {
-                            position = this._cumulatedDistances[cnt - 1];
-                        }
-                        geometry.push({
-                            altitude: altitude,
-                            position: position,
-                            x: ptA.lng,
-                            y: ptA.lat,
-                            latlng: ptA,
-                            type: text,
-                            areaIdx: i
-                        });
-                    }
-                    this._categories[y].distances.push(cumDistance);
-                    this._categories[y].geometries.push(geometry);
-                }
-                if (y === data.length - 1) {
-                    this._totalDistance = cumDistance;
-                }
-            }
-        },
-        /**
-         * calculates minimum and maximum values for the elevation scale drawn with d3
-         */
-        _calculateElevationBounds() {
-            const max = d3Max(this._elevations)
-            const min = d3Min(this._elevations)
-            const range = max - min
-            this._elevationBounds = {
-                min: range < 10 ? min - 10 : min - 0.1 * range,
-                max: range < 10 ? max + 10 : max + 0.1 * range
-            }
-        },
-        /**
-         * Creates a marker on the map while hovering
-         * @param {Object} ll: actual coordinates of the route
-         * @param {Number} height: height as float
-         * @param {string} type: type of element
-         */
-        _showMapMarker(ll, height, type) {
-            const layerPoint = this._map.latLngToLayerPoint(ll)
-            const normalizedY = layerPoint.y - 75
-            if (!this._mouseHeightFocus) {
-                const heightG = select(".leaflet-overlay-pane svg").append("g")
-                this._mouseHeightFocus = heightG.append('svg:line')
-                    .attr('class', 'height-focus line')
-                    .attr('x2', '0')
-                    .attr('y2', '0')
-                    .attr('x1', '0')
-                    .attr('y1', '0');
-                this._mouseHeightFocusLabel = heightG.append("g")
-                    .attr('class', 'height-focus label');
-                this._mouseHeightFocusLabelRect = this._mouseHeightFocusLabel.append("rect")
-                    .attr('class', 'bBox');
-                this._mouseHeightFocusLabelTextElev = this._mouseHeightFocusLabel.append("text")
-                    .attr('class', 'tspan');
-                this._mouseHeightFocusLabelTextType = this._mouseHeightFocusLabel.append("text")
-                    .attr('class', 'tspan');
-                const pointG = this._pointG = heightG.append("g").attr("class", "height-focus circle")
-                pointG.append("svg:circle")
-                    .attr("r", 5)
-                    .attr("cx", 0)
-                    .attr("cy", 0)
-                    .attr("class", "height-focus circle-lower");
-            }
-            this._mouseHeightFocusLabel.style("display", "block");
-            this._mouseHeightFocus.attr("x1", layerPoint.x)
-                .attr("x2", layerPoint.x)
-                .attr("y1", layerPoint.y)
-                .attr("y2", normalizedY)
-                .style("display", "block");
-            this._pointG.attr("transform", "translate(" + layerPoint.x + "," + layerPoint.y + ")")
-                .style("display", "block");
-            this._mouseHeightFocusLabelRect.attr("x", layerPoint.x + 3)
-                .attr("y", normalizedY)
-                .attr("class", 'bBox');
-            this._mouseHeightFocusLabelTextElev.attr("x", layerPoint.x + 5)
-                .attr("y", normalizedY + 12)
-                .text(height + " m")
-                .attr("class", "tspan mouse-height-box-text");
-            this._mouseHeightFocusLabelTextType.attr("x", layerPoint.x + 5)
-                .attr("y", normalizedY + 24)
-                .text(type)
-                .attr("class", "tspan mouse-height-box-text");
-            const maxWidth = this._dynamicBoxSize("text.tspan")[1]
-            // box size should change for profile none (no type)
-            const maxHeight = (type === "") ? 12 + 6 : 2 * 12 + 6
-            selectAll('.bBox')
-                .attr("width", maxWidth + 10)
-                .attr("height", maxHeight);
-        },
-        /**
-         * Creates the elevation profile
-         */
-        _createChart(idx) {
-            let areas = this._categories.length === 0
-                ? []
-                : this._categories[idx].geometries;
-            this._areasFlattended = [].concat.apply([], areas);
-            for (let i = 0; i < areas.length; i++) {
-                this._appendAreas(areas[i], idx, i);
-            }
-            this._createFocus();
-            this._appendBackground();
-            this._createBorderTopLine();
-            this._createLegend();
-            this._createHorizontalLine();
-        },
-        /**
-         *  Creates focus Line and focus box while hovering
-         */
-        _createFocus() {
-            const boxPosition = this._elevationBounds.min
-            const textDistance = 15
-            if (this._focus) {
-                this._focus.remove();
-                this._focusLineGroup.remove();
+              position = this._cumulatedDistances[cnt - 1];
             }
-            this._focus = this._svg.append("g")
-                .attr("class", "focusbox");
-            // background box
-            this._focusRect = this._focus.append("rect")
-                .attr("x", 3)
-                .attr("y", -this._y(boxPosition))
-                .attr("display", "none");
-            // text line 1
-            this._focusDistance = this._focus.append("text")
-                .attr("x", 7)
-                .attr("y", -this._y(boxPosition) + textDistance)
-                .attr("id", "heightgraph.distance")
-                .text(this._getTranslation('distance') + ':');
-            // text line 2
-            this._focusHeight = this._focus.append("text")
-                .attr("x", 7)
-                .attr("y", -this._y(boxPosition) + 2 * textDistance)
-                .attr("id", "heightgraph.height")
-                .text(this._getTranslation('elevation') + ':');
-            // text line 3
-            this._focusBlockDistance = this._focus.append("text")
-                .attr("x", 7)
-                .attr("y", -this._y(boxPosition) + 3 * textDistance)
-                .attr("id", "heightgraph.blockdistance")
-                .text(this._getTranslation('segment_length') + ':');
-            // text line 4
-            this._focusType = this._focus.append("text")
-                .attr("x", 7)
-                .attr("y", -this._y(boxPosition) + 4 * textDistance)
-                .attr("id", "heightgraph.type")
-                .text(this._getTranslation('type') + ':');
-            this._areaTspan = this._focusBlockDistance.append('tspan')
-                .attr("class", "tspan");
-            this._typeTspan = this._focusType.append('tspan')
-                .attr("class", "tspan");
-            const height = this._dynamicBoxSize(".focusbox text")[0]
-            selectAll('.focusbox rect')
-                .attr("height", height * textDistance + (textDistance / 2))
-                .attr("display", "block");
-            this._focusLineGroup = this._svg.append("g")
-                .attr("class", "focusLine");
-            this._focusLine = this._focusLineGroup.append("line")
-                .attr("y1", 0)
-                .attr("y2", this._y(this._elevationBounds.min));
-            this._distTspan = this._focusDistance.append('tspan')
-                .attr("class", "tspan");
-            this._altTspan = this._focusHeight.append('tspan')
-                .attr("class", "tspan");
+            geometry.push({
+              altitude: altitude,
+              position: position,
+              x: ptA.lng,
+              y: ptA.lat,
+              latlng: ptA,
+              type: text,
+              areaIdx: i,
+            });
+          }
+          this._categories[y].distances.push(cumDistance);
+          this._categories[y].geometries.push(geometry);
+        }
+        if (y === data.length - 1) {
+          this._totalDistance = cumDistance;
+        }
+      }
+    },
+    /**
+     * calculates minimum and maximum values for the elevation scale drawn with d3
+     */
+    _calculateElevationBounds() {
+      const max = d3Max(this._elevations);
+      const min = d3Min(this._elevations);
+      const range = max - min;
+      this._elevationBounds = {
+        min: range < 10 ? min - 10 : min - 0.1 * range,
+        max: range < 10 ? max + 10 : max + 0.1 * range,
+      };
+    },
+    /**
+     * Creates a marker on the map while hovering
+     * @param {Object} ll: actual coordinates of the route
+     * @param {Number} height: height as float
+     * @param {string} type: type of element
+     */
+    _showMapMarker(ll, height, type) {
+      const layerPoint = this._map.latLngToLayerPoint(ll);
+      const normalizedY = layerPoint.y - 75;
+      if (!this._mouseHeightFocus) {
+        const heightG = select(".leaflet-overlay-pane svg").append("g");
+        this._mouseHeightFocus = heightG
+          .append("svg:line")
+          .attr("class", "height-focus line")
+          .attr("x2", "0")
+          .attr("y2", "0")
+          .attr("x1", "0")
+          .attr("y1", "0");
+        this._mouseHeightFocusLabel = heightG
+          .append("g")
+          .attr("class", "height-focus label");
+        this._mouseHeightFocusLabelRect = this._mouseHeightFocusLabel
+          .append("rect")
+          .attr("class", "bBox");
+        this._mouseHeightFocusLabelTextElev = this._mouseHeightFocusLabel
+          .append("text")
+          .attr("class", "tspan");
+        this._mouseHeightFocusLabelTextType = this._mouseHeightFocusLabel
+          .append("text")
+          .attr("class", "tspan");
+        const pointG = (this._pointG = heightG
+          .append("g")
+          .attr("class", "height-focus circle"));
+        pointG
+          .append("svg:circle")
+          .attr("r", 5)
+          .attr("cx", 0)
+          .attr("cy", 0)
+          .attr("class", "height-focus circle-lower");
+      }
+      this._mouseHeightFocusLabel.style("display", "block");
+      this._mouseHeightFocus
+        .attr("x1", layerPoint.x)
+        .attr("x2", layerPoint.x)
+        .attr("y1", layerPoint.y)
+        .attr("y2", normalizedY)
+        .style("display", "block");
+      this._pointG
+        .attr(
+          "transform",
+          "translate(" + layerPoint.x + "," + layerPoint.y + ")"
+        )
+        .style("display", "block");
+      this._mouseHeightFocusLabelRect
+        .attr("x", layerPoint.x + 3)
+        .attr("y", normalizedY)
+        .attr("class", "bBox");
+      this._mouseHeightFocusLabelTextElev
+        .attr("x", layerPoint.x + 5)
+        .attr("y", normalizedY + 12)
+        .text((height * 3.281).toFixed(0) + " ft")
+        .attr("class", "tspan mouse-height-box-text");
+      this._mouseHeightFocusLabelTextType
+        .attr("x", layerPoint.x + 5)
+        .attr("y", normalizedY + 24)
+        .text(type)
+        .attr("class", "tspan mouse-height-box-text");
+      const maxWidth = this._dynamicBoxSize("text.tspan")[1];
+      // box size should change for profile none (no type)
+      const maxHeight = type === "" ? 12 + 6 : 2 * 12 + 6;
+      selectAll(".bBox")
+        .attr("width", maxWidth + 10)
+        .attr("height", maxHeight);
+    },
+    /**
+     * Creates the elevation profile
+     */
+    _createChart(idx) {
+      let areas =
+        this._categories.length === 0 ? [] : this._categories[idx].geometries;
+      this._areasFlattended = [].concat.apply([], areas);
+      for (let i = 0; i < areas.length; i++) {
+        this._appendAreas(areas[i], idx, i);
+      }
+      this._createFocus();
+      this._appendBackground();
+      this._createBorderTopLine();
+      this._createLegend();
+      this._createHorizontalLine();
+    },
+    /**
+     *  Creates focus Line and focus box while hovering
+     */
+    _createFocus() {
+      const boxPosition = this._elevationBounds.min;
+      const textDistance = 15;
+      if (this._focus) {
+        this._focus.remove();
+        this._focusLineGroup.remove();
+      }
+      this._focus = this._svg.append("g").attr("class", "focusbox");
+      // background box
+      this._focusRect = this._focus
+        .append("rect")
+        .attr("x", 3)
+        .attr("y", -this._y(boxPosition))
+        .attr("display", "none");
+      // text line 1
+      this._focusDistance = this._focus
+        .append("text")
+        .attr("x", 7)
+        .attr("y", -this._y(boxPosition) + textDistance)
+        .attr("id", "heightgraph.distance")
+        .text(this._getTranslation("distance") + ":");
+      // text line 2
+      this._focusHeight = this._focus
+        .append("text")
+        .attr("x", 7)
+        .attr("y", -this._y(boxPosition) + 2 * textDistance)
+        .attr("id", "heightgraph.height")
+        .text(this._getTranslation("elevation") + ":");
+      // text line 3
+      this._focusBlockDistance = this._focus
+        .append("text")
+        .attr("x", 7)
+        .attr("y", -this._y(boxPosition) + 3 * textDistance)
+        .attr("id", "heightgraph.blockdistance")
+        .text(this._getTranslation("segment_length") + ":");
+      // text line 4
+      this._focusType = this._focus
+        .append("text")
+        .attr("x", 7)
+        .attr("y", -this._y(boxPosition) + 4 * textDistance)
+        .attr("id", "heightgraph.type")
+        .text(this._getTranslation("type") + ":");
+      this._areaTspan = this._focusBlockDistance
+        .append("tspan")
+        .attr("class", "tspan");
+      this._typeTspan = this._focusType.append("tspan").attr("class", "tspan");
+      const height = this._dynamicBoxSize(".focusbox text")[0];
+      selectAll(".focusbox rect")
+        .attr("height", height * textDistance + textDistance / 2)
+        .attr("display", "block");
+      this._focusLineGroup = this._svg.append("g").attr("class", "focusLine");
+      this._focusLine = this._focusLineGroup
+        .append("line")
+        .attr("y1", 0)
+        .attr("y2", this._y(this._elevationBounds.min));
+      this._distTspan = this._focusDistance
+        .append("tspan")
+        .attr("class", "tspan");
+      this._altTspan = this._focusHeight.append("tspan").attr("class", "tspan");
+    },
+    /**
+     *  Creates horizontal Line for dragging
+     */
+    _createHorizontalLine() {
+      const self = this;
+      this._horizontalLine = this._svg
+        .append("line")
+        .attr("class", "horizontalLine")
+        .attr("x1", 0)
+        .attr("x2", this._width - this._margin.left - this._margin.right)
+        .attr("y1", this._y(this._elevationBounds.min))
+        .attr("y2", this._y(this._elevationBounds.min))
+        .style("stroke", "black");
+      this._elevationValueText = this._svg
+        .append("text")
+        .attr("class", "horizontalLineText")
+        .attr("x", this._width - this._margin.left - this._margin.right - 20)
+        .attr("y", this._y(this._elevationBounds.min) - 10)
+        .attr("fill", "black");
+      //triangle symbol as controller
+      const jsonTriangle = [
+        {
+          x: this._width - this._margin.left - this._margin.right + 7,
+          y: this._y(this._elevationBounds.min),
+          color: "black",
+          type: symbolTriangle,
+          angle: -90,
+          size: 100,
         },
-        /**
-         *  Creates horizontal Line for dragging
-         */
-        _createHorizontalLine() {
-            const self = this
-            this._horizontalLine = this._svg.append("line")
-                .attr("class", "horizontalLine")
-                .attr("x1", 0)
-                .attr("x2", this._width - this._margin.left - this._margin.right)
-                .attr("y1", this._y(this._elevationBounds.min))
-                .attr("y2", this._y(this._elevationBounds.min))
-                .style("stroke", "black");
-            this._elevationValueText = this._svg.append("text")
-                .attr("class", "horizontalLineText")
-                .attr("x", this._width - this._margin.left - this._margin.right - 20)
-                .attr("y", this._y(this._elevationBounds.min) - 10)
-                .attr("fill", "black");
-            //triangle symbol as controller
-            const jsonTriangle = [
-                {
-                    "x": this._width - this._margin.left - this._margin.right + 7,
-                    "y": this._y(this._elevationBounds.min),
-                    "color": "black",
-                    "type": symbolTriangle,
-                    "angle": -90,
-                    "size": 100
-                }
-            ]
-            const dragstart = function (d) {
-                select(this).raise().classed("active", true)
-                select(".horizontalLine").raise().classed("active", true)
-            }
+      ];
+      const dragstart = function (d) {
+        select(this).raise().classed("active", true);
+        select(".horizontalLine").raise().classed("active", true);
+      };
 
-            const dragged = function (d) {
-                const maxY = self._svgHeight
-                let eventY = mouse(self._container)[1] - 10
-                select(this)
-                    .attr("transform", d => "translate(" + d.x + "," + (eventY < 0 ? 0
-                        : eventY > maxY ? maxY
-                            : eventY) + ") rotate(" + d.angle + ")");
-                select(".horizontalLine")
-                    .attr("y1", (eventY < 0 ? 0 : (eventY > maxY ? maxY : eventY)))
-                    .attr("y2", (eventY < 0 ? 0 : (eventY > maxY ? maxY : eventY)));
-                if (eventY >= maxY) {
-                    self._highlightedCoords = [];
-                } else {
-                    self._highlightedCoords = self._findCoordsForY(eventY);
-                }
-                select(".horizontalLineText")
-                    .attr("y", (eventY <= 10 ? 0 : (eventY > maxY ? maxY - 10 : eventY - 10)))
-                    .text(format(".0f")(self._y.invert((eventY < 0 ? 0 : (eventY > maxY ? maxY : eventY)))) + " m");
-                self._removeMarkedSegmentsOnMap();
-                self._markSegmentsOnMap(self._highlightedCoords);
-            }
+      const dragged = function (d) {
+        const maxY = self._svgHeight;
+        let eventY = mouse(self._container)[1] - 10;
+        select(this).attr(
+          "transform",
+          (d) =>
+            "translate(" +
+            d.x +
+            "," +
+            (eventY < 0 ? 0 : eventY > maxY ? maxY : eventY) +
+            ") rotate(" +
+            d.angle +
+            ")"
+        );
+        select(".horizontalLine")
+          .attr("y1", eventY < 0 ? 0 : eventY > maxY ? maxY : eventY)
+          .attr("y2", eventY < 0 ? 0 : eventY > maxY ? maxY : eventY);
+        if (eventY >= maxY) {
+          self._highlightedCoords = [];
+        } else {
+          self._highlightedCoords = self._findCoordsForY(eventY);
+        }
+        select(".horizontalLineText")
+          .attr("y", eventY <= 10 ? 0 : eventY > maxY ? maxY - 10 : eventY - 10)
+          .text(
+            format(".0f")(
+              (
+                self._y.invert(eventY < 0 ? 0 : eventY > maxY ? maxY : eventY) *
+                3.281
+              ).toFixed(0)
+            ) + " ft"
+          );
+        self._removeMarkedSegmentsOnMap();
+        self._markSegmentsOnMap(self._highlightedCoords);
+      };
 
-            const dragend = function (d) {
-                select(this)
-                    .classed("active", false);
-                select(".horizontalLine")
-                    .classed("active", false);
-                self._removeMarkedSegmentsOnMap();
-                self._markSegmentsOnMap(self._highlightedCoords);
-            }
+      const dragend = function (d) {
+        select(this).classed("active", false);
+        select(".horizontalLine").classed("active", false);
+        self._removeMarkedSegmentsOnMap();
+        self._markSegmentsOnMap(self._highlightedCoords);
+      };
 
-            const horizontalDrag = this._svg.selectAll(".horizontal-symbol").data(jsonTriangle).enter().append("path").
-                attr("class", "lineSelection")
-                .attr("d", symbol().type(d => d.type).size(d => d.size))
-                .attr("transform", d => "translate(" + d.x + "," + d.y + ") rotate(" + d.angle + ")")
-                .attr("id", d => d.id)
-                .style("fill", d => d.color)
-                .call(drag().on("start", dragstart).on("drag", dragged).on("end", dragend))
-        },
-        /**
-         * Highlights segments on the map above given elevation value
-         */
-        _markSegmentsOnMap(coords) {
-            if (coords) {
-                if (coords.length > 1) {
-                    // some other leaflet plugins can't deal with multi-Polylines very well
-                    // therefore multiple single polylines are used here
-                    this._markedSegments = L.featureGroup()
-                    for (let linePart of coords) {
-                        L.polyline(
-                            linePart,
-                            { ...this._highlightStyle, ...{ interactive: false } }
-                        ).addTo(this._markedSegments)
-                    }
-                    this._markedSegments.addTo(this._map)
-                        .bringToFront()
-                } else {
-                    this._markedSegments = L.polyline(coords, this._highlightStyle).addTo(this._map);
-                }
-            }
-        },
-        /**
-         * Remove the highlighted segments from the map
-         */
-        _removeMarkedSegmentsOnMap() {
-            if (this._markedSegments !== undefined) {
-                this._map.removeLayer(this._markedSegments);
-            }
-        },
-        /**
-         * Defines the ranges and format of x- and y- scales and appends them
-         */
-        _appendScales() {
-            const shortDist = Boolean(this._totalDistance <= 10)
-            this._x = scaleLinear()
-                .range([0, this._svgWidth]);
-            this._y = scaleLinear()
-                .range([this._svgHeight, 0]);
-            this._x.domain([0, this._totalDistance]);
-            this._y.domain([this._elevationBounds.min, this._elevationBounds.max]);
-            this._xAxis = axisBottom()
-                .scale(this._x)
-            if (shortDist === true) {
-                this._xAxis.tickFormat(d => format(".2f")(d) + " km");
-            } else {
-                this._xAxis.tickFormat(d => format(".0f")(d) + " km");
-            }
-            this._xAxis.ticks(this.options.xTicks ? Math.pow(2, this.options.xTicks) : Math.round(this._svgWidth / 75), "s");
-            this._yAxis = axisLeft()
-                .scale(this._y)
-                .tickFormat(d => d + " m");
-            this._yAxis.ticks(this.options.yTicks ? Math.pow(2, this.options.yTicks) : Math.round(this._svgHeight / 30), "s");
-        },
-        /**
-         * Appends a background and adds mouse handlers
-         */
-        _appendBackground() {
-            const background = this._background = select(this._container)
-                .select("svg")
-                .select("g")
-                .append("rect")
-                .attr("width", this._svgWidth)
-                .attr("height", this._svgHeight)
-                .style("fill", "none")
-                .style("stroke", "none")
-                .style("pointer-events", "all")
-                .on("mousemove.focusbox", this._mousemoveHandler.bind(this))
-                .on("mouseout.focusbox", this._mouseoutHandler.bind(this))
-            if (L.Browser.android) {
-                background.on("touchstart.drag", this._dragHandler.bind(this))
-                    .on("touchstart.drag", this._dragStartHandler.bind(this))
-                    .on("touchstart.focusbox", this._mousemoveHandler.bind(this));
-                L.DomEvent.on(this._container, 'touchend', this._dragEndHandler, this);
-            } else {
-                background.on("mousemove.focusbox", this._mousemoveHandler.bind(this))
-                    .on("mouseout.focusbox", this._mouseoutHandler.bind(this))
-                    .on("mousedown.drag", this._dragStartHandler.bind(this))
-                    .on("mousemove.drag", this._dragHandler.bind(this));
-                L.DomEvent.on(this._container, 'mouseup', this._dragEndHandler, this);
-            }
-        },
-        /**
-         * Appends a grid to the graph
-         */
-        _appendGrid() {
-            this._svg.append("g")
-                .attr("class", "grid")
-                .attr("transform", "translate(0," + this._svgHeight + ")")
-                .call(this._make_x_axis()
-                    .tickSize(-this._svgHeight, 0, 0)
-                    .ticks(Math.round(this._svgWidth / 75))
-                    .tickFormat(""));
-            this._svg.append("g")
-                .attr("class", "grid")
-                .call(this._make_y_axis()
-                    .tickSize(-this._svgWidth, 0, 0)
-                    .ticks(Math.round(this._svgHeight / 30))
-                    .tickFormat(""));
-            this._svg.append('g')
-                .attr("transform", "translate(0," + this._svgHeight + ")")
-                .attr('class', 'x axis')
-                .call(this._xAxis);
-            this._svg.append('g')
-                .attr("transform", "translate(-2,0)")
-                .attr('class', 'y axis')
-                .call(this._yAxis);
-        },
-        /**
-         * Appends the areas to the graph
-         */
-        _appendAreas(block, idx, eleIdx) {
-            const c = this._categories[idx].attributes[eleIdx].color
-            const self = this
-            const area = this._area = d3Area().x(d => {
-                const xDiagonalCoordinate = self._x(d.position)
-                d.xDiagonalCoordinate = xDiagonalCoordinate
-                return xDiagonalCoordinate
-            }).y0(this._svgHeight).y1(d => self._y(d.altitude)).curve(curveLinear)
-            this._areapath = this._svg.append("path")
-                .attr("class", "area");
-            this._areapath.datum(block)
-                .attr("d", this._area)
-                .attr("stroke", c)
-                .styles(this._graphStyle)
-                .style("fill", c)
-                .style("pointer-events", "none");
-        },
-        // grid lines in x axis function
-        _make_x_axis() {
-            return axisBottom()
-                .scale(this._x);
+      const horizontalDrag = this._svg
+        .selectAll(".horizontal-symbol")
+        .data(jsonTriangle)
+        .enter()
+        .append("path")
+        .attr("class", "lineSelection")
+        .attr(
+          "d",
+          symbol()
+            .type((d) => d.type)
+            .size((d) => d.size)
+        )
+        .attr(
+          "transform",
+          (d) => "translate(" + d.x + "," + d.y + ") rotate(" + d.angle + ")"
+        )
+        .attr("id", (d) => d.id)
+        .style("fill", (d) => d.color)
+        .call(
+          drag().on("start", dragstart).on("drag", dragged).on("end", dragend)
+        );
+    },
+    /**
+     * Highlights segments on the map above given elevation value
+     */
+    _markSegmentsOnMap(coords) {
+      if (coords) {
+        if (coords.length > 1) {
+          // some other leaflet plugins can't deal with multi-Polylines very well
+          // therefore multiple single polylines are used here
+          this._markedSegments = L.featureGroup();
+          for (let linePart of coords) {
+            L.polyline(linePart, {
+              ...this._highlightStyle,
+              ...{ interactive: false },
+            }).addTo(this._markedSegments);
+          }
+          this._markedSegments.addTo(this._map).bringToFront();
+        } else {
+          this._markedSegments = L.polyline(coords, this._highlightStyle).addTo(
+            this._map
+          );
+        }
+      }
+    },
+    /**
+     * Remove the highlighted segments from the map
+     */
+    _removeMarkedSegmentsOnMap() {
+      if (this._markedSegments !== undefined) {
+        this._map.removeLayer(this._markedSegments);
+      }
+    },
+    /**
+     * Defines the ranges and format of x- and y- scales and appends them
+     */
+    _appendScales() {
+      const shortDist = Boolean(this._totalDistance <= 10);
+      this._x = scaleLinear().range([0, this._svgWidth]);
+      this._y = scaleLinear().range([this._svgHeight, 0]);
+      this._x.domain([0, this._totalDistance]);
+      this._y.domain([this._elevationBounds.min, this._elevationBounds.max]);
+      this._xAxis = axisBottom().scale(this._x);
+      if (shortDist === true) {
+        this._xAxis.tickFormat((d) => format(".2f")(d / 1.852) + " nm");
+      } else {
+        this._xAxis.tickFormat((d) => format(".0f")(d / 1.852) + " nm");
+      }
+      this._xAxis.ticks(
+        this.options.xTicks
+          ? Math.pow(2, this.options.xTicks)
+          : Math.round(this._svgWidth / 75),
+        "s"
+      );
+      this._yAxis = axisLeft()
+        .scale(this._y)
+        .tickFormat((d) => (d * 3.281).toFixed(0) + " ft");
+      this._yAxis.ticks(
+        this.options.yTicks
+          ? Math.pow(2, this.options.yTicks)
+          : Math.round(this._svgHeight / 30),
+        "s"
+      );
+    },
+    /**
+     * Appends a background and adds mouse handlers
+     */
+    _appendBackground() {
+      const background = (this._background = select(this._container)
+        .select("svg")
+        .select("g")
+        .append("rect")
+        .attr("width", this._svgWidth)
+        .attr("height", this._svgHeight)
+        .style("fill", "none")
+        .style("stroke", "none")
+        .style("pointer-events", "all")
+        .on("mousemove.focusbox", this._mousemoveHandler.bind(this))
+        .on("mouseout.focusbox", this._mouseoutHandler.bind(this)));
+      if (L.Browser.android) {
+        background
+          .on("touchstart.drag", this._dragHandler.bind(this))
+          .on("touchstart.drag", this._dragStartHandler.bind(this))
+          .on("touchstart.focusbox", this._mousemoveHandler.bind(this));
+        L.DomEvent.on(this._container, "touchend", this._dragEndHandler, this);
+      } else {
+        background
+          .on("mousemove.focusbox", this._mousemoveHandler.bind(this))
+          .on("mouseout.focusbox", this._mouseoutHandler.bind(this))
+          .on("mousedown.drag", this._dragStartHandler.bind(this))
+          .on("mousemove.drag", this._dragHandler.bind(this));
+        L.DomEvent.on(this._container, "mouseup", this._dragEndHandler, this);
+      }
+    },
+    /**
+     * Appends a grid to the graph
+     */
+    _appendGrid() {
+      this._svg
+        .append("g")
+        .attr("class", "grid")
+        .attr("transform", "translate(0," + this._svgHeight + ")")
+        .call(
+          this._make_x_axis()
+            .tickSize(-this._svgHeight, 0, 0)
+            .ticks(Math.round(this._svgWidth / 75))
+            .tickFormat("")
+        );
+      this._svg
+        .append("g")
+        .attr("class", "grid")
+        .call(
+          this._make_y_axis()
+            .tickSize(-this._svgWidth, 0, 0)
+            .ticks(Math.round(this._svgHeight / 30))
+            .tickFormat("")
+        );
+      this._svg
+        .append("g")
+        .attr("transform", "translate(0," + this._svgHeight + ")")
+        .attr("class", "x axis")
+        .call(this._xAxis);
+      this._svg
+        .append("g")
+        .attr("transform", "translate(-2,0)")
+        .attr("class", "y axis")
+        .call(this._yAxis);
+    },
+    /**
+     * Appends the areas to the graph
+     */
+    _appendAreas(block, idx, eleIdx) {
+      const c = this._categories[idx].attributes[eleIdx].color;
+      const self = this;
+      const area = (this._area = d3Area()
+        .x((d) => {
+          const xDiagonalCoordinate = self._x(d.position);
+          d.xDiagonalCoordinate = xDiagonalCoordinate;
+          return xDiagonalCoordinate;
+        })
+        .y0(this._svgHeight)
+        .y1((d) => self._y(d.altitude))
+        .curve(curveLinear));
+      this._areapath = this._svg.append("path").attr("class", "area");
+      this._areapath
+        .datum(block)
+        .attr("d", this._area)
+        .attr("stroke", c)
+        .styles(this._graphStyle)
+        .style("fill", c)
+        .style("pointer-events", "none");
+    },
+    // grid lines in x axis function
+    _make_x_axis() {
+      return axisBottom().scale(this._x);
+    },
+    // grid lines in y axis function
+    _make_y_axis() {
+      return axisLeft().scale(this._y);
+    },
+    /**
+     * Appends a selection box for different blocks
+     */
+    _createSelectionBox() {
+      const self = this;
+      const svg = select(this._container).select("svg");
+      const width = this._width - this._margin.right,
+        height = this._height - this._margin.bottom;
+      const verticalItemPosition = height + this._margin.bottom / 2 + 6;
+      const jsonTriangles = [
+        {
+          x: width - 25,
+          y: verticalItemPosition + 3,
+          color: "#000",
+          type: symbolTriangle,
+          id: "leftArrowSelection",
+          angle: 0,
         },
-        // grid lines in y axis function
-        _make_y_axis() {
-            return axisLeft()
-                .scale(this._y);
+        {
+          x: width - 10,
+          y: verticalItemPosition,
+          color: "#000",
+          type: symbolTriangle,
+          id: "rightArrowSelection",
+          angle: 180,
         },
-        /**
-         * Appends a selection box for different blocks
-         */
-        _createSelectionBox() {
-            const self = this
-            const svg = select(this._container).select("svg")
-            const width = this._width - this._margin.right,
-                height = this._height - this._margin.bottom
-            const verticalItemPosition = height + this._margin.bottom / 2 + 6
-            const jsonTriangles = [
-                {
-                    "x": width - 25,
-                    "y": verticalItemPosition + 3,
-                    "color": "#000",
-                    "type": symbolTriangle,
-                    "id": "leftArrowSelection",
-                    "angle": 0
-                }, {
-                    "x": width - 10,
-                    "y": verticalItemPosition,
-                    "color": "#000",
-                    "type": symbolTriangle,
-                    "id": "rightArrowSelection",
-                    "angle": 180
-                }
-            ]
-            // Use update pattern to update existing symbols in case of resize
-            let selectionSign = svg.selectAll(".select-symbol").data(jsonTriangles);
-            // remove any existing selection first
-            selectionSign.remove();
-            // select again
-            selectionSign = svg.selectAll(".select-symbol").data(jsonTriangles)
-            // then add only if needed
-            if (self._data.length > 1) {
-                selectionSign.enter().
-                    append("path").
-                    merge(selectionSign).
-                    attr("class", "select-symbol").
-                    attr("d", symbol().type(d => d.type)).
-                    attr("transform", d => "translate(" + d.x + "," + d.y + ") rotate(" + d.angle + ")").
-                    attr("id", d => d.id).style("fill", d => d.color).
-                    on("mousedown", d => {
-                        if (d.id === "rightArrowSelection") arrowRight()
-                        if (d.id === "leftArrowSelection") arrowLeft()
-                        // fake a drag event from cache values to keep selection
-                        self._gotDragged = true
-                        self._dragStartCoords = self._dragCache.start
-                        self._dragCurrentCoords = self._dragCache.end
-                    })
-            }
-            const chooseSelection = (id) => {
-                if (self._selectionText) self._selectionText.remove();
-                // after cleaning up, there is nothing left to do if there is no data
-                if (self._categories.length === 0) return;
-                const type = self._categories[id].info
-                if (typeof self.options.chooseSelectionCallback === "function") {
-                    self.options.chooseSelectionCallback(id, type);
-                }
-                const data = [
-                    {
-                        "selection": type.text
-                    }
-                ]
-                self._selectionText = svg.selectAll('selection_text')
-                    .data(data)
-                    .enter()
-                    .append('text')
-                    .attr("x", width - 35)
-                    .attr("y", verticalItemPosition + 4)
-                    .text(d => d.selection)
-                    .attr("class", "select-info")
-                    .attr("id", "selectionText")
-                    .attr("text-anchor", "end")
-            }
-
-            chooseSelection(this.options.selectedAttributeIdx);
+      ];
+      // Use update pattern to update existing symbols in case of resize
+      let selectionSign = svg.selectAll(".select-symbol").data(jsonTriangles);
+      // remove any existing selection first
+      selectionSign.remove();
+      // select again
+      selectionSign = svg.selectAll(".select-symbol").data(jsonTriangles);
+      // then add only if needed
+      if (self._data.length > 1) {
+        selectionSign
+          .enter()
+          .append("path")
+          .merge(selectionSign)
+          .attr("class", "select-symbol")
+          .attr(
+            "d",
+            symbol().type((d) => d.type)
+          )
+          .attr(
+            "transform",
+            (d) => "translate(" + d.x + "," + d.y + ") rotate(" + d.angle + ")"
+          )
+          .attr("id", (d) => d.id)
+          .style("fill", (d) => d.color)
+          .on("mousedown", (d) => {
+            if (d.id === "rightArrowSelection") arrowRight();
+            if (d.id === "leftArrowSelection") arrowLeft();
+            // fake a drag event from cache values to keep selection
+            self._gotDragged = true;
+            self._dragStartCoords = self._dragCache.start;
+            self._dragCurrentCoords = self._dragCache.end;
+          });
+      }
+      const chooseSelection = (id) => {
+        if (self._selectionText) self._selectionText.remove();
+        // after cleaning up, there is nothing left to do if there is no data
+        if (self._categories.length === 0) return;
+        const type = self._categories[id].info;
+        if (typeof self.options.chooseSelectionCallback === "function") {
+          self.options.chooseSelectionCallback(id, type);
+        }
+        const data = [
+          {
+            selection: type.text,
+          },
+        ];
+        self._selectionText = svg
+          .selectAll("selection_text")
+          .data(data)
+          .enter()
+          .append("text")
+          .attr("x", width - 35)
+          .attr("y", verticalItemPosition + 4)
+          .text((d) => d.selection)
+          .attr("class", "select-info")
+          .attr("id", "selectionText")
+          .attr("text-anchor", "end");
+      };
 
-            let arrowRight = () => {
-                let idx = self.options.selectedAttributeIdx += 1
-                if (idx === self._categories.length) {
-                    self.options.selectedAttributeIdx = idx = 0
-                }
-                chooseSelection(idx)
-                self._removeChart()
-                self._removeMarkedSegmentsOnMap()
-                self._createChart(idx)
-            }
+      chooseSelection(this.options.selectedAttributeIdx);
 
-            let arrowLeft = () => {
-                let idx = self.options.selectedAttributeIdx -= 1
-                if (idx === -1) {
-                    self.options.selectedAttributeIdx = idx = self._categories.length - 1
-                }
-                chooseSelection(idx)
-                self._removeChart()
-                self._removeMarkedSegmentsOnMap()
-                self._createChart(idx)
-            }
-        },
-        /**
-         * Creates and appends legend to chart
-         */
-        _createLegend() {
-            const self = this
-            const data = []
-            if (this._categories.length > 0) {
-                for (let item in this._categories[this.options.selectedAttributeIdx].legend) {
-                    data.push(this._categories[this.options.selectedAttributeIdx].legend[item]);
-                }
-            }
-            const height = this._height - this._margin.bottom
-            const verticalItemPosition = height + this._margin.bottom / 2
-            const leg = [
-                {
-                    "text": this._getTranslation("legend")
-                }
-            ]
-            const legendRectSize = 7
-            const legendSpacing = 7
-            const legend = this._svg.selectAll(".hlegend-hover").data(data).enter().append("g").attr("class", "legend").
-                style("display", "none").attr("transform", (d, i) => {
-                    const height = legendRectSize + legendSpacing
-                    const offset = height * 2
-                    const horizontal = legendRectSize - 15
-                    const vertical = i * height - offset
-                    return "translate(" + horizontal + "," + vertical + ")"
-                })
-            const legendRect = legend.append('rect')
-                .attr('class', 'legend-rect')
-                .attr('x', 15)
-                .attr('y', 6 * 6)
-                .attr('width', 6)
-                .attr('height', 6);
-            if (Object.keys(this._graphStyle).length !== 0) {
-                legendRect.styles(this._graphStyle)
-                    .style('stroke', (d, i) => d.color)
-                    .style('fill', (d, i) => d.color);
-            } else {
-                legendRect.style('stroke', 'black')
-                    .style('fill', (d, i) => d.color);
-            }
-            legend.append('text')
-                .attr('class', 'legend-text')
-                .attr('x', 30)
-                .attr('y', 6 * 7)
-                .text((d, i) => {
-                    const textProp = d.text
-                    self._boxBoundY = (height - (2 * height / 3) + 7) * i;
-                    return textProp;
-                });
-            let legendHover = this._svg.selectAll('.legend-hover')
-                .data(leg)
-                .enter()
-                .append('g')
-                .attr('class', 'legend-hover');
-            this._showLegend = false
-            legendHover.append('text')
-                .attr('x', 15)
-                .attr('y', verticalItemPosition)
-                .attr('text-anchor', "start")
-                .text((d, i) => d.text)
-                .on('mouseover', () => {
-                    selectAll('.legend')
-                        .style("display", "block");
-                })
-                .on('mouseleave', () => {
-                    if (!this._showLegend) {
-                        selectAll('.legend')
-                            .style("display", "none");
-                    }
-                })
-                .on('click', () => {
-                    this._showLegend = !this._showLegend
-                })
-                ;
-        }, /**
-         * calculates the margins of boxes
-         * @param {String} className: name of the class
-         * @return {array} borders: number of text lines, widest range of text
-         */
-        _dynamicBoxSize(className) {
-            const cnt = selectAll(className).nodes().length
-            const widths = []
-            for (let i = 0; i < cnt; i++) {
-                widths.push(selectAll(className)
-                    .nodes()[i].getBoundingClientRect()
-                    .width);
-            }
-            const maxWidth = d3Max(widths)
-            return [cnt, maxWidth];
-        },
-        /**
-         * Creates top border line on graph
-         */
-        _createBorderTopLine() {
-            const self = this
-            const data = this._areasFlattended
-            const borderTopLine = line()
-                .x(d => {
-                    const x = self._x
-                    return x(d.position)
-                })
-                .y(d => {
-                    const y = self._y
-                    return y(d.altitude)
-                })
-                .curve(curveBasis)
-            this._svg.append("svg:path")
-                .attr("d", borderTopLine(data))
-                .attr('class', 'border-top');
-        },
-        /*
-         * Handles the mouseout event when the mouse leaves the background
-         */
-        _mouseoutHandler() {
-            for (let param of ['_focusLine', '_focus', '_pointG', '_mouseHeightFocus', '_mouseHeightFocusLabel'])
-                if (this[param]) {
-                    this[param].style('display', 'none');
-                }
-        },
-        /*
-         * Handles the mouseout event and clears the current point info.
-         * @param {int} delay - time before markers are removed in milliseconds
-         */
-        mapMouseoutHandler(delay = 1000) {
-            if (this.mouseoutDelay) {
-                window.clearTimeout(this.mouseoutDelay)
-            }
-            this.mouseoutDelay = window.setTimeout(() => {
-                this._mouseoutHandler();
-            }, delay)
-        },
-        /*
-         * Handles the mouseover the map and displays distance and altitude level.
-         * Since this does a lookup of the point on the graph
-         * the closest to the given latlng on the provided event, it could be slow.
-         */
-        mapMousemoveHandler(event, { showMapMarker: showMapMarker = true } = {}) {
-            if (this._areasFlattended === false) {
-                return;
-            }
-            // initialize the vars for the closest item calculation
-            let closestItem = null;
-            // large enough to be trumped by any point on the chart
-            let closestDistance = 2 * Math.pow(100, 2);
-            // consider a good enough match if the given point (lat and lng) is within
-            // 1.1 meters of a point on the chart (there are 111,111 meters in a degree)
-            const exactMatchRounding = 1.1 / 111111;
-            for (let item of this._areasFlattended) {
-                let latDiff = event.latlng.lat - item.latlng.lat;
-                let lngDiff = event.latlng.lng - item.latlng.lng;
-                // first check for an almost exact match; it's simple and avoid further calculations
-                if (Math.abs(latDiff) < exactMatchRounding && Math.abs(lngDiff) < exactMatchRounding) {
-                    this._internalMousemoveHandler(item, showMapMarker);
-                    break;
-                }
-                // calculate the squared distance from the current to the given;
-                // it's the squared distance, to avoid the expensive square root
-                const distance = Math.pow(latDiff, 2) + Math.pow(lngDiff, 2);
-                if (distance < closestDistance) {
-                    closestItem = item;
-                    closestDistance = distance;
-                }
-            }
+      let arrowRight = () => {
+        let idx = (self.options.selectedAttributeIdx += 1);
+        if (idx === self._categories.length) {
+          self.options.selectedAttributeIdx = idx = 0;
+        }
+        chooseSelection(idx);
+        self._removeChart();
+        self._removeMarkedSegmentsOnMap();
+        self._createChart(idx);
+      };
 
-            if (closestItem) this._internalMousemoveHandler(closestItem, showMapMarker);
-        },
-        /*
-         * Handles the mouseover the chart and displays distance and altitude level
-         */
-        _mousemoveHandler(d, i, ctx) {
-            const coords = mouse(this._svg.node())
-            const item = this._areasFlattended[this._findItemForX(coords[0])];
-            if (item) this._internalMousemoveHandler(item);
-        },
-        /*
-         * Handles the mouseover, given the current item the mouse is over
-         */
-        _internalMousemoveHandler(item, showMapMarker = true) {
-            let areaLength
-            const alt = item.altitude, dist = item.position,
-                ll = item.latlng, areaIdx = item.areaIdx, type = item.type
-            const boxWidth = this._dynamicBoxSize(".focusbox text")[1] + 10
-            if (areaIdx === 0) {
-                areaLength = this._categories[this.options.selectedAttributeIdx].distances[areaIdx];
-            } else {
-                areaLength = this._categories[this.options.selectedAttributeIdx].distances[areaIdx] - this._categories[this.options.selectedAttributeIdx].distances[areaIdx - 1];
-            }
-            if (showMapMarker) {
-                this._showMapMarker(ll, alt, type);
-            }
-            this._distTspan.text(" " + dist.toFixed(1) + ' km');
-            this._altTspan.text(" " + alt + ' m');
-            this._areaTspan.text(" " + areaLength.toFixed(1) + ' km');
-            this._typeTspan.text(" " + type);
-            this._focusRect.attr("width", boxWidth);
-            this._focusLine.style("display", "block")
-                .attr('x1', this._x(dist))
-                .attr('x2', this._x(dist));
-            const xPositionBox = this._x(dist) - (boxWidth + 5)
-            const totalWidth = this._width - this._margin.left - this._margin.right
-            if (this._x(dist) + boxWidth < totalWidth) {
-                this._focus.style("display", "initial")
-                    .attr("transform", "translate(" + this._x(dist) + "," + this._y(this._elevationBounds.min) + ")");
-            }
-            if (this._x(dist) + boxWidth > totalWidth) {
-                this._focus.style("display", "initial")
-                    .attr("transform", "translate(" + xPositionBox + "," + this._y(this._elevationBounds.min) + ")");
-            }
-        },
-        /*
-         * Finds a data entry for a given x-coordinate of the diagram
-         */
-        _findItemForX(x) {
-            const bisect = bisector(d => d.position).left
-            const xInvert = this._x.invert(x)
-            return bisect(this._areasFlattended, xInvert);
+      let arrowLeft = () => {
+        let idx = (self.options.selectedAttributeIdx -= 1);
+        if (idx === -1) {
+          self.options.selectedAttributeIdx = idx = self._categories.length - 1;
+        }
+        chooseSelection(idx);
+        self._removeChart();
+        self._removeMarkedSegmentsOnMap();
+        self._createChart(idx);
+      };
+    },
+    /**
+     * Creates and appends legend to chart
+     */
+    _createLegend() {
+      const self = this;
+      const data = [];
+      if (this._categories.length > 0) {
+        for (let item in this._categories[this.options.selectedAttributeIdx]
+          .legend) {
+          data.push(
+            this._categories[this.options.selectedAttributeIdx].legend[item]
+          );
+        }
+      }
+      const height = this._height - this._margin.bottom;
+      const verticalItemPosition = height + this._margin.bottom / 2;
+      const leg = [
+        {
+          text: this._getTranslation("legend"),
         },
-        /*
-         * Finds data entries above a given y-elevation value and returns geo-coordinates
-         */
-        _findCoordsForY(y) {
-            let bisect = (b, yInvert) => {
-                //save indexes of elevation values above the horizontal line
-                const list = []
-                for (let i = 0; i < b.length; i++) {
-                    if (b[i].altitude >= yInvert) {
-                        list.push(i);
-                    }
-                }
-                //split index list into coherent blocks of coordinates
-                const newList = []
-                let start = 0
-                for (let j = 0; j < list.length - 1; j++) {
-                    if (list[j + 1] !== list[j] + 1) {
-                        newList.push(list.slice(start, j + 1));
-                        start = j + 1;
-                    }
-                }
-                newList.push(list.slice(start, list.length));
-                //get lat lon coordinates based on indexes
-                for (let k = 0; k < newList.length; k++) {
-                    for (let l = 0; l < newList[k].length; l++) {
-                        newList[k][l] = b[newList[k][l]].latlng;
-                    }
-                }
-                return newList;
-            }
+      ];
+      const legendRectSize = 7;
+      const legendSpacing = 7;
+      const legend = this._svg
+        .selectAll(".hlegend-hover")
+        .data(data)
+        .enter()
+        .append("g")
+        .attr("class", "legend")
+        .style("display", "none")
+        .attr("transform", (d, i) => {
+          const height = legendRectSize + legendSpacing;
+          const offset = height * 2;
+          const horizontal = legendRectSize - 15;
+          const vertical = i * height - offset;
+          return "translate(" + horizontal + "," + vertical + ")";
+        });
+      const legendRect = legend
+        .append("rect")
+        .attr("class", "legend-rect")
+        .attr("x", 15)
+        .attr("y", 6 * 6)
+        .attr("width", 6)
+        .attr("height", 6);
+      if (Object.keys(this._graphStyle).length !== 0) {
+        legendRect
+          .styles(this._graphStyle)
+          .style("stroke", (d, i) => d.color)
+          .style("fill", (d, i) => d.color);
+      } else {
+        legendRect.style("stroke", "black").style("fill", (d, i) => d.color);
+      }
+      legend
+        .append("text")
+        .attr("class", "legend-text")
+        .attr("x", 30)
+        .attr("y", 6 * 7)
+        .text((d, i) => {
+          const textProp = d.text;
+          self._boxBoundY = (height - (2 * height) / 3 + 7) * i;
+          return textProp;
+        });
+      let legendHover = this._svg
+        .selectAll(".legend-hover")
+        .data(leg)
+        .enter()
+        .append("g")
+        .attr("class", "legend-hover");
+      this._showLegend = false;
+      legendHover
+        .append("text")
+        .attr("x", 15)
+        .attr("y", verticalItemPosition)
+        .attr("text-anchor", "start")
+        .text((d, i) => d.text)
+        .on("mouseover", () => {
+          selectAll(".legend").style("display", "block");
+        })
+        .on("mouseleave", () => {
+          if (!this._showLegend) {
+            selectAll(".legend").style("display", "none");
+          }
+        })
+        .on("click", () => {
+          this._showLegend = !this._showLegend;
+        });
+    },
+    /**
+     * calculates the margins of boxes
+     * @param {String} className: name of the class
+     * @return {array} borders: number of text lines, widest range of text
+     */ _dynamicBoxSize(className) {
+      const cnt = selectAll(className).nodes().length;
+      const widths = [];
+      for (let i = 0; i < cnt; i++) {
+        widths.push(
+          selectAll(className).nodes()[i].getBoundingClientRect().width
+        );
+      }
+      const maxWidth = d3Max(widths);
+      return [cnt, maxWidth];
+    },
+    /**
+     * Creates top border line on graph
+     */
+    _createBorderTopLine() {
+      const self = this;
+      const data = this._areasFlattended;
+      const borderTopLine = line()
+        .x((d) => {
+          const x = self._x;
+          return x(d.position);
+        })
+        .y((d) => {
+          const y = self._y;
+          return y(d.altitude);
+        })
+        .curve(curveBasis);
+      this._svg
+        .append("svg:path")
+        .attr("d", borderTopLine(data))
+        .attr("class", "border-top");
+    },
+    /*
+     * Handles the mouseout event when the mouse leaves the background
+     */
+    _mouseoutHandler() {
+      for (let param of [
+        "_focusLine",
+        "_focus",
+        "_pointG",
+        "_mouseHeightFocus",
+        "_mouseHeightFocusLabel",
+      ])
+        if (this[param]) {
+          this[param].style("display", "none");
+        }
+    },
+    /*
+     * Handles the mouseout event and clears the current point info.
+     * @param {int} delay - time before markers are removed in milliseconds
+     */
+    mapMouseoutHandler(delay = 1000) {
+      if (this.mouseoutDelay) {
+        window.clearTimeout(this.mouseoutDelay);
+      }
+      this.mouseoutDelay = window.setTimeout(() => {
+        this._mouseoutHandler();
+      }, delay);
+    },
+    /*
+     * Handles the mouseover the map and displays distance and altitude level.
+     * Since this does a lookup of the point on the graph
+     * the closest to the given latlng on the provided event, it could be slow.
+     */
+    mapMousemoveHandler(event, { showMapMarker: showMapMarker = true } = {}) {
+      if (this._areasFlattended === false) {
+        return;
+      }
+      // initialize the vars for the closest item calculation
+      let closestItem = null;
+      // large enough to be trumped by any point on the chart
+      let closestDistance = 2 * Math.pow(100, 2);
+      // consider a good enough match if the given point (lat and lng) is within
+      // 1.1 meters of a point on the chart (there are 111,111 meters in a degree)
+      const exactMatchRounding = 1.1 / 111111;
+      for (let item of this._areasFlattended) {
+        let latDiff = event.latlng.lat - item.latlng.lat;
+        let lngDiff = event.latlng.lng - item.latlng.lng;
+        // first check for an almost exact match; it's simple and avoid further calculations
+        if (
+          Math.abs(latDiff) < exactMatchRounding &&
+          Math.abs(lngDiff) < exactMatchRounding
+        ) {
+          this._internalMousemoveHandler(item, showMapMarker);
+          break;
+        }
+        // calculate the squared distance from the current to the given;
+        // it's the squared distance, to avoid the expensive square root
+        const distance = Math.pow(latDiff, 2) + Math.pow(lngDiff, 2);
+        if (distance < closestDistance) {
+          closestItem = item;
+          closestDistance = distance;
+        }
+      }
 
-            const yInvert = this._y.invert(y)
-            return bisect(this._areasFlattended, yInvert);
-        },
-        /*
-         * Checks the user passed translations, if they don't exist, fallback to the default translations
-         */
-        _getTranslation(key) {
-            if (this.options.translation[key])
-                return this.options.translation[key];
-            if (this._defaultTranslation[key])
-                return this._defaultTranslation[key];
-            console.error("Unexpected error when looking up the translation for " + key);
-            return 'No translation found';
+      if (closestItem)
+        this._internalMousemoveHandler(closestItem, showMapMarker);
+    },
+    /*
+     * Handles the mouseover the chart and displays distance and altitude level
+     */
+    _mousemoveHandler(d, i, ctx) {
+      const coords = mouse(this._svg.node());
+      const item = this._areasFlattended[this._findItemForX(coords[0])];
+      if (item) this._internalMousemoveHandler(item);
+    },
+    /*
+     * Handles the mouseover, given the current item the mouse is over
+     */
+    _internalMousemoveHandler(item, showMapMarker = true) {
+      let areaLength;
+      const alt = item.altitude,
+        dist = item.position,
+        ll = item.latlng,
+        areaIdx = item.areaIdx,
+        type = item.type;
+      const boxWidth = this._dynamicBoxSize(".focusbox text")[1] + 10;
+      if (areaIdx === 0) {
+        areaLength = this._categories[this.options.selectedAttributeIdx]
+          .distances[areaIdx];
+      } else {
+        areaLength =
+          this._categories[this.options.selectedAttributeIdx].distances[
+            areaIdx
+          ] -
+          this._categories[this.options.selectedAttributeIdx].distances[
+            areaIdx - 1
+          ];
+      }
+      if (showMapMarker) {
+        this._showMapMarker(ll, alt, type);
+      }
+      this._distTspan.text(" " + (dist / 1.852).toFixed(1) + "nm");
+      this._altTspan.text(" " + (alt * 3.281).toFixed(0) + " ft");
+      this._areaTspan.text(" " + (areaLength / 1.852).toFixed(1) + " nm");
+      this._typeTspan.text(" " + type);
+      this._focusRect.attr("width", boxWidth);
+      this._focusLine
+        .style("display", "block")
+        .attr("x1", this._x(dist))
+        .attr("x2", this._x(dist));
+      const xPositionBox = this._x(dist) - (boxWidth + 5);
+      const totalWidth = this._width - this._margin.left - this._margin.right;
+      if (this._x(dist) + boxWidth < totalWidth) {
+        this._focus
+          .style("display", "initial")
+          .attr(
+            "transform",
+            "translate(" +
+              this._x(dist) +
+              "," +
+              this._y(this._elevationBounds.min) +
+              ")"
+          );
+      }
+      if (this._x(dist) + boxWidth > totalWidth) {
+        this._focus
+          .style("display", "initial")
+          .attr(
+            "transform",
+            "translate(" +
+              xPositionBox +
+              "," +
+              this._y(this._elevationBounds.min) +
+              ")"
+          );
+      }
+    },
+    /*
+     * Finds a data entry for a given x-coordinate of the diagram
+     */
+    _findItemForX(x) {
+      const bisect = bisector((d) => d.position).left;
+      const xInvert = this._x.invert(x);
+      return bisect(this._areasFlattended, xInvert);
+    },
+    /*
+     * Finds data entries above a given y-elevation value and returns geo-coordinates
+     */
+    _findCoordsForY(y) {
+      let bisect = (b, yInvert) => {
+        //save indexes of elevation values above the horizontal line
+        const list = [];
+        for (let i = 0; i < b.length; i++) {
+          if (b[i].altitude >= yInvert) {
+            list.push(i);
+          }
         }
-    });
-    L.control.heightgraph = function (options) {
-        return new L.Control.Heightgraph(options)
-    }
+        //split index list into coherent blocks of coordinates
+        const newList = [];
+        let start = 0;
+        for (let j = 0; j < list.length - 1; j++) {
+          if (list[j + 1] !== list[j] + 1) {
+            newList.push(list.slice(start, j + 1));
+            start = j + 1;
+          }
+        }
+        newList.push(list.slice(start, list.length));
+        //get lat lon coordinates based on indexes
+        for (let k = 0; k < newList.length; k++) {
+          for (let l = 0; l < newList[k].length; l++) {
+            newList[k][l] = b[newList[k][l]].latlng;
+          }
+        }
+        return newList;
+      };
+
+      const yInvert = this._y.invert(y);
+      return bisect(this._areasFlattended, yInvert);
+    },
+    /*
+     * Checks the user passed translations, if they don't exist, fallback to the default translations
+     */
+    _getTranslation(key) {
+      if (this.options.translation[key]) return this.options.translation[key];
+      if (this._defaultTranslation[key]) return this._defaultTranslation[key];
+      console.error(
+        "Unexpected error when looking up the translation for " + key
+      );
+      return "No translation found";
+    },
+  });
+  L.control.heightgraph = function (options) {
+    return new L.Control.Heightgraph(options);
+  };
 
-    return L.Control.Heightgraph
-}, window))
+  return L.Control.Heightgraph;
+}, window);
\ No newline at end of file
